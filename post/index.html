<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posts &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.39" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Posts &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Posts &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">27 Apr 2018, 17:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/terraform_azure_secret/" class="post-title">TerraformでAzureのシークレットを受け渡す(ACI/AKS編)</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="動機">動機</h2>

<p>システム開発、運用の現場では、しばしばシークレットの受け渡しをします。代表例はデータベースの接続文字列です。データベース作成時に生成した接続文字列をアプリ側で設定するのですが、ひとりでコピペするにせよ、チームメンバー間で受け渡すにせよ、めんどくさく、危険が危ないわけです。</p>

<ul>
<li>いちいちポータルやCLIで接続文字列を出力、コピーして、アプリの設定ファイルや環境変数にペーストしなければいけない

<ul>
<li>めんどくさいし手が滑る</li>
</ul></li>
<li>データベース管理者がアプリ開発者に接続文字列を何らかの手段で渡さないといけない

<ul>
<li>メールとかチャットとかファイルサーバーとか勘弁</li>
</ul></li>
<li>もしくはアプリ開発者にデータベースの接続文字列が読める権限を与えなければいけない

<ul>
<li>本番でも、それやる？</li>
</ul></li>
<li>kubernetes(k8s)のSecretをいちいちkubectlを使って作りたくない

<ul>
<li>Base64符号化とか、うっかり忘れる</li>
</ul></li>
</ul>

<p>つらいですね。シークレットなんて意識したくないのが人情。そこで、Terraformを使った解決法を。</p>

<h2 id="シナリオ">シナリオ</h2>

<p>Azureでコンテナーを使うシナリオを例に紹介します。ACI(Azure Container Instances)とAKS(Azure Container Service - k8s)の2パターンです。</p>

<ul>
<li>Nodeとデータストアを組み合わせた、<a href="https://github.com/ToruMakabe/ImpressAzureBookNode">Todoアプリケーション</a></li>
<li>コンテナーイメージは<a href="https://hub.docker.com/r/torumakabe/nodetodo/">Docker Hub</a>にある</li>
<li>コンテナーでデータストアを運用したくないので、データストアはマネージドサービスを使う</li>
<li>データストアはCosmos DB(MongoDB API)</li>
<li>Cosmos DBへのアクセスに必要な属性をTerraformで参照し、接続文字列(MONGO_URL)を作る

<ul>
<li>接続文字列の渡し方はACI/AKSで異なる</li>
<li>ACI

<ul>
<li>コンテナー作成時に環境変数として接続文字列を渡す</li>
</ul></li>
<li>AKS

<ul>
<li>k8sのSecretとして接続文字列をストアする</li>
<li>コンテナー作成時にSecretを参照し、環境変数として渡す</li>
</ul></li>
</ul></li>
</ul>

<h2 id="検証環境">検証環境</h2>

<ul>
<li>Azure Cloud Shell

<ul>
<li>Terraform v0.11.7</li>
<li>Terraformの認証はCloud Shell組み込み</li>
</ul></li>
<li>Terraform Azure Provider v1.4</li>
<li>Terraform kubernetes Provider v1.1</li>
<li>AKS kubernetes 1.9.6</li>
</ul>

<h2 id="aciの場合">ACIの場合</h2>

<p>ざっと以下の流れです。</p>

<ol>
<li>リソースグループ作成</li>
<li>Cosmos DBアカウント作成</li>
<li>ACIコンテナーグループ作成 (Cosmos DB属性から接続文字列を生成)</li>
</ol>

<p>var.で参照している変数は、別ファイルに書いています。</p>

<p>[main.tf]</p>

<pre><code>resource &quot;azurerm_resource_group&quot; &quot;rg&quot; {
  name     = &quot;${var.resource_group_name}&quot;
  location = &quot;${var.resource_group_location}&quot;
}

resource &quot;random_integer&quot; &quot;ri&quot; {
  min = 10000
  max = 99999
}

resource &quot;azurerm_cosmosdb_account&quot; &quot;db&quot; {
  name                = &quot;your-cosmos-db-${random_integer.ri.result}&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  offer_type          = &quot;Standard&quot;
  kind                = &quot;MongoDB&quot;

  enable_automatic_failover = true

  consistency_policy {
    consistency_level       = &quot;BoundedStaleness&quot;
    max_interval_in_seconds = 10
    max_staleness_prefix    = 200
  }

  geo_location {
    location          = &quot;${azurerm_resource_group.rg.location}&quot;
    failover_priority = 0
  }

  geo_location {
    location          = &quot;${var.failover_location}&quot;
    failover_priority = 1
  }
}

resource &quot;azurerm_container_group&quot; &quot;aci-todo&quot; {
  name                = &quot;aci-todo&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  ip_address_type     = &quot;public&quot;
  dns_name_label      = &quot;yourtodo&quot;
  os_type             = &quot;linux&quot;

  container {
    name   = &quot;todo&quot;
    image  = &quot;torumakabe/nodetodo&quot;
    cpu    = &quot;1&quot;
    memory = &quot;1.5&quot;
    port   = &quot;8080&quot;

    environment_variables {
      &quot;MONGO_URL&quot; = &quot;mongodb://${azurerm_cosmosdb_account.db.name}:${azurerm_cosmosdb_account.db.primary_master_key}@${azurerm_cosmosdb_account.db.name}.documents.azure.com:10255/?ssl=true&quot;
    }
  }
}
</code></pre>

<p>containerのenvironment_variablesブロックでCosmos DBの属性を参照し、接続文字列を生成しています。簡単ですね。これで接続文字列コピペ作業から解放されます。</p>

<h2 id="aks">AKS</h2>

<p>AKSの場合、流れは以下の通りです。</p>

<ol>
<li>リソースグループ作成</li>
<li>Cosmos DBアカウント作成</li>
<li>AKSクラスター作成</li>
<li>k8s Secretを作成 (Cosmos DB属性から接続文字列生成)</li>
<li>k8s Secretをコンテナーの環境変数として参照し、アプリをデプロイ</li>
</ol>

<p>[main.tf]</p>

<pre><code>resource &quot;azurerm_resource_group&quot; &quot;rg&quot; {
  name     = &quot;${var.resource_group_name}&quot;
  location = &quot;${var.resource_group_location}&quot;
}

resource &quot;random_integer&quot; &quot;ri&quot; {
  min = 10000
  max = 99999
}

resource &quot;azurerm_cosmosdb_account&quot; &quot;db&quot; {
  name                = &quot;your-cosmos-db-${random_integer.ri.result}&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  offer_type          = &quot;Standard&quot;
  kind                = &quot;MongoDB&quot;

  enable_automatic_failover = true

  consistency_policy {
    consistency_level       = &quot;BoundedStaleness&quot;
    max_interval_in_seconds = 10
    max_staleness_prefix    = 200
  }

  geo_location {
    location          = &quot;${azurerm_resource_group.rg.location}&quot;
    failover_priority = 0
  }

  geo_location {
    location          = &quot;${var.failover_location}&quot;
    failover_priority = 1
  }
}

resource &quot;azurerm_kubernetes_cluster&quot; &quot;aks&quot; {
  name                = &quot;yourakstf&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  dns_prefix          = &quot;yourakstf&quot;
  kubernetes_version  = &quot;1.9.6&quot;

  linux_profile {
    admin_username = &quot;${var.admin_username}&quot;

    ssh_key {
      key_data = &quot;${var.key_data}&quot;
    }
  }

  agent_pool_profile {
    name            = &quot;default&quot;
    count           = 3
    vm_size         = &quot;Standard_B2ms&quot;
    os_type         = &quot;Linux&quot;
    os_disk_size_gb = 30
  }

  service_principal {
    client_id     = &quot;${var.client_id}&quot;
    client_secret = &quot;${var.client_secret}&quot;
  }
}

provider &quot;kubernetes&quot; {
  host = &quot;${azurerm_kubernetes_cluster.aks.kube_config.0.host}&quot;

  client_certificate     = &quot;${base64decode(azurerm_kubernetes_cluster.aks.kube_config.0.client_certificate)}&quot;
  client_key             = &quot;${base64decode(azurerm_kubernetes_cluster.aks.kube_config.0.client_key)}&quot;
  cluster_ca_certificate = &quot;${base64decode(azurerm_kubernetes_cluster.aks.kube_config.0.cluster_ca_certificate)}&quot;
}

resource &quot;kubernetes_secret&quot; &quot;cosmosdb_secret&quot; {
  metadata {
    name = &quot;cosmosdb-secret&quot;
  }

  data {
    MONGO_URL = &quot;mongodb://${azurerm_cosmosdb_account.db.name}:${azurerm_cosmosdb_account.db.primary_master_key}@${azurerm_cosmosdb_account.db.name}.documents.azure.com:10255/?ssl=true&quot;
  }
}
</code></pre>

<p>Cosmos DB、AKSクラスターを作ったのち、kubernetesプロバイダーを使ってSecretを登録しています。複数のプロバイダーを組み合わせられる、Terraformの特長が活きています。</p>

<p>そしてアプリのデプロイ時に、登録したSecretを指定します。ここからはkubernetesワールドなので、kubectlなどを使います。マニフェストは以下のように。</p>

<p>[todo.yaml]</p>

<pre><code>apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: todoapp
spec:
  selector:
    matchLabels:
      app: todoapp
  replicas: 2
  template:
    metadata:
      labels:
        app: todoapp
    spec:
      containers:
        - name: todoapp
          image: torumakabe/nodetodo
          ports:
            - containerPort: 8080
          env:
            - name: MONGO_URL
              valueFrom:
                secretKeyRef:
                  name: cosmosdb-secret
                  key: MONGO_URL
---
apiVersion: v1
kind: Service
metadata:
  name: todoapp
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: todoapp
</code></pre>

<p>シークレットの中身を見ることなく、コピペもせず、もちろんメールやチャットやファイルも使わず、アプリからCosmos DBへ接続できました。</p>

<p>シークレットに限らず、Terraformの属性参照、変数表現は強力ですので、ぜひ活用してみてください。数多くの<a href="https://www.terraform.io/docs/providers/azurerm/">Azureリソース</a>が対応しています。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">09 Apr 2018, 15:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/myazurecli201804/" class="post-title">俺のAzure CLI 2018春版</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="春の環境リフレッシュ祭り">春の環境リフレッシュ祭り</h2>

<p>最近KubernetesのCLI、kubectlを使う機会が多いのですが、なかなかイケてるんですよ。かゆい所に手が届く感じ。そこで、いい機会なのでAzure CLIまわりも最新の機能やツールで整えようか、というのが今回の動機。気づかないうちに、界隈が充実していた。</p>

<h2 id="俺のおすすめ-3選">俺のおすすめ 3選</h2>

<ul>
<li>デフォルト設定

<ul>
<li>リソースグループやロケーション、出力形式などのデフォルト設定ができる</li>
</ul></li>
<li>エイリアス

<ul>
<li>サブコマンドにエイリアスを付けられる</li>
<li>引数付きの込み入った表現もできる</li>
</ul></li>
<li>VS Code プラグイン

<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli">Azure CLI Toolsプラグイン</a> でazコマンドの編集をコードアシストしてくれる</li>
<li>編集画面上でコマンド選択して実行できる</li>
</ul></li>
</ul>

<h2 id="デフォルト設定">デフォルト設定</h2>

<p>$AZURE_CONFIG_DIR/configファイルで構成設定ができます。$AZURE_CONFIG_DIR の既定値は、Linux/macOS の場合$HOME/.azure、Windowsは%USERPROFILE%.azure。</p>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-configuration?view=azure-cli-latest">Azure CLI 2.0 の構成</a></p>

<p>まず変えたいところは、コマンドの出力形式。デフォルトはJSON。わたしのお気持ちは、普段はTable形式、掘りたい時だけJSON。なのでデフォルトをtableに変えます。</p>

<pre><code>[core]
output = table
</code></pre>

<p>そしてデフォルトのリソースグループを設定します。以前は「デフォルト設定すると、気づかないところで事故るから、やらない」という主義だったのですが、Kubernetesのdefault namespaceの扱いを見て「ああ、これもありかなぁ」と改宗したところ。</p>

<pre><code>[defaults]
group = default-ejp-rg
</code></pre>

<p>他にもロケーションやストレージアカウントなどを設定できます。ロケーションはリソースグループの属性を継承させたい、もしくは明示したい場合が多いので、設定していません。</p>

<p>ということで、急ぎUbuntuの仮想マシンが欲しいぜという場合、az vm createコマンドの必須パラメーター、-gと-lを省略できるようになったので、さくっと以下のコマンドでできるようになりました。</p>

<p>デフォルト指定したリソースグループを、任意のロケーションに作ってある前提です。</p>

<pre><code>az vm create -n yoursmplvm01 --image UbuntuLTS
</code></pre>

<h2 id="エイリアス">エイリアス</h2>

<p>$AZURE_CONFIG_DIR/aliasにエイリアスを書けます。</p>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest">Azure CLI 2.0 のエイリアス拡張機能</a></p>

<p>前提はAzure CLI v2.0.28以降です。以下のコマンドでエイリアス拡張を導入できます。現時点ではプレビュー扱いなのでご注意を。</p>

<pre><code>az extension add --name alias
</code></pre>

<p>ひとまずわたしは以下3カテゴリのエイリアスを登録しました。</p>

<h3 id="頻繁に打つからできる限り短くしたい系">頻繁に打つからできる限り短くしたい系</h3>

<pre><code>[ls]
command = list

[nw]
command = network

[pip]
command = public-ip

[fa]
command = functionapp
</code></pre>

<p>例えばデフォルトリソースグループでパブリックIP公開してるか確認したいな、と思った時は、az network public-ip listじゃなくて、こう打てます。</p>

<pre><code>$ az nw pip ls
Name                  ResourceGroup    Location    Zones    AddressVersion    AllocationMethod      IdleTimeoutInMinutes
ProvisioningState
--------------------  ---------------  ----------  -------  ----------------  ------------------  ----------------------
-------------------
yoursmplvm01PublicIP  default-ejp-rg   japaneast            IPv4              Dynamic                                  4
Succeeded
</code></pre>

<h3 id="クエリー打つのがめんどくさい系">クエリー打つのがめんどくさい系</h3>

<p>VMに紐づいてるパブリックIPを確認したいときは、こんなエイリアス。</p>

<pre><code>[get-vm-pip]
command = vm list-ip-addresses --query [0].virtualMachine.network.publicIpAddresses[0].ipAddress
</code></pre>

<p>実行すると。</p>

<pre><code>$ az get-vm-pip -n yoursmplvm01
Result
-------------
52.185.133.68
</code></pre>

<h3 id="引数を確認するのがめんどくさい系">引数を確認するのがめんどくさい系</h3>

<p>リソースグループを消したくないけど、中身だけ消したいってケース、よくありますよね。そんなエイリアスも作りました。&ndash;template-uriで指定しているGistには、空っぽのAzure Resource Manager デプロイメントテンプレートが置いてあります。このuriをいちいち確認するのがめんどくさいので、エイリアスに。</p>

<pre><code>[empty-rg]
command = group deployment create --mode Complete --template-uri https://gist.githubusercontent.com/ToruMakabe/28ad5177a6de525866027961aa33b1e7/raw/9b455bfc9608c637e1980d9286b7f77e76a5c74b/azuredeploy_empty.json
</code></pre>

<p>以下のコマンドを打つだけで、リソースグループの中身をバッサリ消せます。投げっぱなしでさっさとPC閉じて帰りたいときは &ndash;no-waitオプションを。</p>

<pre><code>$ az empty-rg
</code></pre>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest#create-an-alias-command-with-arguments">位置引数</a>や<a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest#process-arguments-using-jinja2-templates">Jinja2テンプレート</a>を使ったエイリアスも作れるので、込み入ったブツを、という人は挑戦してみてください。</p>

<h2 id="vs-code-プラグイン-azure-cli-tools">VS Code プラグイン (Azure CLI Tools )</h2>

<p>Azure CLIのVS Code向けプラグインがあります。コードアシストと編集画面からの実行が2大機能。紹介ページのGifアニメを見るのが分かりやすいです。</p>

<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli">Azure CLI Tools</a></p>

<p>プラグインを入れて、拡張子.azcliでファイルを作ればプラグインが効きます。長いコマンドを補完支援付きでコーディングしたい、スクリプトを各行実行して確認しながら作りたい、なんて場合におすすめです。</p>

<h2 id="注意点">注意点</h2>

<ul>
<li>エイリアスには補完が効かない

<ul>
<li>bashでのCLI実行、VS Code Azure CLI Toolsともに、現時点(<sup>2018</sup>&frasl;<sub>4</sub>)でエイリアスには補完が効きません</li>
</ul></li>
<li>ソースコード管理に不要なファイルを含めない

<ul>
<li>$AZURE_CONFIG_DIR/ 下には、aliasやconfigの他に、認証トークンやプロファイルといったシークレット情報が置かれます。なのでGitなどでソースコード管理する場合は、aliasとconfig以外は除外したほうがいいでしょう</li>
</ul></li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Apr 2018, 18:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_terraform_customimage_desc/" class="post-title">TerraformでAzure VM/VMSSの最新のカスタムイメージを指定する方法</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="カスタムイメージではlatest指定できない">カスタムイメージではlatest指定できない</h2>

<p>Azure Marketplaceで提供されているVM/VMSSのイメージは、latest指定により最新のイメージを取得できます。いっぽうでカスタムイメージの場合、同様の属性を管理していないので、できません。</p>

<p>ではVM/VMSSを作成するとき、どうやって最新のカスタムイメージ名を指定すればいいでしょうか。</p>

<ol>
<li>最新のイメージ名を確認のうえ、手で指定する</li>
<li>自動化パイプラインで、イメージ作成とVM/VMSS作成ステップでイメージ名を共有する</li>
</ol>

<p>2のケースは、JenkinsでPackerとTerraformを同じジョブで流すケースがわかりやすい。変数BUILD_NUMBERを共有すればいいですね。でもイメージに変更がなく、Terraformだけ流したい時、パイプラインを頭から流してイメージ作成をやり直すのは、無駄なわけです。</p>

<h2 id="terraformではイメージ名取得に正規表現とソートが可能">Terraformではイメージ名取得に正規表現とソートが可能</h2>

<p>Terraformでは見出しの通り、捗る表現ができます。</p>

<p>イメージを取得するとき、name_regexでイメージ名を引っ張り、sort_descendingを指定すればOK。以下の例は、イメージ名をubuntu1604-xxxxというルールで作ると決めた場合の例です。イメージを作るたびに末尾をインクリメントしてください。ソートはイメージ名全体の<a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/azurerm/data_source_image.go#L164">文字列比較</a>なので、末尾の番号の決めた桁は埋めること。</p>

<p>ということで降順で最上位、つまり最新のイメージ名を取得できます。</p>

<pre><code>data &quot;azurerm_image&quot; &quot;poc&quot; {
  name_regex          = &quot;ubuntu1604-[0-9]*&quot;
  sort_descending     = true
  resource_group_name = &quot;${var.managed_image_resource_group_name}&quot;
}
</code></pre>

<p>あとはVM/VMSSリソース定義内で、取得したイメージのidを渡します。</p>

<pre><code>  storage_profile_image_reference {
    id = &quot;${data.azurerm_image.poc.id}&quot;
  }
</code></pre>

<p>便利である。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">30 Mar 2018, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_msi_terraform/" class="post-title">Azure MarketplaceからMSI対応でセキュアなTerraform環境を整える</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="terraformのプロビジョニングがmarketplaceから可能に">TerraformのプロビジョニングがMarketplaceから可能に</h2>

<p>Terraform使ってますか。Azureのリソースプロビジョニングの基本はAzure Resource Manager Template Deployである、がわたしの持論ですが、Terraformを使う/併用する方がいいな、というケースは結構あります。使い分けは<a href="https://www.slideshare.net/ToruMakabe/azure-infrastructure-as-code">この資料</a>も参考に。</p>

<p>さて、先日Azure Marketplaceから<a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps/azure-oss.terraform">Terraform入りの仮想マシン</a>をプロビジョニングできるようになりました。Ubuntuに以下のアプリが導入、構成されます。</p>

<ul>
<li>Terraform (latest)</li>
<li>Azure CLI 2.0</li>
<li>Managed Service Identity (MSI) VM Extension</li>
<li>Unzip</li>
<li>JQ</li>
<li>apt-transport-https</li>
</ul>

<p>いろいろセットアップしてくれるのでしみじみ便利なのですが、ポイントはManaged Service Identity (MSI)です。</p>

<h2 id="シークレットをコードにベタ書きする問題">シークレットをコードにベタ書きする問題</h2>

<p>MSIの何がうれしいいのでしょう。分かりやすい例を挙げると「GitHubにシークレットを書いたコードをpushする、お漏らし事案」を避ける仕組みです。もちそんそれだけではありませんが。</p>

<p><a href="https://docs.microsoft.com/ja-jp/azure/active-directory/managed-service-identity/overview">Azure リソースの管理対象サービス ID (MSI)</a></p>

<p>詳細の説明は公式ドキュメントに譲りますが、ざっくり説明すると</p>

<p><strong>アプリに認証・認可用のシークレットを書かなくても、アプリの動く仮想マシン上にあるローカルエンドポイントにアクセスすると、Azureのサービスを使うためのトークンが得られるよ</strong></p>

<p>です。</p>

<p>GitHub上に疑わしいシークレットがないかスキャンする<a href="https://azure.microsoft.com/ja-jp/blog/managing-azure-secrets-on-github-repositories/">取り組み</a>もはじまっているのですが、できればお世話になりなくない。MSIを活用しましょう。</p>

<h2 id="terraformはmsiに対応している">TerraformはMSIに対応している</h2>

<p>TerraformでAzureのリソースをプロビジョニングするには、もちろん認証・認可が必要です。従来はサービスプリンシパルを作成し、そのIDやシークレットをTerraformの実行環境に配布していました。でも、できれば配布したくないですよね。実行環境を特定の仮想マシンに限定し、MSIを使えば、解決できます。</p>

<p>ところでMSIを使うには、ローカルエンドポイントにトークンを取りに行くよう、アプリを作らなければいけません。</p>

<p><a href="https://www.terraform.io/docs/providers/azurerm/authenticating_via_msi.html">Authenticating to Azure Resource Manager using Managed Service Identity</a></p>

<p>Terraformは対応済みです。環境変数 ARM_USE_MSI をtrueにしてTerraformを実行すればOK。</p>

<h2 id="試してみよう">試してみよう</h2>

<p>実は、すでに使い方を解説した公式ドキュメントがあります。</p>

<p><a href="https://docs.microsoft.com/ja-jp/azure/terraform/terraform-vm-msi">Azure Marketplace イメージを使用して管理対象サービス ID を使用する Terraform Linux 仮想マシンを作成する</a></p>

<p>手順は十分なのですが、理解を深めるための補足情報が、もうちょっと欲しいところです。なので補ってみましょう。</p>

<h3 id="marketplaceからterraform入り仮想マシンを作る">MarketplaceからTerraform入り仮想マシンを作る</h3>

<p>まず、Marketplaceからのデプロイでどんな仮想マシンが作られたのか、気になります。デプロイに利用されたテンプレートをのぞいてみましょう。注目は以下3つのリソースです。抜き出します。</p>

<ul>
<li>MSI VM拡張の導入</li>
<li>VMに対してリソースグループスコープでContributorロールを割り当て</li>
<li>スクリプト実行 VM拡張でTerraform関連のプロビジョニング</li>
</ul>

<pre><code>[snip]
        {
            &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
            &quot;name&quot;: &quot;[concat(parameters('vmName'),'/MSILinuxExtension')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-12-01&quot;,
            &quot;location&quot;: &quot;[parameters('location')]&quot;,
            &quot;properties&quot;: {
                &quot;publisher&quot;: &quot;Microsoft.ManagedIdentity&quot;,
                &quot;type&quot;: &quot;ManagedIdentityExtensionForLinux&quot;,
                &quot;typeHandlerVersion&quot;: &quot;1.0&quot;,
                &quot;autoUpgradeMinorVersion&quot;: true,
                &quot;settings&quot;: {
                    &quot;port&quot;: 50342
                },
                &quot;protectedSettings&quot;: {}
            },
            &quot;dependsOn&quot;: [
                &quot;[concat('Microsoft.Compute/virtualMachines/', parameters('vmName'))]&quot;
            ]
        },
        {
            &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
            &quot;name&quot;: &quot;[variables('resourceGuid')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-09-01&quot;,
            &quot;properties&quot;: {
                &quot;roleDefinitionId&quot;: &quot;[variables('contributor')]&quot;,
                &quot;principalId&quot;: &quot;[reference(concat(resourceId('Microsoft.Compute/virtualMachines/', parameters('vmName')),'/providers/Microsoft.ManagedIdentity/Identities/default'),'2015-08-31-PREVIEW').principalId]&quot;,
                &quot;scope&quot;: &quot;[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', resourceGroup().name)]&quot;
            },
            &quot;dependsOn&quot;: [
                &quot;[resourceId('Microsoft.Compute/virtualMachines/extensions/', parameters('vmName'),'MSILinuxExtension')]&quot;
            ]
        },
        {
            &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
            &quot;name&quot;: &quot;[concat(parameters('vmName'),'/customscriptextension')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-03-30&quot;,
            &quot;location&quot;: &quot;[parameters('location')]&quot;,
            &quot;properties&quot;: {
                &quot;publisher&quot;: &quot;Microsoft.Azure.Extensions&quot;,
                &quot;type&quot;: &quot;CustomScript&quot;,
                &quot;typeHandlerVersion&quot;: &quot;2.0&quot;,
                &quot;autoUpgradeMinorVersion&quot;: true,
                &quot;settings&quot;: {
                    &quot;fileUris&quot;: [
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/infra.sh', parameters('artifactsLocationSasToken'))]&quot;,
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/install.sh', parameters('artifactsLocationSasToken'))]&quot;,
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/azureProviderAndCreds.tf', parameters('artifactsLocationSasToken'))]&quot;
                    ]
                },
                &quot;protectedSettings&quot;: {
                    &quot;commandToExecute&quot;: &quot;[concat('bash infra.sh &amp;&amp; bash install.sh ', variables('installParm1'), variables('installParm2'), variables('installParm3'), variables('installParm4'), ' -k ', listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('stateStorageAccountName')), '2017-10-01').keys[0].value, ' -l ', reference(concat(resourceId('Microsoft.Compute/virtualMachines/', parameters('vmName')),'/providers/Microsoft.ManagedIdentity/Identities/default'),'2015-08-31-PREVIEW').principalId)]&quot;
                }
            },
            &quot;dependsOn&quot;: [
                &quot;[resourceId('Microsoft.Authorization/roleAssignments', variables('resourceGuid'))]&quot;
            ]
        }
[snip]
</code></pre>

<h3 id="vmにログインし-環境を確認">VMにログインし、環境を確認</h3>

<p>では出来上がったVMにsshし、いろいろのぞいてみましょう。</p>

<pre><code>$ ssh your-vm-public-ip
</code></pre>

<p>Terraformのバージョンは、現時点で最新の0.11.5が入っています。</p>

<pre><code>$ terraform -v
Terraform v0.11.5
</code></pre>

<p>環境変数ARM_USE_MSIはtrueに設定されています。</p>

<pre><code>$ echo $ARM_USE_MSI
true
</code></pre>

<p>MSIも有効化されています(SystemAssigned)。</p>

<pre><code>$ az vm identity show -g tf-msi-poc-ejp-rg -n tfmsipocvm01
{
  &quot;additionalProperties&quot;: {},
  &quot;identityIds&quot;: null,
  &quot;principalId&quot;: &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot;,
  &quot;tenantId&quot;: &quot;tttt-tttt-tttt-tttt&quot;,
  &quot;type&quot;: &quot;SystemAssigned&quot;
}
</code></pre>

<p>さて、このVMはMSIが使えるようになったわけですが、操作できるリソースのスコープは、このVMが属するリソースグループに限定されてます。新たなリソースグループを作成したい場合は、ロールを付与し、スコープを広げます。~/にtfEnv.shというスクリプトが用意されています。用意されたスクリプトを実行すると、サブスクリプションスコープのContributorがVMに割り当てられます。必要に応じて変更しましょう。</p>

<pre><code>$ ls
tfEnv.sh  tfTemplate

$ cat tfEnv.sh
az login
az role assignment create  --assignee &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot; --role 'b24988ac-6180-42a0-ab88-20f7382dd24c'  --scope /subscriptions/&quot;cccc-cccc-cccc-cccc&quot;

$ . ~/tfEnv.sh
To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code HOGEHOGE to authenticate.
[snip]
{
  &quot;additionalProperties&quot;: {},
  &quot;canDelegate&quot;: null,
  &quot;id&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc/providers/Microsoft.Authorization/roleAssignments/ffff-ffff-ffff-ffff&quot;,
  &quot;name&quot;: &quot;ffff-ffff-ffff-ffff&quot;,
  &quot;principalId&quot;: &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot;,
  &quot;roleDefinitionId&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c&quot;,
  &quot;scope&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc&quot;,
  &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;
}
</code></pre>

<p>ちなみに、role id &ldquo;b24988ac-6180-42a0-ab88-20f7382dd24c&rdquo;はContributorを指します。</p>

<p>tfTemplateというディレクトリも用意されているようです。2つのファイルがあります。</p>

<pre><code>$ ls tfTemplate/
azureProviderAndCreds.tf  remoteState.tf
</code></pre>

<p>azureProviderAndCreds.tfは、tfファイルのテンプレートです。コメントアウトと説明のとおり、MSIを使う場合には、このテンプレートは必要ありません。subscription_idとtenant_idは、VMのプロビジョニング時に環境変数にセットされています。そしてclient_idとclient_secretは、MSIを通じて取得されます。明示的に変えたい時のみ指定しましょう。</p>

<pre><code>$ cat tfTemplate/azureProviderAndCreds.tf
#
#
# Provider and credential snippet to add to configurations
# Assumes that there's a terraform.tfvars file with the var values
#
# Uncomment the creds variables if using service principal auth
# Leave them commented to use MSI auth
#
#variable subscription_id {}
#variable tenant_id {}
#variable client_id {}
#variable client_secret {}

provider &quot;azurerm&quot; {
#    subscription_id = &quot;${var.subscription_id}&quot;
#    tenant_id = &quot;${var.tenant_id}&quot;
#    client_id = &quot;${var.client_id}&quot;
#    client_secret = &quot;${var.client_secret}&quot;
}
</code></pre>

<p>remoteState.tfは、TerraformのstateをAzureのBlob上に置く場合に使います。Blobの<a href="https://azure.microsoft.com/en-us/blog/soft-delete-for-azure-storage-blobs-now-in-public-preview/">soft delete</a>が使えるようになったこともあり、事件や事故を考慮すると、できればstateはローカルではなくBlobで管理したいところです。</p>

<pre><code>$ cat tfTemplate/remoteState.tf
terraform {
 backend &quot;azurerm&quot; {
  storage_account_name = &quot;storestaterandomid&quot;
  container_name       = &quot;terraform-state&quot;
  key                  = &quot;prod.terraform.tfstate&quot;
  access_key           = &quot;KYkCz88z+7yoyoyoiyoyoyoiyoyoyoiyoiTDZRbrwAWIPWD+rU6g==&quot;
  }
}
</code></pre>

<p>soft delete設定は、別途 <a href="https://docs.microsoft.com/en-us/cli/azure/storage/blob/service-properties/delete-policy?view=azure-cli-latest#az-storage-blob-service-properties-delete-policy-update">az storage blob service-properties delete-policy update</a> コマンドで行ってください。</p>

<h3 id="プロビジョニングしてみる">プロビジョニングしてみる</h3>

<p>ではTerraformを動かしてみましょう。サブディレクトリsampleを作り、そこで作業します。</p>

<pre><code>$ mkdir sample
$ cd sample/
</code></pre>

<p>stateはBlobで管理しましょう。先ほどのremoteState.tfを実行ディレクトリにコピーします。アクセスキーが入っていますので、このディレクトリをコード管理システム配下に置くのであれば、.gitignoreなどで除外をお忘れなく。</p>

<pre><code>$ cp ../tfTemplate/remoteState.tf ./
</code></pre>

<p>ここのキーが残ってしまうのが現時点での課題。ストレージのキー問題は<a href="https://feedback.azure.com/forums/217298-storage/suggestions/14831712-allow-user-based-access-to-blob-containers-for-su">対応がはじまったので</a>、いずれ解決するはずです。</p>

<p>ではTerraformで作るリソースを書きます。さくっとACI上にnginxコンテナーを作りましょう。</p>

<pre><code>$ vim main.tf
resource &quot;azurerm_resource_group&quot; &quot;tf-msi-poc&quot; {
    name     = &quot;tf-msi-poc-aci-wus-rg&quot;
    location = &quot;West US&quot;
}

resource &quot;random_integer&quot; &quot;random_int&quot; {
    min = 100
    max = 999
}

resource &quot;azurerm_container_group&quot; &quot;aci-example&quot; {
    name                = &quot;aci-cg-${random_integer.random_int.result}&quot;
    location            = &quot;${azurerm_resource_group.tf-msi-poc.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.tf-msi-poc.name}&quot;
    ip_address_type     = &quot;public&quot;
    dns_name_label      = &quot;tomakabe-aci-cg-${random_integer.random_int.result}&quot;
    os_type             = &quot;linux&quot;

    container {
        name    = &quot;nginx&quot;
        image   = &quot;nginx&quot;
        cpu     = &quot;0.5&quot;
        memory  = &quot;1.0&quot;
        port    = &quot;80&quot;
    }
}
</code></pre>

<p>init、plan、アプラーイ。アプライ王子。</p>

<pre><code>$ terraform init
$ terraform plan
$ terraform apply -auto-approve
[snip]
Apply complete! Resources: 3 added, 0 changed, 0 destroyed.
</code></pre>

<p>できたか確認。</p>

<pre><code>$ az container show -g tf-msi-poc-aci-wus-rg -n aci-cg-736 -o table
Name        ResourceGroup          ProvisioningState    Image    IP:ports         CPU/Memory       OsType    Location
----------  ---------------------  -------------------  -------  ---------------  ---------------  --------  ----------
aci-cg-736  tf-msi-poc-aci-wus-rg  Succeeded            nginx    13.91.90.117:80  0.5 core/1.0 gb  Linux     westus
$ curl 13.91.90.117
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
[snip]
</code></pre>

<h2 id="おまけ">おまけ</h2>

<p>サービスプリンシパルは、アプリに対して権限を付与するために必要な仕組みなのですが、使わなくなった際に消し忘れることが多いです。意識して消さないと、散らかり放題。</p>

<p>MSIの場合、対象のVMを消すとそのプリンシパルも消えます。爽快感ほとばしる。</p>

<pre><code>$ az ad sp show --id aaaa-aaaa-aaaa-aaaa-aaaa
Resource 'aaaa-aaaa-aaaa-aaaa-aaaa' does not exist or one of its queried reference-property objects are not present.
</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">27 Mar 2018, 00:10</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_private_dns_preview/" class="post-title">Azure DNS Private Zonesの動きを確認する</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="プライベートゾーンのパブリックプレビュー開始">プライベートゾーンのパブリックプレビュー開始</h2>

<p>Azure DNSのプライベートゾーン対応が、全リージョンでパブリックプレビューとなりました。ゾーンとプレビューのプライベートとパブリックが入り混じって、なにやら紛らわしいですが。</p>

<p>さて、このプライベートゾーン対応ですが、名前のとおりAzure DNSをプライベートな仮想ネットワーク(VNet)で使えるようになります。加えて、しみじみと嬉しい便利機能がついています。</p>

<ul>
<li>Split-Horizonに対応します。VNet内からの問い合わせにはプライベートゾーン、それ以外からはパブリックゾーンのレコードを返します。</li>
<li>仮想マシンの作成時、プライベートゾーンへ自動でホスト名を追加します。</li>
<li>プライベートゾーンとVNetをリンクして利用します。複数のVNetをリンクすることが可能です。</li>
<li>リンクの種類として、仮想マシンホスト名の自動登録が行われるVNetをRegistration VNet、名前解決(正引き)のみ可能なResolution VNetがあります。</li>
<li>プライベートゾーンあたり、Registration VNetの現時点の上限数は1、Resolution VNetは10です。</li>
</ul>

<p>公式ドキュメントは<a href="https://docs.microsoft.com/en-us/azure/dns/private-dns-overview">こちら</a>。現時点の<a href="https://docs.microsoft.com/en-us/azure/dns/private-dns-overview#limitations">制約もまとまっている</a>ので、目を通しておきましょう。</p>

<h2 id="動きを見てみよう">動きを見てみよう</h2>

<p>公式ドキュメントには<a href="https://docs.microsoft.com/en-us/azure/dns/private-dns-scenarios">想定シナリオ</a>があり、これを読めばできることがだいたい分かります。ですが、名前解決は呼吸のようなもの、体に叩き込みたいお気持ちです。手を動かして確認します。</p>

<h3 id="事前に準備する環境">事前に準備する環境</h3>

<p>下記リソースを先に作っておきます。手順は割愛。ドメイン名はexample.comとしましたが、適宜読み替えてください。</p>

<ul>
<li>VNet *2

<ul>
<li>vnet01</li>
<li>subnet01

<ul>
<li>subnet01-nsg (allow ssh)</li>
</ul></li>
<li>vnet02</li>
<li>subnet01

<ul>
<li>subnet01-nsg (allow ssh)</li>
</ul></li>
</ul></li>
<li>Azure DNS Public Zone

<ul>
<li>example.com</li>
</ul></li>
</ul>

<h3 id="azure-cliへdns拡張を導入">Azure CLIへDNS拡張を導入</h3>

<p>プレビュー機能をCLIに導入します。いずれ要らなくなるかもしれませんので、要否は<a href="https://docs.microsoft.com/en-us/azure/dns/private-dns-getstarted-cli#to-installuse-azure-dns-private-zones-feature-public-preview">公式ドキュメント</a>で確認してください。</p>

<pre><code>$ az extension add --name dns
</code></pre>

<h3 id="プライベートゾーンの作成">プライベートゾーンの作成</h3>

<p>既存のゾーンを確認します。パブリックゾーンがあります。</p>

<pre><code>$ az network dns zone list -o table
ZoneName      ResourceGroup             RecordSets    MaxRecordSets
------------  ----------------------  ------------  ---------------
example.com   common-global-rg                   2             5000
</code></pre>

<p>プライベートゾーンを作成します。Registration VNetとしてvnet01をリンクします。<a href="https://docs.microsoft.com/en-us/azure/dns/private-dns-overview#limitations">現時点の制約</a>で、リンク時にはVNet上にVMが無い状態にする必要があります。</p>

<pre><code>$ az network dns zone create -g private-dns-poc-ejp-rg -n example.com --zone-type Private --registration-vnets vnet01
</code></pre>

<p>同じ名前のゾーンが2つになりました。</p>

<pre><code>$ az network dns zone list -o table
ZoneName      ResourceGroup             RecordSets    MaxRecordSets
------------  ----------------------  ------------  ---------------
example.com   common-global-rg                   2             5000
example.com   private-dns-poc-ejp-rg             1             5000
</code></pre>

<h3 id="registration-vnetへvmを作成">Registration VNetへVMを作成</h3>

<p>VMを2つ作ります。1つにはインターネット経由でsshするので、パブリックIPを割り当てます。</p>

<pre><code>$ BASE_NAME=&quot;private-dns-poc-ejp&quot;
$ az network public-ip create -n vm01-pip -g ${BASE_NAME}-rg
$ az network nic create -g ${BASE_NAME}-rg -n vm01-nic --public-ip-address vm01-pip --vnet vnet01 --subnet subnet01
$ az vm create -g ${BASE_NAME}-rg -n vm01 --image Canonical:UbuntuServer:16.04.0-LTS:latest --size Standard_B1s --nics vm01-nic
$ az network nic create -g ${BASE_NAME}-rg -n vm02-nic --vnet vnet01 --subnet subnet01
$ az vm create -g ${BASE_NAME}-rg -n vm02 --image Canonical:UbuntuServer:16.04.0-LTS:latest --size Standard_B1s --nics vm02-nic
</code></pre>

<h3 id="パブリックipをパブリックゾーンへ登録">パブリックIPをパブリックゾーンへ登録</h3>

<p>Split-Horizonの動きを確認したいので、パブリックIPをパブリックゾーンへ登録します。</p>

<pre><code>$ az network public-ip show -g private-dns-poc-ejp-rg -n vm01-pip --query ipAddress
&quot;13.78.84.84&quot;
$ az network dns record-set a add-record -g common-global-rg -z example.com -n vm01 -a 13.78.84.84
</code></pre>

<p>パブリックゾーンで名前解決できることを確認します。</p>

<pre><code>$ nslookup vm01.example.com
Server:         103.5.140.1
Address:        103.5.140.1#53

Non-authoritative answer:
Name:   vm01.example.com
Address: 13.78.84.84
</code></pre>

<h3 id="registration-vnetの動きを確認">Registration VNetの動きを確認</h3>

<p>vnet01のvm01へ、パブリックIP経由でsshします。</p>

<pre><code>$ ssh vm01.example.com
</code></pre>

<p>同じRegistration VNet上のvm02を正引きします。ドメイン名無し、ホスト名だけでnslookupすると、VNetの内部ドメイン名がSuffixになります。</p>

<pre><code>vm01:~$ nslookup vm02
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm02.aioh0amlfdze5drhlpb1ktqwxd.lx.internal.cloudapp.net
Address: 10.0.0.5
</code></pre>

<p>ドメイン名をつけてみましょう。Nameはvnet01にリンクしたプライベートゾーンのドメイン名になりました。</p>

<pre><code>vm01:~$ nslookup vm02.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm02.example.com
Address: 10.0.0.5
</code></pre>

<p>逆引きもできます。</p>

<pre><code>vm01:~$ nslookup 10.0.0.5
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
5.0.0.10.in-addr.arpa   name = vm02.example.com.

Authoritative answers can be found from:
</code></pre>

<h3 id="split-horizonの動きを確認">Split-Horizonの動きを確認</h3>

<p>さて、いま作業をしているvm01には、インターネット経由でパブリックゾーンで名前解決してsshしたわけですが、プライベートなVNet内でnslookupするとどうなるでしょう。</p>

<pre><code>vm01:~$ nslookup vm01.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm01.example.com
Address: 10.0.0.4
</code></pre>

<p>プライベートゾーンで解決されました。Split-Horizonが機能していることが分かります。</p>

<p>あ、どうでもいいことですが、Split-Horizonって戦隊モノの必殺技みたいなネーミングですね。叫びながら地面に拳を叩きつけたい感じ。</p>

<h3 id="resolution-vnetの動きを確認">Resolution VNetの動きを確認</h3>

<p>vnet02を作成し、Resolution VNetとしてプライベートゾーンとリンクします。そして、vnet02にvm03を作ります。vm03へのsshまで一気に進めます。</p>

<pre><code>$ BASE_NAME=&quot;private-dns-poc-ejp&quot;
$ az network vnet create -g ${BASE_NAME}-rg -n vnet02 --address-prefix 10.1.0.0/16 --subnet-name subnet01
$ az network vnet subnet update -g ${BASE_NAME}-rg -n subnet01 --vnet-name vnet02 --network-security-group subnet01-nsg
$ az network public-ip create -n vm03-pip -g ${BASE_NAME}-rg
$ az network dns zone update -g private-dns-poc-ejp-rg -n example.com --resolution-vnets vnet02
$ az network nic create -g ${BASE_NAME}-rg -n vm03-nic --public-ip-address vm03-pip --vnet vnet02 --subnet subnet01
$ az vm create -g ${BASE_NAME}-rg -n vm03 --image Canonical:UbuntuServer:16.04.0-LTS:latest --size Standard_B1s --nics vm03-nic
$ az network public-ip show -g private-dns-poc-ejp-rg -n vm03-pip --query ipAddress
&quot;13.78.54.133&quot;
$ ssh 13.78.54.133
</code></pre>

<p>名前解決の確認が目的なので、vnet01/02間はPeeringしません。</p>

<p>では、vnet01上のvm01を正引きします。ドメイン名を指定しないと、解決できません。vnet02上にvm01がある、と指定されたと判断するからです。</p>

<pre><code>vm03:~$ nslookup vm01
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can't find vm01: SERVFAIL
</code></pre>

<p>ではプライベートゾーンのドメイン名をつけてみます。解決できました。</p>

<pre><code>vm03:~$ nslookup vm01.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm01.example.com
Address: 10.0.0.4
</code></pre>

<p>Resolution VNetからは、逆引きできません。</p>

<pre><code>vm03:~$ nslookup 10.0.0.4
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can't find 4.0.0.10.in-addr.arpa: NXDOMAIN
</code></pre>

<p>ところでRegistration VNetからResolution VNetのホスト名をnslookupするとどうなるでしょう。</p>

<pre><code>$ ssh vm01.example.com
vm01:~$ nslookup vm03
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can't find vm03: SERVFAIL

vm01:~$ nslookup vm03.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can't find vm03.example.com: NXDOMAIN
</code></pre>

<p>ドメイン名あり、なしに関わらず、名前解決できません。VNetが別なのでVNetの内部DNSで解決できない、また、Resolution VNetのVMはレコードがプライベートゾーンに自動登録されないことが分かります。</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 13</span>
    
      <a href="/post/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
