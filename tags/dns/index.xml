<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>re-imagine</title>
    <link>http://torumakabe.github.io/tags/dns/index.xml</link>
    <description>Recent content on re-imagine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://torumakabe.github.io/tags/dns/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Azure DNS Private Zonesの動きを確認する</title>
      <link>http://torumakabe.github.io/post/azure_private_dns_preview/</link>
      <pubDate>Tue, 27 Mar 2018 00:10:30 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_private_dns_preview/</guid>
      <description>

&lt;h2 id=&#34;プライベートゾーンのパブリックプレビュー開始&#34;&gt;プライベートゾーンのパブリックプレビュー開始&lt;/h2&gt;

&lt;p&gt;Azure DNSのプライベートゾーン対応が、全リージョンでパブリックプレビューとなりました。ゾーンとプレビューのプライベートとパブリックが入り混じって、なにやら紛らわしいですが。&lt;/p&gt;

&lt;p&gt;さて、このプライベートゾーン対応ですが、名前のとおりAzure DNSをプライベートな仮想ネットワーク(VNet)で使えるようになります。加えて、しみじみと嬉しい便利機能がついています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Split-Horizonに対応します。VNet内からの問い合わせにはプライベートゾーン、それ以外からはパブリックゾーンのレコードを返します。&lt;/li&gt;
&lt;li&gt;仮想マシンの作成時、プライベートゾーンへ自動でホスト名を追加します。&lt;/li&gt;
&lt;li&gt;プライベートゾーンとVNetをリンクして利用します。複数のVNetをリンクすることが可能です。&lt;/li&gt;
&lt;li&gt;リンクの種類として、仮想マシンホスト名の自動登録が行われるVNetをRegistration VNet、名前解決(正引き)のみ可能なResolution VNetがあります。&lt;/li&gt;
&lt;li&gt;プライベートゾーンあたり、Registration VNetの現時点の上限数は1、Resolution VNetは10です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公式ドキュメントは&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/dns/private-dns-overview&#34;&gt;こちら&lt;/a&gt;。現時点の&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/dns/private-dns-overview#limitations&#34;&gt;制約もまとまっている&lt;/a&gt;ので、目を通しておきましょう。&lt;/p&gt;

&lt;h2 id=&#34;動きを見てみよう&#34;&gt;動きを見てみよう&lt;/h2&gt;

&lt;p&gt;公式ドキュメントには&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/dns/private-dns-scenarios&#34;&gt;想定シナリオ&lt;/a&gt;があり、これを読めばできることがだいたい分かります。ですが、名前解決は呼吸のようなもの、体に叩き込みたいお気持ちです。手を動かして確認します。&lt;/p&gt;

&lt;h3 id=&#34;事前に準備する環境&#34;&gt;事前に準備する環境&lt;/h3&gt;

&lt;p&gt;下記リソースを先に作っておきます。手順は割愛。ドメイン名はexample.comとしましたが、適宜読み替えてください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VNet *2

&lt;ul&gt;
&lt;li&gt;vnet01&lt;/li&gt;
&lt;li&gt;subnet01

&lt;ul&gt;
&lt;li&gt;subnet01-nsg (allow ssh)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vnet02&lt;/li&gt;
&lt;li&gt;subnet01

&lt;ul&gt;
&lt;li&gt;subnet01-nsg (allow ssh)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Azure DNS Public Zone

&lt;ul&gt;
&lt;li&gt;example.com&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;azure-cliへdns拡張を導入&#34;&gt;Azure CLIへDNS拡張を導入&lt;/h3&gt;

&lt;p&gt;プレビュー機能をCLIに導入します。いずれ要らなくなるかもしれませんので、要否は&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/dns/private-dns-getstarted-cli#to-installuse-azure-dns-private-zones-feature-public-preview&#34;&gt;公式ドキュメント&lt;/a&gt;で確認してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az extension add --name dns
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;プライベートゾーンの作成&#34;&gt;プライベートゾーンの作成&lt;/h3&gt;

&lt;p&gt;既存のゾーンを確認します。パブリックゾーンがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az network dns zone list -o table
ZoneName      ResourceGroup             RecordSets    MaxRecordSets
------------  ----------------------  ------------  ---------------
example.com   common-global-rg                   2             5000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プライベートゾーンを作成します。Registration VNetとしてvnet01をリンクします。&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/dns/private-dns-overview#limitations&#34;&gt;現時点の制約&lt;/a&gt;で、リンク時にはVNet上にVMが無い状態にする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az network dns zone create -g private-dns-poc-ejp-rg -n example.com --zone-type Private --registration-vnets vnet01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じ名前のゾーンが2つになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az network dns zone list -o table
ZoneName      ResourceGroup             RecordSets    MaxRecordSets
------------  ----------------------  ------------  ---------------
example.com   common-global-rg                   2             5000
example.com   private-dns-poc-ejp-rg             1             5000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;registration-vnetへvmを作成&#34;&gt;Registration VNetへVMを作成&lt;/h3&gt;

&lt;p&gt;VMを2つ作ります。1つにはインターネット経由でsshするので、パブリックIPを割り当てます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ BASE_NAME=&amp;quot;private-dns-poc-ejp&amp;quot;
$ az network public-ip create -n vm01-pip -g ${BASE_NAME}-rg
$ az network nic create -g ${BASE_NAME}-rg -n vm01-nic --public-ip-address vm01-pip --vnet vnet01 --subnet subnet01
$ az vm create -g ${BASE_NAME}-rg -n vm01 --image Canonical:UbuntuServer:16.04.0-LTS:latest --size Standard_B1s --nics vm01-nic
$ az network nic create -g ${BASE_NAME}-rg -n vm02-nic --vnet vnet01 --subnet subnet01
$ az vm create -g ${BASE_NAME}-rg -n vm02 --image Canonical:UbuntuServer:16.04.0-LTS:latest --size Standard_B1s --nics vm02-nic
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;パブリックipをパブリックゾーンへ登録&#34;&gt;パブリックIPをパブリックゾーンへ登録&lt;/h3&gt;

&lt;p&gt;Split-Horizonの動きを確認したいので、パブリックIPをパブリックゾーンへ登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az network public-ip show -g private-dns-poc-ejp-rg -n vm01-pip --query ipAddress
&amp;quot;13.78.84.84&amp;quot;
$ az network dns record-set a add-record -g common-global-rg -z example.com -n vm01 -a 13.78.84.84
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パブリックゾーンで名前解決できることを確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nslookup vm01.example.com
Server:         103.5.140.1
Address:        103.5.140.1#53

Non-authoritative answer:
Name:   vm01.example.com
Address: 13.78.84.84
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;registration-vnetの動きを確認&#34;&gt;Registration VNetの動きを確認&lt;/h3&gt;

&lt;p&gt;vnet01のvm01へ、パブリックIP経由でsshします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh vm01.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じRegistration VNet上のvm02を正引きします。ドメイン名無し、ホスト名だけでnslookupすると、VNetの内部ドメイン名がSuffixになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm01:~$ nslookup vm02
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm02.aioh0amlfdze5drhlpb1ktqwxd.lx.internal.cloudapp.net
Address: 10.0.0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ドメイン名をつけてみましょう。Nameはvnet01にリンクしたプライベートゾーンのドメイン名になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm01:~$ nslookup vm02.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm02.example.com
Address: 10.0.0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逆引きもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm01:~$ nslookup 10.0.0.5
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
5.0.0.10.in-addr.arpa   name = vm02.example.com.

Authoritative answers can be found from:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;split-horizonの動きを確認&#34;&gt;Split-Horizonの動きを確認&lt;/h3&gt;

&lt;p&gt;さて、いま作業をしているvm01には、インターネット経由でパブリックゾーンで名前解決してsshしたわけですが、プライベートなVNet内でnslookupするとどうなるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm01:~$ nslookup vm01.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm01.example.com
Address: 10.0.0.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プライベートゾーンで解決されました。Split-Horizonが機能していることが分かります。&lt;/p&gt;

&lt;p&gt;あ、どうでもいいことですが、Split-Horizonって戦隊モノの必殺技みたいなネーミングですね。叫びながら地面に拳を叩きつけたい感じ。&lt;/p&gt;

&lt;h3 id=&#34;resolution-vnetの動きを確認&#34;&gt;Resolution VNetの動きを確認&lt;/h3&gt;

&lt;p&gt;vnet02を作成し、Resolution VNetとしてプライベートゾーンとリンクします。そして、vnet02にvm03を作ります。vm03へのsshまで一気に進めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ BASE_NAME=&amp;quot;private-dns-poc-ejp&amp;quot;
$ az network vnet create -g ${BASE_NAME}-rg -n vnet02 --address-prefix 10.1.0.0/16 --subnet-name subnet01
$ az network vnet subnet update -g ${BASE_NAME}-rg -n subnet01 --vnet-name vnet02 --network-security-group subnet01-nsg
$ az network public-ip create -n vm03-pip -g ${BASE_NAME}-rg
$ az network dns zone update -g private-dns-poc-ejp-rg -n example.com --resolution-vnets vnet02
$ az network nic create -g ${BASE_NAME}-rg -n vm03-nic --public-ip-address vm03-pip --vnet vnet02 --subnet subnet01
$ az vm create -g ${BASE_NAME}-rg -n vm03 --image Canonical:UbuntuServer:16.04.0-LTS:latest --size Standard_B1s --nics vm03-nic
$ az network public-ip show -g private-dns-poc-ejp-rg -n vm03-pip --query ipAddress
&amp;quot;13.78.54.133&amp;quot;
$ ssh 13.78.54.133
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;名前解決の確認が目的なので、vnet01/02間はPeeringしません。&lt;/p&gt;

&lt;p&gt;では、vnet01上のvm01を正引きします。ドメイン名を指定しないと、解決できません。vnet02上にvm01がある、と指定されたと判断するからです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm03:~$ nslookup vm01
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can&#39;t find vm01: SERVFAIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではプライベートゾーンのドメイン名をつけてみます。解決できました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm03:~$ nslookup vm01.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

Non-authoritative answer:
Name:   vm01.example.com
Address: 10.0.0.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resolution VNetからは、逆引きできません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vm03:~$ nslookup 10.0.0.4
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can&#39;t find 4.0.0.10.in-addr.arpa: NXDOMAIN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ところでRegistration VNetからResolution VNetのホスト名をnslookupするとどうなるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh vm01.example.com
vm01:~$ nslookup vm03
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can&#39;t find vm03: SERVFAIL

vm01:~$ nslookup vm03.example.com
Server:         168.63.129.16
Address:        168.63.129.16#53

** server can&#39;t find vm03.example.com: NXDOMAIN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ドメイン名あり、なしに関わらず、名前解決できません。VNetが別なのでVNetの内部DNSで解決できない、また、Resolution VNetのVMはレコードがプライベートゾーンに自動登録されないことが分かります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AKSのService作成時にホスト名を付ける</title>
      <link>http://torumakabe.github.io/post/aks_dns/</link>
      <pubDate>Mon, 12 Mar 2018 00:21:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/aks_dns/</guid>
      <description>

&lt;h2 id=&#34;2つのやり口&#34;&gt;2つのやり口&lt;/h2&gt;

&lt;p&gt;Azure Container Service(AKS)はServiceを公開する際、パブリックIPを割り当てられます。でもIPだけじゃなく、ホスト名も同時に差し出して欲しいケースがありますよね。&lt;/p&gt;

&lt;p&gt;わたしの知る限り、2つの方法があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AKS(k8s) 1.9で対応した&lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/47849&#34;&gt;DNSラベル名付与機能&lt;/a&gt;を使う&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-incubator/external-dns&#34;&gt;Kubenetes ExternalDNS&lt;/a&gt;を使ってAzure DNSへAレコードを追加する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下、AKS 1.9.2での実現手順です。&lt;/p&gt;

&lt;h2 id=&#34;dnsラベル名付与機能&#34;&gt;DNSラベル名付与機能&lt;/h2&gt;

&lt;p&gt;簡単です。Serviceのannotationsに定義するだけ。試しにnginxをServiceとして公開し、確認してみましょう。&lt;/p&gt;

&lt;p&gt;[nginx-label.yaml]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: nginx
spec:
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - image: nginx
        name: nginx
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: hogeginx
  annotations:
    service.beta.kubernetes.io/azure-dns-label-name: hogeginx
spec:
  selector:
    app: nginx
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デプロイ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f nginx-label.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パブリックIP(EXTERNAL-IP)が割り当てられた後、ラベル名が使えます。ルールは [ラベル名].[リージョン].cloudapp.azure.com です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl hogeginx.eastus.cloudapp.azure.com
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
[snip]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ドメイン名は指定しなくていいから、Service毎にホスト名を固定したいんじゃ、という場合にはこれでOK。&lt;/p&gt;

&lt;h2 id=&#34;kubenetes-externaldns&#34;&gt;Kubenetes ExternalDNS&lt;/h2&gt;

&lt;p&gt;任意のドメイン名を使いたい場合は、Incubatorプロジェクトのひとつ、Kubenetes ExternalDNSを使ってAzure DNSへAレコードを追加する手があります。本家の説明は&lt;a href=&#34;https://github.com/kubernetes-incubator/external-dns/blob/master/docs/tutorials/azure.md&#34;&gt;こちら&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Kubenetes ExternalDNSは、Azure DNSなどAPIを持つDNSサービスを操作するアプリです。k8sのDeploymentとして動かせます。Route 53などにも対応。&lt;/p&gt;

&lt;p&gt;さて動かしてみましょう。前提として、すでにAzure DNSにゾーンがあるものとします。&lt;/p&gt;

&lt;p&gt;ExternalDNSがDNSゾーンを操作できるよう、サービスプリンシパルを作成しましょう。スコープはDNSゾーンが置かれているリソースグループ、ロールはContributorとします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az ad sp create-for-rbac --role=&amp;quot;Contributor&amp;quot; --scopes=&amp;quot;/subscriptions/your-subscription-id/resourceGroups/hoge-dns-rg&amp;quot; -n hogeExtDnsSp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;appId、password、tenantを控えておいてください。次でsecretに使います。&lt;/p&gt;

&lt;p&gt;ではExteralDNSに渡すsecretを作ります。まずJSONファイルに書きます。&lt;/p&gt;

&lt;p&gt;[azure.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;tenantId&amp;quot;: &amp;quot;your-tenant&amp;quot;,
    &amp;quot;subscriptionId&amp;quot;: &amp;quot;your-subscription-id&amp;quot;,
    &amp;quot;aadClientId&amp;quot;: &amp;quot;your-appId&amp;quot;,
    &amp;quot;aadClientSecret&amp;quot;: &amp;quot;your-password&amp;quot;,
    &amp;quot;resourceGroup&amp;quot;: &amp;quot;hoge-dns-rg&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSONファイルを元に、secretを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create secret generic azure-config-file --from-file=azure.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ExteralDNSのマニフェストを作ります。ドメイン名はexmaple.comとしていますが、使うDNSゾーンに合わせてください。以下はRBACを使っていない環境での書き方です。&lt;/p&gt;

&lt;p&gt;[extdns.yaml]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: external-dns
spec:
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: external-dns
    spec:
      containers:
      - name: external-dns
        image: registry.opensource.zalan.do/teapot/external-dns:v0.4.8
        args:
        - --source=service
        - --domain-filter=example.com # (optional) limit to only example.com domains; change to match the zone created above.
        - --provider=azure
        - --azure-resource-group=hoge-dns-rg # (optional) use the DNS zones from the tutorial&#39;s resource group
        volumeMounts:
        - name: azure-config-file
          mountPath: /etc/kubernetes
          readOnly: true
      volumes:
      - name: azure-config-file
        secret:
          secretName: azure-config-file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ExternalDNSをデプロイします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f extdns.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではホスト名を付与するServiceのマニフェストを作りましょう。先ほどのDNSラベル名付与機能と同様、annotationsへ定義します。&lt;/p&gt;

&lt;p&gt;[nginx-extdns.yaml]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: nginx-extdns
spec:
  template:
    metadata:
      labels:
        app: nginx-extdns
    spec:
      containers:
      - image: nginx
        name: nginx
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: hogeginx-extdns
  annotations:
    external-dns.alpha.kubernetes.io/hostname: hogeginx.example.com
spec:
  selector:
    app: nginx-extdns
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デプローイ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f nginx-extdns.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パブリックIP(EXTERNAL-IP)が割り当てられた後、Aレコードが登録されます。確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az network dns record-set a list -g hoge-dns-rg -z example.com -o table
Name      ResourceGroup       Ttl  Type    Metadata
--------  ----------------  -----  ------  ----------
hogeginx  hoge-dns-rg         300  A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ゲッツ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl hogeginx.example.com
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
[snip]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Incubatorプロジェクトなので今後大きく変化する可能性がありますが、ご参考になれば。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>