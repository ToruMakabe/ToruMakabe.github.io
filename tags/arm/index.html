<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arm &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.14" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Arm &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Arm &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">23 Mar 2016, 13:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_terraform_429_workaround/" class="post-title">Azure &amp; Terraform エラーコード429の対処法</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="terraformer増加に備えて:41e5563e03314499a86e746f2fbd113b">Terraformer増加に備えて</h2>

<p>2016/3/21にリリースされたTerraform v0.6.14で、Azure Resource Manager ProviderのリソースにVMとテンプレートデプロイが<a href="https://github.com/hashicorp/terraform/blob/v0.6.14/CHANGELOG.md">追加</a>されました。待っていた人も多いのではないでしょうか。</p>

<p>追って<a href="https://www.hashicorp.com/partners.html#sipart">Hashicorp認定パートナー</a>のクリエーションラインさんから導入・サポートサービスが<a href="http://www.creationline.com/lab/13268">アナウンス</a>されましたし、今後AzureをTerraformでコントロールしようという需要は増えそうです。</p>

<h2 id="エラーコード429:41e5563e03314499a86e746f2fbd113b">エラーコード429</h2>

<p>さて、TerraformでAzureをいじっていると、下記のようなエラーに出くわすことがあります。</p>

<pre><code>Error applying plan:

1 error(s) occurred:
azurerm_virtual_network.vnet1: autorest:DoErrorUnlessStatusCode 429 PUT https://management.azure.com/subscriptions/my_subscription_id/resourceGroups/mygroup/providers/Microsoft.Network/virtualnetworks/vnet1?api-version=2015-06-15 failed with 429
</code></pre>

<p>autorestがステータスコード429をキャッチしました。<a href="https://tools.ietf.org/html/rfc6585#section-4">RFC上で429は</a>&ldquo;Too many requests&rdquo;です。何かが多すぎたようです。</p>

<h2 id="対処法:41e5563e03314499a86e746f2fbd113b">対処法</h2>

<p><strong>もう一度applyしてください</strong></p>

<p>冪等性最高。冪等性なんていらない、という人もいますが、こういうときはありがたい。Terraformが作成に失敗したリソースのみ再作成します。</p>

<h2 id="背景:41e5563e03314499a86e746f2fbd113b">背景</h2>

<p>エラーになった背景ですが、2つの可能性があります。</p>

<ol>
<li>APIリクエスト数上限に達した</li>
<li>リソースの作成や更新に時間がかかっており、Azure側で処理を中断した</li>
</ol>

<h3 id="1-apiリクエスト数上限に達した:41e5563e03314499a86e746f2fbd113b">1. APIリクエスト数上限に達した</h3>

<p>Azure Resource Manager APIには時間当たりのリクエスト数制限があります。読み取り 15,000/時、書き込み1,200/時です。</p>

<p><strong><a href="https://azure.microsoft.com/ja-jp/documentation/articles/azure-subscription-service-limits/">Azure サブスクリプションとサービスの制限、クォータ、制約</a></strong></p>

<p>Terraformは扱うリソースごとにAPIをコールするので、数が多い環境で作って壊してをやると、この上限にひっかかる可能性があります。</p>

<p>長期的な対処として、Terraformにリトライ/Exponential Backoffロジックなどを実装してもらうのがいいのか、このままユーザ側でシンプルにリトライすべきか、悩ましいところです。</p>

<p>ひとまずプロダクトの方針は確認したいので、Issueに質問を<a href="https://github.com/hashicorp/terraform/issues/5704">あげておきました</a>。</p>

<h3 id="2-リソースの作成や更新に時間がかかっており-azure側で処理を中断した:41e5563e03314499a86e746f2fbd113b">2. リソースの作成や更新に時間がかかっており、Azure側で処理を中断した</h3>

<p>Terraform側ではエラーコードで判断するしかありませんが、Azureの監査ログで詳細が確認できます。</p>

<p>わたしが経験したエラーの中に、こんなものがありました。</p>

<pre><code>Cannot proceed with operation since resource /subscriptions/GUID/resourceGroups/xxxx/providers/Microsoft.Network/networkSecurityGroups/yyy allocated to resource /subscriptions/GUID/resourceGroups/***/providers/Microsoft.Network/virtualNetworks/yyy is not in Succeeded state. Resource is in Updating state and the last operation that updated/is updating the resource is PutSecurityRuleOperation. 
</code></pre>

<p>Too many requestsというよりは、リソースのアップデートが終わってないので先に進めない、という内容です。</p>

<p>Too many requestsをどう解釈するかにもよりますが、ちょっと混乱しますね。この問題はFeedbackとして<a href="https://feedback.azure.com/forums/34192--general-feedback/suggestions/13069563-better-http-status-code-instead-of-429">あがっています</a>。</p>

<p>でも安心してください。<strong>もう一度applyしてください</strong>。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">17 Mar 2016, 23:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_packer_ansible_arm_sp/" class="post-title">PackerとAnsibleでAzureのGolden Imageを作る(ARM対応)</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="いつの間に:ebce8e7176cbf58fa7a5804522b325a3">いつの間に</h2>

<p>ナイスな感じにイメージを作ってくれるPackerですが、いつの間にか<a href="https://www.packer.io/docs/builders/azure.html">Azure ARM対応のBuilder</a>が出ておりました。0.10からかな。早く言ってください。</p>

<h2 id="ansible-localと組み合わせたサンプル:ebce8e7176cbf58fa7a5804522b325a3">ansible_localと組み合わせたサンプル</h2>

<p>さっそく試してそつなく動くことを確認しました。サンプルを<a href="https://github.com/ToruMakabe/Packer_Azure_Sample">Githubにあげておきます</a>。</p>

<p>手の込んだ設定もできるように、Provisonerにansible_localを使うサンプルで。</p>

<h3 id="前準備:ebce8e7176cbf58fa7a5804522b325a3">前準備</h3>

<ul>
<li>リソースグループとストレージアカウントを作っておいてください。そこにイメージが格納されます。</li>
<li>認証情報の類は外だしします。builder/variables.sample.jsonを参考にしてください。</li>
<li>Packerの構成ファイルはOSに合わせて書きます。サンプルのbuilder/ubuntu.jsonはubuntuの例です。

<ul>
<li>Azure ARM BuilderはまだWindowsに対応していません。開発中とのこと。</li>
</ul></li>
<li>ansibleはapache2をインストール、サービスEnableするサンプルにしました。</li>
</ul>

<h3 id="サンプル:ebce8e7176cbf58fa7a5804522b325a3">サンプル</h3>

<p>ubuntu.jsonはこんな感じです。</p>

<pre><code>{
  &quot;variables&quot;: {
    &quot;client_id&quot;: &quot;&quot;,
    &quot;client_secret&quot;: &quot;&quot;,
    &quot;resource_group&quot;: &quot;&quot;,
    &quot;storage_account&quot;: &quot;&quot;,
    &quot;subscription_id&quot;: &quot;&quot;,
    &quot;tenant_id&quot;: &quot;&quot;
  },
  &quot;builders&quot;: [{
    &quot;type&quot;: &quot;azure-arm&quot;,

    &quot;client_id&quot;: &quot;{{user `client_id`}}&quot;,
    &quot;client_secret&quot;: &quot;{{user `client_secret`}}&quot;,
    &quot;resource_group_name&quot;: &quot;{{user `resource_group`}}&quot;,
    &quot;storage_account&quot;: &quot;{{user `storage_account`}}&quot;,
    &quot;subscription_id&quot;: &quot;{{user `subscription_id`}}&quot;,
    &quot;tenant_id&quot;: &quot;{{user `tenant_id`}}&quot;,

    &quot;capture_container_name&quot;: &quot;images&quot;,
    &quot;capture_name_prefix&quot;: &quot;packer&quot;,

    &quot;image_publisher&quot;: &quot;Canonical&quot;,
    &quot;image_offer&quot;: &quot;UbuntuServer&quot;,
    &quot;image_sku&quot;: &quot;14.04.3-LTS&quot;,

    &quot;location&quot;: &quot;Japan West&quot;,
    &quot;vm_size&quot;: &quot;Standard_D1&quot;
  }],
  &quot;provisioners&quot;: [{
    &quot;type&quot;: &quot;shell&quot;,
      &quot;scripts&quot;: [
        &quot;../script/ubuntu/provision.sh&quot;
    ]
  },
  {
    &quot;type&quot;: &quot;ansible-local&quot;,
    &quot;playbook_file&quot;: &quot;../ansible/baseimage.yml&quot;,
    &quot;inventory_file&quot;: &quot;../ansible/hosts&quot;,
    &quot;role_paths&quot;: [
      &quot;../ansible/roles/baseimage&quot;
    ]
  },
  {
    &quot;type&quot;: &quot;shell&quot;,
      &quot;scripts&quot;: [
        &quot;../script/ubuntu/deprovision.sh&quot;
    ]
  }]
}
</code></pre>

<p>waagentによるde-provisionはansibleでもできるのですが、他OS対応も考えて、最後に追いshellしてます。他ファイルは<a href="https://github.com/ToruMakabe/Packer_Azure_Sample">Github</a>でご確認を。</p>

<p>これで手順書&amp;目視&amp;指差し確認でイメージ作るのを、やめられそうですね。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">09 Mar 2016, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_tf_fundamental_rules/" class="post-title">Terraform &amp; Azure デプロイ設計4原則</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="情報がありそうでない:d303628c574d6be5ce0911be72b7a9a0">情報がありそうでない</h2>

<p><a href="http://torumakabe.github.io/post/azure_tf_arm_sp/">以前のエントリ</a>で書いたとおり、TerraformでAzureへデプロイする方式をClassicからResource Managerへ移行しているところです。</p>

<p>今後も継続して試行錯誤するとは思うのですが、ふらふらしないように原則を作りました。この手の情報はありそうでないので、参考になればと思いこのエントリを書いています。</p>

<p>なお、考え方は他のクラウドやデプロイツールでも応用できるかと。</p>

<h2 id="4原則:d303628c574d6be5ce0911be72b7a9a0">4原則</h2>

<ol>
<li>セキュリティファースト</li>
<li>手順書をなくそう</li>
<li>分割境界にこだわりすぎない</li>
<li>早すぎる最適化は悪</li>
</ol>

<p>なお、サンプルのTerraformファイル群を、<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample">Githubに置いて</a>おきました。</p>

<p>今後ガラガラポンする可能性は大いにありますが、現時点ではこんな構造です。</p>

<pre><code>.
├── .gitignore
├── main.tf
├── availability_set
│   ├── avset_web.tf
│   ├── avset_db.tf
│   └── variables.tf
├── network
│   ├── sg_backend.tf
│   ├── sg_frontend.tf
│   ├── variables.tf
│   └── vnets.tf
├── storage
│   ├── storage_backend.tf
│   ├── storage_frontend.tf
│   └── variables.tf
└── terraform.tfvars
</code></pre>

<p>Availability Setに対するVMのデプロイはTerraformの外でやっています。まだTerraformのAzure RM Providerにない、ということもありますが、VMの増減はアドホックだったり、別ツールを使いたいケースが多いので。</p>

<h2 id="1-セキュリティファースト:d303628c574d6be5ce0911be72b7a9a0">1. セキュリティファースト</h2>

<p>セキュリティはデザイン時に考慮すべき時代です。機密情報が漏れないように、また、身内がうっかりリソースを壊して泣かないようにしましょう。</p>

<ul>
<li><p>認証情報は変数指定し、設定ファイルから読み込む</p>

<ul>
<li>サブスクリプションIDやOAuth Client ID/Secretなどを、リソースを作るtfファイルに書かない</li>
<li>terraform.tfvarsなどにまとめて書く</li>
</ul></li>

<li><p>認証情報や現物情報が入ったファイルはバージョン管理ツールから除外する</p>

<ul>
<li>Gitなら.gitignoreに指定する</li>
<li>.tfstateなど現物情報(Azure上のIDなど)が入る結果ファイルも除外

<ul>
<li>チームで使う場合はファイルではなく、Consulなどのリモートバックエンドを使うと思いますが、念のため</li>
</ul></li>
</ul></li>

<li><p>RBACで必要最小限の権限を付与する</p>

<ul>
<li>Terraformの外の話ですが、サービスプリンシパルを作る時には意識しましょう</li>
<li>身内がリソースをうっかり壊したら、それは管理者の責任です</li>
</ul></li>

<li><p>ネットワークセキュリティグループはサブネットに指定しておく</p>

<ul>
<li>個々のVMの管理者に任せず、サブネットで絞っておきましょう

<ul>
<li>VMはアドホックに作られるケースが多く、ルーズになりがちです</li>
</ul></li>
<li>サンプルではフロントエンドとバックエンドサブネットそれぞれにセキュリティグループを指定しています

<ul>
<li>フロントの受信はPort 80、443、22を許可 (できれば22はソースIP指定)</li>
<li>バックの受信はフロントサブネットからのみ許可</li>
</ul></li>
</ul></li>
</ul>

<h2 id="2-手順書をなくそう:d303628c574d6be5ce0911be72b7a9a0">2. 手順書をなくそう</h2>

<p>どうせなら手順書を無くす心意気でやりましょう。Infrastructure as Codeのメリットのひとつです。コードで手順を語りましょう。わかりやすさ重視です。</p>

<p>ポリシーや使い方、前提条件をリポジトリのREADMEに書いておけばOK、あとはコードで語る。という世界を目指したいものです。</p>

<h2 id="3-分割境界にこだわりすぎない:d303628c574d6be5ce0911be72b7a9a0">3. 分割境界にこだわりすぎない</h2>

<p>TerraformのModuleをはじめ、最近のデプロイツールはリソースや処理単位をグルーピングできます。ここがアーキテクトの腕の見せ所です。安易に「ベストプラクティス教えろや」という人は残念ながら残念です。大事なことなので2回言いました。</p>

<p>グルーピング、分割する目的は、</p>

<ul>
<li>main.tfの肥大化を防止し、コードの見通しを良くする</li>
<li>再利用しやすくする</li>
<li>責任範囲を明確化し、オーナー意識を醸成する</li>
<li>権限とコードを一致させる</li>
</ul>

<p>などが挙げられます。規模が小さく関わる人が少ないうちは無理して分割する必要はないですが、大きくなってくるとメリットがあります。</p>

<p>以下が分割単位、境界ポリシーの例です。</p>

<ul>
<li><p>リソースタイプで分割する</p>

<ul>
<li>サンプルはその例

<ul>
<li>ネットワーク、ストレージ、VM Availability Setで分割</li>
</ul></li>
<li>直観的</li>
<li>デプロイに関わる人数が少ない間はこれがおすすめ</li>
</ul></li>

<li><p>組織単位で分割する</p>

<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%AB%E3%83%B4%E3%82%A3%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%82%A6%E3%82%A7%E3%82%A4">コンウェイの法則</a></li>
<li>リソースタイプ = 組織 という場合もある

<ul>
<li>ネットワーク管理者が別グループ、など</li>
</ul></li>
</ul></li>

<li><p>地理的に分割する</p>

<ul>
<li>リージョンやロケーションで分割</li>
<li>リソースタイプと組み合わせる手もある

<ul>
<li>&ldquo;Network_JapanEast&rdquo;など</li>
</ul></li>
</ul></li>

<li><p>静的なリソースと動的なリソースを分ける</p>

<ul>
<li>変化の頻度で分ける

<ul>
<li>ネットワークが頻繁に変わることはまれ</li>
<li>VMは増減が激しい</li>
</ul></li>
<li>動的なリソースは対象から外す、別手段とする手も</li>
</ul></li>
</ul>

<p>スカッとしませんが、ひとつのポリシーにこだわらず、複数組み合わせてもいいと思います。そんな世界に僕らは生きています。</p>

<h2 id="4-早すぎる最適化は悪:d303628c574d6be5ce0911be72b7a9a0">4. 早すぎる最適化は悪</h2>

<p>最適化できる人 = その道のエキスパート です。使いはじめたばかりの段階では、最適化とか無理。また、システムの外部環境や制約がはじめから決まっていることは、まれです。</p>

<p>なので、はじめから「最強の構成」を目指さないほうがいいでしょう。特に分割方針。きっとすぐに変えたくなります。</p>

<p>ひとつのmain.tfで動かしながら、まずTerraformやAzureの仕様や挙動を理解しましょう。そして、慣れてきて、システムの外部環境や制約が見えてきた時点で分割方針を決めてもいいのではないか、と思います。</p>

<p>そして、</p>

<ul>
<li>リファクタリングできるなら、する</li>
<li>リファクタリングできなくても、理解の上で維持し機会を待つ、または、次の機会に活かす</li>
<li>はじめに作った人へマサカリを投げない</li>
</ul>

<p>完璧を求めずにいきましょう。</p>

<p>でも、しつこいですが、セキュリティだけは、はじめから意識してくださいね。Security by design。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">27 Feb 2016, 12:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_tf_arm_sp/" class="post-title">TerraformをAzure ARMで使う時の認証</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="高まってまいりました:dfc3556fff242cb82e1ca9532877c49b">高まってまいりました</h2>

<p>全国10,000人のTerraformファンのみなさま、こんにちは。applyしてますか。</p>

<p>Terraformのマイナーバージョンアップのたびに、<a href="https://www.terraform.io/docs/providers/azurerm/index.html">Azure Resource Manager Providerのリソース</a>が追加されているので、ぼちぼちClassic(Service Management)からの移行を考えよう、という人もいるのでは。VMリソースが追加されたら、いよいよ、ですかね。</p>

<p>そこで、Classicとは認証方式が変わっているので、ご注意を、という話です。</p>

<h2 id="client-id-client-secret-って何よ:dfc3556fff242cb82e1ca9532877c49b">client_id/client_secret って何よ</h2>

<p>以下がARM向けのProvider設定です。</p>

<pre><code># Configure the Azure Resource Manager Provider
provider &quot;azurerm&quot; {
  subscription_id = &quot;...&quot;
  client_id       = &quot;...&quot;
  client_secret   = &quot;...&quot;
  tenant_id       = &quot;...&quot;
}
</code></pre>

<p>subscription_idは、いつものあれ。tenant_idは普段使わないけどどこかで見た気がする。でも、<strong>client_id/client_secret って何よ</strong>。ためしにポータルログインで使うID/パスワード指定したら、盛大にコケた。</p>

<pre><code>&quot;The provider needs to be configured with the credentials needed to generate OAuth tokens for the ARM API.&quot;
</code></pre>

<p>おっとそういうことか。OAuth。</p>

<h2 id="サービスプリンシパルを使おう:dfc3556fff242cb82e1ca9532877c49b">サービスプリンシパルを使おう</h2>

<p>Terraformをアプリケーションとして登録し、そのサービスプリンシパルを作成し権限を付与すると、使えるようになります。</p>

<p><a href="https://azure.microsoft.com/ja-jp/documentation/articles/active-directory-application-objects/">&ldquo;アプリケーション オブジェクトおよびサービス プリンシパル オブジェクト&rdquo;</a></p>

<p><a href="https://azure.microsoft.com/ja-jp/documentation/articles/resource-group-authenticate-service-principal/">&ldquo;Azure リソース マネージャーでのサービス プリンシパルの認証&rdquo;</a></p>

<p>以下、Azure CLIでの実行結果をのせておきます。WindowsでもMacでもLinuxでも手順は同じです。</p>

<p>まずは、Terraformをアプリとして登録します。&ndash;identifier-urisの存在チェックはないですが、ユニークにしなければいけません。また、&ndash;passwordはclient_secretになるので、おぼえておきましょう。</p>

<pre><code>$ azure ad app create --name &quot;My Terraform&quot; --home-page &quot;http://tftest.makabe.info&quot; --identifier-uris &quot;http://tftest.makabe.info&quot; --password pAssw0rd%
info:    Executing command ad app create
+ Creating application My Terraform
data:    AppId:                   AppId-AppId-AppId-AppId-AppId
data:    ObjectId:                AppObjId-AppObjId-AppObjId-AppObjId
data:    DisplayName:             My Terraform
data:    IdentifierUris:          0=http://tftest.makabe.info
data:    ReplyUrls:
data:    AvailableToOtherTenants:  False
data:    AppPermissions:
data:                             claimValue:  user_impersonation
data:                             description:  Allow the application to access My Terraform on behalf of the signed-in user.
data:                             directAccessGrantTypes:
data:                             displayName:  Access My Terraform
data:                             impersonationAccessGrantTypes:  impersonated=User, impersonator=Application
data:                             isDisabled:
data:                             origin:  Application
data:                             permissionId:  AppPermID-AppPermID-AppPermID-AppPermID
data:                             resourceScopeType:  Personal
data:                             userConsentDescription:  Allow the application to access My Terraform on your behalf.
data:                             userConsentDisplayName:  Access My Terraform
data:                             lang:
info:    ad app create command OK
</code></pre>

<p>次にサービスプリンシパルを作ります。AppIdは先ほどアプリを登録した際に生成されたものです。</p>

<pre><code>$ azure ad sp create AppId-AppId-AppId-AppId-AppId
info:    Executing command ad sp create
+ Creating service principal for application AppId-AppId-AppId-AppId-AppId
data:    Object Id:               SpObjId-SpObjId-SpObjId-SpObjId
data:    Display Name:            My Terraform
data:    Service Principal Names:
data:                             AppId-AppId-AppId-AppId-AppId
data:                             http://tftest.makabe.info
info:    ad sp create command OK
</code></pre>

<p>サービスプリンシパルの役割を設定します。&ndash;objectIdは、サービスプリンシパルのObject Idなのでご注意を。アプリのObject Idではありません。</p>

<p>この例では、サブスクリプションのContributorとして位置づけました。権限設定は慎重に。</p>

<pre><code>$ azure role assignment create --objectId SpObjId-SpObjId-SpObjId-SpObjId-SpObjId -o Contributor -c /subscriptions/SubId-SubId-SubId-SubId-SubId/
info:    Executing command role assignment create
+ Finding role with specified name
/data:    RoleAssignmentId     : /subscriptions/SubId-SubId-SubId-SubId-SubId/providers/Microsoft.Authorization/roleAssignments/RoleAsId-RoleAsId-RoleAsId-RoleAsId
data:    RoleDefinitionName   : Contributor
data:    RoleDefinitionId     : RoleDefId-RoleDefId-RoleDefId-RoleDefId-RoleDefId
data:    Scope                : /subscriptions/SubId-SubId-SubId-SubId-SubId
data:    Display Name         : My Terraform
data:    SignInName           :
data:    ObjectId             : SpObjId-SpObjId-SpObjId-SpObjId-SpObjId
data:    ObjectType           : ServicePrincipal
data:
+
info:    role assignment create command OK
</code></pre>

<p>サービスプリンシパルまわりの設定は以上です。</p>

<p>テナントIDを確認しておきましょう。</p>

<pre><code>$ azure account list --json
[
  {
    &quot;id&quot;: &quot;SubId-SubId-SubId-SubId-SubId&quot;,
    &quot;name&quot;: &quot;Your Subscription Name&quot;,
    &quot;user&quot;: {
      &quot;name&quot;: &quot;abc@microsoft.com&quot;,
      &quot;type&quot;: &quot;user&quot;
    },
    &quot;tenantId&quot;: &quot;TenantId-TenantId-TenantId-TenantId-TenantId&quot;,
    &quot;state&quot;: &quot;Enabled&quot;,
    &quot;isDefault&quot;: true,
    &quot;registeredProviders&quot;: [],
    &quot;environmentName&quot;: &quot;AzureCloud&quot;
  }
]
</code></pre>

<p>これでようやく.tfファイルが書けます。さくっとリソースグループでも作ってみましょう。</p>

<pre><code># Configure the Azure Resource Manager Provider
provider &quot;azurerm&quot; {
  subscription_id = &quot;SubId-SubId-SubId-SubId-SubId&quot;
  client_id       = &quot;AppId-AppId-AppId-AppId-AppId&quot;
  client_secret   = &quot;pAssw0rd%&quot;
  tenant_id       = &quot;TenantId-TenantId-TenantId-TenantId-TenantId&quot;
}

# Create a resource group
resource &quot;azurerm_resource_group&quot; &quot;test&quot; {
    name     = &quot;test&quot;
    location = &quot;Japan West&quot;
}
</code></pre>

<p>apply。もちろんplanしましたよ。</p>

<pre><code>$ terraform apply
azurerm_resource_group.test: Creating...
  location: &quot;&quot; =&gt; &quot;japanwest&quot;
  name:     &quot;&quot; =&gt; &quot;test&quot;
azurerm_resource_group.test: Creation complete

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.  
</code></pre>

<p>これで、ARM認証難民がうまれなくなりますように。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">11 Jan 2016, 00:20</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_infradeployment_selection/" class="post-title">Azureでインフラデプロイツールを選ぶ時に考えていること</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="ケースバイケースだけど:d8f24c1ecd76ea2b63a3969342359091">ケースバイケースだけど</h2>

<p>Azureを生業にして、3か月たちます。ここまで、もっとも質問や議論が多いのが、デプロイメントの自動化についてです。進化が早いですし、選択肢も豊富。クラウド採用に合わせて自動化に挑戦するケースも増えてますので、自然なことと思います。</p>

<p>特に話題になるのが「どのツールを選べばいいか」。ツールというのは課題を解決する手段なので、まず課題を掘るべきです。ですが、まだ成熟していない領域で変化が激しいですし、ツールひとつで課題を解決できるとも限らない。複数のツールを組み合わせることも多く、依存関係もありそう。となると、考えるきっかけが欲しいのは、ごもっとも。</p>

<p>なので「ケースバイケース。以上」とは、言いにくい。</p>

<p>私見であっても、たたき台となる考え方なりパターンがWebに転がっていれば、参考になるかもしれない。それがこのエントリを書く動機です。わたしは他のプラットフォームからAzureに主戦場を移していますので、新鮮な意見が書けるかも、という背景も、あります。</p>

<h2 id="書く前に前提など:d8f24c1ecd76ea2b63a3969342359091">書く前に前提など</h2>

<p>対象はインフラレイヤのデプロイメントに絞ります。そして、インフラ = 物理/仮想ハードウェア(サーバ、ストレージ、ネットワーク) + OS + プラットフォームソフト(アプリじゃないもの、Webサーバ、ユーティリティ、etc）と定義します。</p>

<p>レイヤリングや用語は、 @gosukenator さんの<a href="http://mizzy.org/blog/2013/10/29/1/">&ldquo;インフラ系技術の流れ&rdquo;</a>が参考になるので、合わせて読むと幸せになれるでしょう。このエントリで言うBootstrapping/Configurationレイヤが今回の焦点です。</p>

<p>では、わたしがツールを選ぶ時にどんなことを考えているのか、脳内をダンプしていきましょう。</p>

<h2 id="そもそもツールで自動化すべきかを考える:d8f24c1ecd76ea2b63a3969342359091">そもそもツールで自動化すべきかを考える</h2>

<p>いきなり萎えるそもそも論で恐縮ですが、重要です。たとえばあるソフトの試用目的で、同じ構成のサーバのデプロイは今後しなさそう、台数は1台、使うのは自分だけ、なんていう環境のデプロイまで、自動化する必要はないはずです。時短、工数削減、オペレーションミスリスクの軽減、そもそも自動化しないと運用がまわらない、など自動化によって得られる利益がその手間を上回るかを判断します。</p>

<p>なお「知っている/できる」人でないとその価値、利益はわかりません。やらないという判断は、腕があってはじめてできることです。</p>

<h2 id="使い捨てられないかを考える:d8f24c1ecd76ea2b63a3969342359091">使い捨てられないかを考える</h2>

<p>次は、ツールによって作った環境がどのように変化するか、変えられるかを検討します。ストレートに言うと、変化のタイミングで捨てられないか？新しいものに置き換えられないか？を考えます。もしこれができるのであれば、方式はとてもシンプルにできます。Immutable Infrastructure、Blue/Green Deploymentなどのやり口が注目されていますが、これらの根っこには「ちまちま変化を加えて複雑化するくらいなら、使い捨て/入れ替えてしまえ」という意識があります。</p>

<p>ですが、とは言ってもそんな大胆にできない事情もあると思います。Blue/Green Deploymentでは、入れ替えのタイミングでBlue、Green分のリソースが必要になりますし、切り替えにともなうリスクもあります。それを許容できない場合、同じインフラに変化を積んでいくことになります。ChefなどConfigurationレイヤで冪等なオペーレーションができるツールが注目されたのは、この変化を維持しやすいからです。</p>

<p>変化を積む場合にやるべきでないのは、中途半端に職人が真心こめて手作業してしまうことです。ツールでやると決めたら、少なくともそのカバー範囲はツールに任せましょう。でないといわゆる「手作業汚れ」「スノーフレークサーバ（雪の結晶のように、全部同じように見えて実はそれぞれ違う）」のダークサイドに堕ちます。</p>

<p>変化を積まないのであれば、インフラデプロイメント用途ではConfigurationレイヤのツールを導入しないという割り切りもできるでしょう。</p>

<h2 id="優先事項や制約条件を洗い出す:d8f24c1ecd76ea2b63a3969342359091">優先事項や制約条件を洗い出す</h2>

<p>アーキテクトが真っ白なキャンバスに画を描けることはほぼありません。きっと、先になんらかの優先事項や制約条件があるはずです。そして、ほとんどのシステムにおいて、インフラのデプロイは主役ではありません。ツールに合わせてもらえることはまれでしょう。様々な条件を選定にあたって洗い出す必要があります。</p>

<ul>
<li><em>社内/プロジェクト標準</em></li>
</ul>

<p>　周知されていないだけで、推奨ツールが決まってたりします。あるある。そのツールの良し悪しは置いておいて、社内ノウハウの蓄積など、大きな目的がある場合には従うべきでしょう。</p>

<ul>
<li><em>他レイヤでの優先ツール</em></li>
</ul>

<p>　インフラのデプロイに影響がありそうなツールがアプリ開発側で決まっていたりします。最近華やかなのがDockerです。Docker社が出してるツール群は上から下までカバー範囲も広く、デプロイツールと重複しがちです。組み合わせを検討しなければいけません。また、Apache Mesosもインフラとアプリのグレーゾーンに鎮座します。なかなか悩ましいですが、優先せざるをえません。</p>

<ul>
<li><em>規模</em></li>
</ul>

<p>　いきなり1000台とか10000台規模を扱うユーザは多くないと思いますが、その規模になるとツールの性能限界にぶち当たったりします。念のため、意識はしましょう。ちなみに、1000台をひとつのツールの傘に入れずとも、たとえば10*100台にする設計ができないか、事前に考えておくと打ち手が増えます。</p>

<ul>
<li><em>チーム or ひとり</em></li>
</ul>

<p>　本番環境のデプロイ自動化はチームプレイになるので、ツールの導入はサーバ上になるでしょうし、構成ファイルの共有、バージョンコントロールなど考慮点は多いです。一方で、開発者が開発、検証用途で端末に導入し実行する使い方では、手軽さが求められます。誤解を恐れず例をあげると、前者にはChefが、後者にはAnsibleやTerraformがフィットしやすいです。</p>

<ul>
<li><em>Windows or Linux</em></li>
</ul>

<p>　Azure ARM Templateなど、はじめからマルチOS環境を前提に作られているツールはありますが、ほとんどのツールはその生まれがWindows、Linuxに寄っています。マルチOS対応が進んではいますが、活用にあたって、参考となる情報量には大きな差があります。たとえばマルチOS対応のツールであっても、DSCはWindowsの、ChefやAnsibleはLinuxの情報が圧倒的に多いです。これは意識せざるを得ません。使うOSでの十分な情報があるか確認します。</p>

<h2 id="マネージドサービス-機能を活用する:d8f24c1ecd76ea2b63a3969342359091">マネージドサービス、機能を活用する</h2>

<p>マネージドサービス = プラットフォームが提供している機能です。Azureであれば、今回対象としているレイヤではARMがそれにあたります。デプロイツールは有用ですが、その導入や維持運用には本質的価値はありません。プラットフォームに任せられるのであれば、そうしたほうが楽です。</p>

<p>また、Azureのインフラは進化が早いため、それに対応するスピードも、本家ツールのほうが期待できます。</p>

<p>ですが、<a href="http://torumakabe.github.io/post/arm_idempotent/">以前のエントリ</a>で触れたように、本家のツールであっても、すべてのレイヤをカバーできるほど万能ではありません。たとえばARM TemplateはインフラのBootstrappingには向いていますが冪等性が限定的であるため、ソフトウェアパッケージを足す/消す/入れ替えるを頻繁に繰り返す環境のConfiguration用途では、苦しいです。</p>

<p>よってARM Templateは、Immutableな環境で使う、もしくは、ChefなどのConfigurationツールと組み合わせて使うことを念頭に設計をします。</p>

<p>ARM Templateでは、ハード(VM、ストレージ、ネットワーク)の割り当て、OSの導入と設定、各種エージェントの導入が基本。それに加え、Immutableな環境ではプラットフォームソフトを導入してしまっていいでしょう。ARM TemplateにはDSCやシェルを実行するエクステンションが使えるので、活用します。</p>

<p>また、Bootstrapping時点で、Configurationツールを導入できてしまうのであれば、せっかくなので入れてしまいましょう。たとえばChefサーバのインストールは、ここで。</p>

<p>以上、ちょっとまとまりに欠けますが、ざっとわたしが意識していることを、挙げてみました。</p>

<h2 id="汎用的-リファレンスアーキテクチャ:d8f24c1ecd76ea2b63a3969342359091">汎用的 リファレンスアーキテクチャ</h2>

<p>具体例があったほうが分かりやすいので、最後に汎用的な組み合わせを紹介します。</p>

<p><a href="https://gallery.technet.microsoft.com/Automating-Deployment-with-84c1549f">&ldquo;Automating Deployment with Azure &amp; Chef&rdquo;</a></p>

<ul>
<li><p>ARM TemplateでBootstrapping</p>

<ul>
<li>VMを4つ作成、1つはLinux、他はWindows</li>
<li>ストレージ、ネットワークの作成</li>
<li>VMのストレージ、ネットワーク設定</li>
<li>OSの導入</li>
<li>ドメインコントローラサーバへのソフト導入、各種設定 (DSC/PowerShell Extension)</li>
<li>他Windowsサーバへのソフト導入、各種設定、ドメイン参加 (PowerShell Extension)</li>
<li>LinuxへChefサーバを導入、各種設定 (Shell Extension)</li>
</ul></li>

<li><p>ChefでConfiguration</p>

<ul>
<li>各ノードのChef bootstrap(言葉が混同しやすいので注意)</li>
<li>Chef Clientサービスの起動設定</li>
<li>DBサーバのDB領域ディスク作成、フォーマット</li>
<li>DBサーバへSQL Server 2014のインストール</li>
<li>ChefがDBサーバが設定通りになるよう維持し続ける</li>
</ul></li>
</ul>

<p>どうでしょう、役割分担がイメージできたでしょうか。いいドキュメントがあったので、ChefのLinux/Windows混在例を紹介しましたが、Windowsとの親和性や情報量を重視するなら、ChefをAzure Automation DSCに置き換えて挑戦してもいいでしょう。そのまた逆もありで、ChefならLinux染めな環境で、とこだわってもいいと思います。</p>

<p>書くことが意外に多かったので、また機会があれば、参考例を交えて紹介します。</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 2</span>
    
      <a href="/tags/arm/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
