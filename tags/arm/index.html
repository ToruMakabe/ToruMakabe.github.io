<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arm &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.14" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Arm &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Arm &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">09 Mar 2016, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_tf_fundamental_rules/" class="post-title">Terraform &amp; Azure デプロイ設計4原則</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="情報がありそうでない:d303628c574d6be5ce0911be72b7a9a0">情報がありそうでない</h2>

<p><a href="http://torumakabe.github.io/post/azure_tf_arm_sp/">以前のエントリ</a>で書いたとおり、TerraformでAzureへデプロイする方式をClassicからResource Managerへ移行しているところです。</p>

<p>今後も継続して試行錯誤するとは思うのですが、ふらふらしないように原則を作りました。この手の情報はありそうでないので、参考になればと思いこのエントリを書いています。</p>

<p>なお、考え方は他のクラウドやデプロイツールでも応用できるかと。</p>

<h2 id="4原則:d303628c574d6be5ce0911be72b7a9a0">4原則</h2>

<ol>
<li>セキュリティファースト</li>
<li>手順書をなくそう</li>
<li>分割境界にこだわりすぎない</li>
<li>早すぎる最適化は悪</li>
</ol>

<p>なお、サンプルのTerraformファイル群を、<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample">Githubに置いて</a>おきました。</p>

<p>今後ガラガラポンする可能性は大いにありますが、現時点ではこんな構造です。</p>

<pre><code>.
├── .gitignore
├── main.tf
├── availability_set
│   ├── avset_backend.tf
│   ├── avset_frontend.tf
│   └── variables.tf
├── network
│   ├── sg_backend.tf
│   ├── sg_frontend.tf
│   ├── variables.tf
│   └── vnets.tf
├── storage
│   ├── storage_backend.tf
│   ├── storage_frontend.tf
│   └── variables.tf
└── terraform.tfvars
</code></pre>

<p>Availability Setに対するVMのデプロイはTerraformの外でやっています。まだTerraformのAzure RM Providerにない、ということもありますが、VMの増減はアドホックだったり、別ツールを使いたいケースが多いので。</p>

<h2 id="1-セキュリティファースト:d303628c574d6be5ce0911be72b7a9a0">1. セキュリティファースト</h2>

<p>セキュリティはデザイン時に考慮すべき時代です。機密情報が漏れないように、また、身内がうっかりリソースを壊して泣かないようにしましょう。</p>

<ul>
<li><p>認証情報は変数指定し、設定ファイルから読み込む</p>

<ul>
<li>サブスクリプションIDやOAuth Client ID/Secretなどを、リソースを作るtfファイルに書かない</li>
<li>terraform.tfvarsなどにまとめて書く</li>
</ul></li>

<li><p>認証情報や現物情報が入ったファイルはバージョン管理ツールから除外する</p>

<ul>
<li>Gitなら.gitignoreに指定する</li>
<li>.tfstateなど現物情報(Azure上のIDなど)が入る結果ファイルも除外

<ul>
<li>チームで使う場合はファイルに書かず、Consulなどのリモートバックエンドを使うと思いますが、念のため</li>
</ul></li>
</ul></li>

<li><p>RBACで必要最小限の権限を付与する</p>

<ul>
<li>Terraformの外の話ですが、サービスプリンシパルを作る時には意識しましょう</li>
<li>身内がリソースをうっかり壊したら、それは管理者の責任です</li>
</ul></li>

<li><p>ネットワークセキュリティグループはサブネットに指定しておく</p>

<ul>
<li>個々のVMの管理者に任せず、サブネットで絞っておきましょう

<ul>
<li>VMはアドホックに作られるケースが多く、ルーズになりがちです</li>
</ul></li>
<li>サンプルではフロントエンドとバックエンドサブネットそれぞれにセキュリティグループを指定しています

<ul>
<li>フロントの受信はPort 80、443、22を許可 (できれば22はソースIP指定)</li>
<li>バックの受信はフロントサブネットからのみ許可</li>
</ul></li>
</ul></li>
</ul>

<h2 id="2-手順書をなくそう:d303628c574d6be5ce0911be72b7a9a0">2. 手順書をなくそう</h2>

<p>どうせなら手順書を無くす心意気でやりましょう。Infrastructure as Codeのメリットのひとつです。コードで手順を語りましょう。わかりやすさ重視です。</p>

<p>ポリシーや使い方、前提条件をリポジトリのREADMEに書いておけばOK、あとはコードで語る。という世界を目指したいものです。</p>

<h2 id="3-分割境界にこだわりすぎない:d303628c574d6be5ce0911be72b7a9a0">3. 分割境界にこだわりすぎない</h2>

<p>TerraformのModuleをはじめ、最近のデプロイツールはリソースや処理単位をグルーピングできます。ここがアーキテクトの腕の見せ所です。安易に「ベストプラクティス教えろや」という人は残念ながら残念です。大事なことなので2回言いました。</p>

<p>グルーピング、分割する目的は、</p>

<ul>
<li>main.tfの肥大化を防止し、コードの見通しを良くする</li>
<li>再利用しやすくする</li>
<li>責任範囲を明確化し、オーナー意識を醸成する</li>
<li>権限とコードを一致させる</li>
</ul>

<p>などが挙げられます。規模が小さく関わる人が少ないうちは無理して分割する必要はないですが、大きくなってくるとメリットがあります。</p>

<p>以下が分割単位、境界ポリシーの例です。</p>

<ul>
<li><p>リソースタイプで分割する</p>

<ul>
<li>サンプルはその例

<ul>
<li>ネットワーク、ストレージ、VM Availability Setで分割</li>
</ul></li>
<li>直観的</li>
<li>デプロイに関わる人数が少ない間はこれがおすすめ</li>
</ul></li>

<li><p>組織単位で分割する</p>

<ul>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%AB%E3%83%B4%E3%82%A3%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%82%A6%E3%82%A7%E3%82%A4">コンウェイの法則</a></li>
<li>リソースタイプ = 組織 という場合もある

<ul>
<li>ネットワーク管理者が別グループ、など</li>
</ul></li>
</ul></li>

<li><p>地理的に分割する</p>

<ul>
<li>リージョンやロケーションで分割</li>
<li>リソースタイプと組み合わせる手もある

<ul>
<li>&ldquo;Network_JapanEast&rdquo;など</li>
</ul></li>
</ul></li>

<li><p>静的なリソースと動的なリソースを分ける</p>

<ul>
<li>変化の頻度で分ける

<ul>
<li>ネットワークが頻繁に変わることはまれ</li>
<li>VMは増減が激しい</li>
</ul></li>
<li>動的なリソースは対象から外す、別手段とする手も</li>
</ul></li>
</ul>

<p>スカッとしませんが、ひとつのポリシーにこだわらず、複数組み合わせてもいいと思います。そんな世界に僕らは生きています。</p>

<h2 id="4-早すぎる最適化は悪:d303628c574d6be5ce0911be72b7a9a0">4. 早すぎる最適化は悪</h2>

<p>最適化できる人 = その道のエキスパート です。使い始めたばかりの段階では、最適化とか無理。また、システムの外部環境や制約がはじめから決まっていることは、まれです。</p>

<p>なので、はじめから「最強の構成」を目指さないほうがいいでしょう。特に分割方針。きっとすぐに変えたくなります。</p>

<p>ひとつのmain.tfで動かしながら、まずTerraformやAzureの仕様や挙動を理解しましょう。そして、慣れてきて、システムの外部環境や制約が見えてきた時点で分割方針を決めてもいいのではないか、と思います。</p>

<p>そして、</p>

<ul>
<li>リファクタリングできるなら、する</li>
<li>リファクタリングできなくても、理解の上で維持し機会を待つ、または、次の機会に活かす</li>
<li>はじめに作った人へマサカリを投げない</li>
</ul>

<p>完璧を求めずにいきましょう。</p>

<p>でも、しつこいですが、セキュリティだけは、はじめから意識してくださいね。Security by design。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">27 Feb 2016, 12:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_tf_arm_sp/" class="post-title">TerraformをAzure ARMで使う時の認証</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="高まってまいりました:dfc3556fff242cb82e1ca9532877c49b">高まってまいりました</h2>

<p>全国10,000人のTerraformファンのみなさま、こんにちは。applyしてますか。</p>

<p>Terraformのマイナーバージョンアップのたびに、<a href="https://www.terraform.io/docs/providers/azurerm/index.html">Azure Resource Manager Providerのリソース</a>が追加されているので、ぼちぼちClassic(Service Management)からの移行を考えよう、という人もいるのでは。VMリソースが追加されたら、いよいよ、ですかね。</p>

<p>そこで、Classicとは認証方式が変わっているので、ご注意を、という話です。</p>

<h2 id="client-id-client-secret-って何よ:dfc3556fff242cb82e1ca9532877c49b">client_id/client_secret って何よ</h2>

<p>以下がARM向けのProvider設定です。</p>

<pre><code># Configure the Azure Resource Manager Provider
provider &quot;azurerm&quot; {
  subscription_id = &quot;...&quot;
  client_id       = &quot;...&quot;
  client_secret   = &quot;...&quot;
  tenant_id       = &quot;...&quot;
}
</code></pre>

<p>subscription_idは、いつものあれ。tenant_idは普段使わないけどどこかで見た気がする。でも、<strong>client_id/client_secret って何よ</strong>。ためしにポータルログインで使うID/パスワード指定したら、盛大にコケた。</p>

<pre><code>&quot;The provider needs to be configured with the credentials needed to generate OAuth tokens for the ARM API.&quot;
</code></pre>

<p>おっとそういうことか。OAuth。</p>

<h2 id="サービスプリンシパルを使おう:dfc3556fff242cb82e1ca9532877c49b">サービスプリンシパルを使おう</h2>

<p>Terraformをアプリケーションとして登録し、そのサービスプリンシパルを作成し権限を付与すると、使えるようになります。</p>

<p><a href="https://azure.microsoft.com/ja-jp/documentation/articles/active-directory-application-objects/">&ldquo;アプリケーション オブジェクトおよびサービス プリンシパル オブジェクト&rdquo;</a></p>

<p><a href="https://azure.microsoft.com/ja-jp/documentation/articles/resource-group-authenticate-service-principal/">&ldquo;Azure リソース マネージャーでのサービス プリンシパルの認証&rdquo;</a></p>

<p>以下、Azure CLIでの実行結果をのせておきます。WindowsでもMacでもLinuxでも手順は同じです。</p>

<p>まずは、Terraformをアプリとして登録します。&ndash;identifier-urisの存在チェックはないですが、ユニークにしなければいけません。また、&ndash;passwordはclient_secretになるので、おぼえておきましょう。</p>

<pre><code>$ azure ad app create --name &quot;My Terraform&quot; --home-page &quot;http://tftest.makabe.info&quot; --identifier-uris &quot;http://tftest.makabe.info&quot; --password pAssw0rd%
info:    Executing command ad app create
+ Creating application My Terraform
data:    AppId:                   AppId-AppId-AppId-AppId-AppId
data:    ObjectId:                AppObjId-AppObjId-AppObjId-AppObjId
data:    DisplayName:             My Terraform
data:    IdentifierUris:          0=http://tftest.makabe.info
data:    ReplyUrls:
data:    AvailableToOtherTenants:  False
data:    AppPermissions:
data:                             claimValue:  user_impersonation
data:                             description:  Allow the application to access My Terraform on behalf of the signed-in user.
data:                             directAccessGrantTypes:
data:                             displayName:  Access My Terraform
data:                             impersonationAccessGrantTypes:  impersonated=User, impersonator=Application
data:                             isDisabled:
data:                             origin:  Application
data:                             permissionId:  AppPermID-AppPermID-AppPermID-AppPermID
data:                             resourceScopeType:  Personal
data:                             userConsentDescription:  Allow the application to access My Terraform on your behalf.
data:                             userConsentDisplayName:  Access My Terraform
data:                             lang:
info:    ad app create command OK
</code></pre>

<p>次にサービスプリンシパルを作ります。AppIdは先ほどアプリを登録した際に生成されたものです。</p>

<pre><code>$ azure ad sp create AppId-AppId-AppId-AppId-AppId
info:    Executing command ad sp create
+ Creating service principal for application AppId-AppId-AppId-AppId-AppId
data:    Object Id:               SpObjId-SpObjId-SpObjId-SpObjId
data:    Display Name:            My Terraform
data:    Service Principal Names:
data:                             AppId-AppId-AppId-AppId-AppId
data:                             http://tftest.makabe.info
info:    ad sp create command OK
</code></pre>

<p>サービスプリンシパルの役割を設定します。&ndash;objectIdは、サービスプリンシパルのObject Idなのでご注意を。アプリのObject Idではありません。</p>

<p>この例では、サブスクリプションのContributorとして位置づけました。権限設定は慎重に。</p>

<pre><code>$ azure role assignment create --objectId SpObjId-SpObjId-SpObjId-SpObjId-SpObjId -o Contributor -c /subscriptions/SubId-SubId-SubId-SubId-SubId/
info:    Executing command role assignment create
+ Finding role with specified name
/data:    RoleAssignmentId     : /subscriptions/SubId-SubId-SubId-SubId-SubId/providers/Microsoft.Authorization/roleAssignments/RoleAsId-RoleAsId-RoleAsId-RoleAsId
data:    RoleDefinitionName   : Contributor
data:    RoleDefinitionId     : RoleDefId-RoleDefId-RoleDefId-RoleDefId-RoleDefId
data:    Scope                : /subscriptions/SubId-SubId-SubId-SubId-SubId
data:    Display Name         : My Terraform
data:    SignInName           :
data:    ObjectId             : SpObjId-SpObjId-SpObjId-SpObjId-SpObjId
data:    ObjectType           : ServicePrincipal
data:
+
info:    role assignment create command OK
</code></pre>

<p>サービスプリンシパルまわりの設定は以上です。</p>

<p>テナントIDを確認しておきましょう。</p>

<pre><code>$ azure account list --json
[
  {
    &quot;id&quot;: &quot;SubId-SubId-SubId-SubId-SubId&quot;,
    &quot;name&quot;: &quot;Your Subscription Name&quot;,
    &quot;user&quot;: {
      &quot;name&quot;: &quot;abc@microsoft.com&quot;,
      &quot;type&quot;: &quot;user&quot;
    },
    &quot;tenantId&quot;: &quot;TenantId-TenantId-TenantId-TenantId-TenantId&quot;,
    &quot;state&quot;: &quot;Enabled&quot;,
    &quot;isDefault&quot;: true,
    &quot;registeredProviders&quot;: [],
    &quot;environmentName&quot;: &quot;AzureCloud&quot;
  }
]
</code></pre>

<p>これでようやく.tfファイルが書けます。さくっとリソースグループでも作ってみましょう。</p>

<pre><code># Configure the Azure Resource Manager Provider
provider &quot;azurerm&quot; {
  subscription_id = &quot;SubId-SubId-SubId-SubId-SubId&quot;
  client_id       = &quot;AppId-AppId-AppId-AppId-AppId&quot;
  client_secret   = &quot;pAssw0rd%&quot;
  tenant_id       = &quot;TenantId-TenantId-TenantId-TenantId-TenantId&quot;
}

# Create a resource group
resource &quot;azurerm_resource_group&quot; &quot;test&quot; {
    name     = &quot;test&quot;
    location = &quot;Japan West&quot;
}
</code></pre>

<p>apply。もちろんplanしましたよ。</p>

<pre><code>$ terraform apply
azurerm_resource_group.test: Creating...
  location: &quot;&quot; =&gt; &quot;japanwest&quot;
  name:     &quot;&quot; =&gt; &quot;test&quot;
azurerm_resource_group.test: Creation complete

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.  
</code></pre>

<p>これで、ARM認証難民がうまれなくなりますように。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">11 Jan 2016, 00:20</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_infradeployment_selection/" class="post-title">Azureでインフラデプロイツールを選ぶ時に考えていること</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="ケースバイケースだけど:d8f24c1ecd76ea2b63a3969342359091">ケースバイケースだけど</h2>

<p>Azureを生業にして、3か月たちます。ここまで、もっとも質問や議論が多いのが、デプロイメントの自動化についてです。進化が早いですし、選択肢も豊富。クラウド採用に合わせて自動化に挑戦するケースも増えてますので、自然なことと思います。</p>

<p>特に話題になるのが「どのツールを選べばいいか」。ツールというのは課題を解決する手段なので、まず課題を掘るべきです。ですが、まだ成熟していない領域で変化が激しいですし、ツールひとつで課題を解決できるとも限らない。複数のツールを組み合わせることも多く、依存関係もありそう。となると、考えるきっかけが欲しいのは、ごもっとも。</p>

<p>なので「ケースバイケース。以上」とは、言いにくい。</p>

<p>私見であっても、たたき台となる考え方なりパターンがWebに転がっていれば、参考になるかもしれない。それがこのエントリを書く動機です。わたしは他のプラットフォームからAzureに主戦場を移していますので、新鮮な意見が書けるかも、という背景も、あります。</p>

<h2 id="書く前に前提など:d8f24c1ecd76ea2b63a3969342359091">書く前に前提など</h2>

<p>対象はインフラレイヤのデプロイメントに絞ります。そして、インフラ = 物理/仮想ハードウェア(サーバ、ストレージ、ネットワーク) + OS + プラットフォームソフト(アプリじゃないもの、Webサーバ、ユーティリティ、etc）と定義します。</p>

<p>レイヤリングや用語は、 @gosukenator さんの<a href="http://mizzy.org/blog/2013/10/29/1/">&ldquo;インフラ系技術の流れ&rdquo;</a>が参考になるので、合わせて読むと幸せになれるでしょう。このエントリで言うBootstrapping/Configurationレイヤが今回の焦点です。</p>

<p>では、わたしがツールを選ぶ時にどんなことを考えているのか、脳内をダンプしていきましょう。</p>

<h2 id="そもそもツールで自動化すべきかを考える:d8f24c1ecd76ea2b63a3969342359091">そもそもツールで自動化すべきかを考える</h2>

<p>いきなり萎えるそもそも論で恐縮ですが、重要です。たとえばあるソフトの試用目的で、同じ構成のサーバのデプロイは今後しなさそう、台数は1台、使うのは自分だけ、なんていう環境のデプロイまで、自動化する必要はないはずです。時短、工数削減、オペレーションミスリスクの軽減、そもそも自動化しないと運用がまわらない、など自動化によって得られる利益がその手間を上回るかを判断します。</p>

<p>なお「知っている/できる」人でないとその価値、利益はわかりません。やらないという判断は、腕があってはじめてできることです。</p>

<h2 id="使い捨てられないかを考える:d8f24c1ecd76ea2b63a3969342359091">使い捨てられないかを考える</h2>

<p>次は、ツールによって作った環境がどのように変化するか、変えられるかを検討します。ストレートに言うと、変化のタイミングで捨てられないか？新しいものに置き換えられないか？を考えます。もしこれができるのであれば、方式はとてもシンプルにできます。Immutable Infrastructure、Blue/Green Deploymentなどのやり口が注目されていますが、これらの根っこには「ちまちま変化を加えて複雑化するくらいなら、使い捨て/入れ替えてしまえ」という意識があります。</p>

<p>ですが、とは言ってもそんな大胆にできない事情もあると思います。Blue/Green Deploymentでは、入れ替えのタイミングでBlue、Green分のリソースが必要になりますし、切り替えにともなうリスクもあります。それを許容できない場合、同じインフラに変化を積んでいくことになります。ChefなどConfigurationレイヤで冪等なオペーレーションができるツールが注目されたのは、この変化を維持しやすいからです。</p>

<p>変化を積む場合にやるべきでないのは、中途半端に職人が真心こめて手作業してしまうことです。ツールでやると決めたら、少なくともそのカバー範囲はツールに任せましょう。でないといわゆる「手作業汚れ」「スノーフレークサーバ（雪の結晶のように、全部同じように見えて実はそれぞれ違う）」のダークサイドに堕ちます。</p>

<p>変化を積まないのであれば、インフラデプロイメント用途ではConfigurationレイヤのツールを導入しないという割り切りもできるでしょう。</p>

<h2 id="優先事項や制約条件を洗い出す:d8f24c1ecd76ea2b63a3969342359091">優先事項や制約条件を洗い出す</h2>

<p>アーキテクトが真っ白なキャンバスに画を描けることはほぼありません。きっと、先になんらかの優先事項や制約条件があるはずです。そして、ほとんどのシステムにおいて、インフラのデプロイは主役ではありません。ツールに合わせてもらえることはまれでしょう。様々な条件を選定にあたって洗い出す必要があります。</p>

<ul>
<li><em>社内/プロジェクト標準</em></li>
</ul>

<p>　周知されていないだけで、推奨ツールが決まってたりします。あるある。そのツールの良し悪しは置いておいて、社内ノウハウの蓄積など、大きな目的がある場合には従うべきでしょう。</p>

<ul>
<li><em>他レイヤでの優先ツール</em></li>
</ul>

<p>　インフラのデプロイに影響がありそうなツールがアプリ開発側で決まっていたりします。最近華やかなのがDockerです。Docker社が出してるツール群は上から下までカバー範囲も広く、デプロイツールと重複しがちです。組み合わせを検討しなければいけません。また、Apache Mesosもインフラとアプリのグレーゾーンに鎮座します。なかなか悩ましいですが、優先せざるをえません。</p>

<ul>
<li><em>規模</em></li>
</ul>

<p>　いきなり1000台とか10000台規模を扱うユーザは多くないと思いますが、その規模になるとツールの性能限界にぶち当たったりします。念のため、意識はしましょう。ちなみに、1000台をひとつのツールの傘に入れずとも、たとえば10*100台にする設計ができないか、事前に考えておくと打ち手が増えます。</p>

<ul>
<li><em>チーム or ひとり</em></li>
</ul>

<p>　本番環境のデプロイ自動化はチームプレイになるので、ツールの導入はサーバ上になるでしょうし、構成ファイルの共有、バージョンコントロールなど考慮点は多いです。一方で、開発者が開発、検証用途で端末に導入し実行する使い方では、手軽さが求められます。誤解を恐れず例をあげると、前者にはChefが、後者にはAnsibleやTerraformがフィットしやすいです。</p>

<ul>
<li><em>Windows or Linux</em></li>
</ul>

<p>　Azure ARM Templateなど、はじめからマルチOS環境を前提に作られているツールはありますが、ほとんどのツールはその生まれがWindows、Linuxに寄っています。マルチOS対応が進んではいますが、活用にあたって、参考となる情報量には大きな差があります。たとえばマルチOS対応のツールであっても、DSCはWindowsの、ChefやAnsibleはLinuxの情報が圧倒的に多いです。これは意識せざるを得ません。使うOSでの十分な情報があるか確認します。</p>

<h2 id="マネージドサービス-機能を活用する:d8f24c1ecd76ea2b63a3969342359091">マネージドサービス、機能を活用する</h2>

<p>マネージドサービス = プラットフォームが提供している機能です。Azureであれば、今回対象としているレイヤではARMがそれにあたります。デプロイツールは有用ですが、その導入や維持運用には本質的価値はありません。プラットフォームに任せられるのであれば、そうしたほうが楽です。</p>

<p>また、Azureのインフラは進化が早いため、それに対応するスピードも、本家ツールのほうが期待できます。</p>

<p>ですが、<a href="http://torumakabe.github.io/post/arm_idempotent/">以前のエントリ</a>で触れたように、本家のツールであっても、すべてのレイヤをカバーできるほど万能ではありません。たとえばARM TemplateはインフラのBootstrappingには向いていますが冪等性が限定的であるため、ソフトウェアパッケージを足す/消す/入れ替えるを頻繁に繰り返す環境のConfiguration用途では、苦しいです。</p>

<p>よってARM Templateは、Immutableな環境で使う、もしくは、ChefなどのConfigurationツールと組み合わせて使うことを念頭に設計をします。</p>

<p>ARM Templateでは、ハード(VM、ストレージ、ネットワーク)の割り当て、OSの導入と設定、各種エージェントの導入が基本。それに加え、Immutableな環境ではプラットフォームソフトを導入してしまっていいでしょう。ARM TemplateにはDSCやシェルを実行するエクステンションが使えるので、活用します。</p>

<p>また、Bootstrapping時点で、Configurationツールを導入できてしまうのであれば、せっかくなので入れてしまいましょう。たとえばChefサーバのインストールは、ここで。</p>

<p>以上、ちょっとまとまりに欠けますが、ざっとわたしが意識していることを、挙げてみました。</p>

<h2 id="汎用的-リファレンスアーキテクチャ:d8f24c1ecd76ea2b63a3969342359091">汎用的 リファレンスアーキテクチャ</h2>

<p>具体例があったほうが分かりやすいので、最後に汎用的な組み合わせを紹介します。</p>

<p><a href="https://gallery.technet.microsoft.com/Automating-Deployment-with-84c1549f">&ldquo;Automating Deployment with Azure &amp; Chef&rdquo;</a></p>

<ul>
<li><p>ARM TemplateでBootstrapping</p>

<ul>
<li>VMを4つ作成、1つはLinux、他はWindows</li>
<li>ストレージ、ネットワークの作成</li>
<li>VMのストレージ、ネットワーク設定</li>
<li>OSの導入</li>
<li>ドメインコントローラサーバへのソフト導入、各種設定 (DSC/PowerShell Extension)</li>
<li>他Windowsサーバへのソフト導入、各種設定、ドメイン参加 (PowerShell Extension)</li>
<li>LinuxへChefサーバを導入、各種設定 (Shell Extension)</li>
</ul></li>

<li><p>ChefでConfiguration</p>

<ul>
<li>各ノードのChef bootstrap(言葉が混同しやすいので注意)</li>
<li>Chef Clientサービスの起動設定</li>
<li>DBサーバのDB領域ディスク作成、フォーマット</li>
<li>DBサーバへSQL Server 2014のインストール</li>
<li>ChefがDBサーバが設定通りになるよう維持し続ける</li>
</ul></li>
</ul>

<p>どうでしょう、役割分担がイメージできたでしょうか。いいドキュメントがあったので、ChefのLinux/Windows混在例を紹介しましたが、Windowsとの親和性や情報量を重視するなら、ChefをAzure Automation DSCに置き換えて挑戦してもいいでしょう。そのまた逆もありで、ChefならLinux染めな環境で、とこだわってもいいと思います。</p>

<p>書くことが意外に多かったので、また機会があれば、参考例を交えて紹介します。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Jan 2016, 00:16</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/arm_idempotent/" class="post-title">Azure ARM Templateによるデプロイと冪等性</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="宣言的に-冪等に:7f9d18b141fe8baff11274b2e0ae3943">宣言的に、冪等に</h2>

<p>ここ数年で生まれたデプロイメント手法、ツールは数多くありますが、似たような特徴があります。それは「より宣言的に、冪等に」です。これまで可読性や再利用性を犠牲にしたシェル芸になりがちだったデプロイの世界。それがいま、あるべき姿を定義しその状態に収束させるように、また、何度ツールを実行しても同じ結果が得られるように変わってきています。</p>

<p>さて、そんな時流に飛び込んできたデプロイ手法があります。AzureのARM(Azure Resource Manager) Templateによるデプロイです。ARMはAzureのリソース管理の仕組みですが、そのARMに対し、構成を宣言的に書いたJSONを食わせて環境を構築する手法です。Azureの標準機能として、提供されています。</p>

<h3 id="azure-リソース-マネージャーの概要-https-azure-microsoft-com-ja-jp-documentation-articles-resource-group-overview:7f9d18b141fe8baff11274b2e0ae3943"><a href="https://azure.microsoft.com/ja-jp/documentation/articles/resource-group-overview/">Azure リソース マネージャーの概要</a></h3>

<blockquote>
<p>&ldquo;ソリューションを開発のライフサイクル全体で繰り返しデプロイできます。また、常にリソースが一貫した状態でデプロイされます&rdquo;</p>

<p>&ldquo;宣言型のテンプレートを利用し、デプロイメントを定義できます&rdquo;</p>
</blockquote>

<p>冪等と言い切ってはいませんが、目的は似ています。</p>

<p>なるほど、期待十分。ではあるのですが、冪等性の実現は簡単ではありません。たとえばChefやAnsibleも、冪等性はリソースやモジュール側で考慮する必要があります。多様なリソースの違いを吸収しなければいけないので、仕方ありません。魔法じゃないです。その辺を理解して使わないと、ハマります。</p>

<p>残念ながらARMは成長が著しく、情報が多くありません。そこで、今回は実行結果を元に、冪等さ加減を理解していきましょう。</p>

<h2 id="増分デプロイと完全デプロイ:7f9d18b141fe8baff11274b2e0ae3943">増分デプロイと完全デプロイ</h2>

<p>まず、デプロイのコマンド例を見ていきましょう。今回はPowerShellを使いますが、Mac/Linux/Winで使える<a href="https://github.com/Azure/azure-xplat-cli">クロスプラットフォームCLI</a>もあります。</p>

<pre><code>PS C:\&gt; New-AzureRmResourceGroupDeployment -ResourceGroupName YourRGName -TemplateFile .\azuredeploy.json -TemplateParameterFile .\azuredeploy.parameters.json
</code></pre>

<p>ワンライナーです。これだけで環境ができあがります。-TemplateFileでリソース定義を記述したJSONファイルを指定します。また、-TemplateParameterFileにパラメータを外だしできます。</p>

<p>今回は冪等さがテーマであるため詳細は省きます。関心のあるかたは、別途<a href="https://azure.microsoft.com/ja-jp/documentation/articles/resource-group-template-deploy/">ドキュメント</a>で確認してください。</p>

<p>さて、ワンライナーで環境ができあがるわけですが、その後が重要です。環境変更の際にJSONで定義を変更し、同じコマンドを再投入したとしても、破たんなく使えなければ冪等とは言えません。</p>

<p>コマンド投入には2つのモードがあります。増分(Incremental)と完全(Complete)です。まずは増分から見ていきましょう。</p>

<blockquote>
<p>・リソース グループに存在するが、テンプレートに指定されていないリソースを変更せず、そのまま残します</p>

<p>・テンプレートに指定されているが、リソース グループに存在しないリソースを追加します</p>

<p>・テンプレートに定義されている同じ条件でリソース グループに存在するリソースを再プロビジョニングしません</p>
</blockquote>

<p>すでに存在するリソースには手を入れず、JSONへ新たに追加されたリソースのみを追加します。</p>

<p>いっぽうで、完全モードです。</p>

<blockquote>
<p>・リソース グループに存在するが、テンプレートに指定されていないリソースを削除します</p>

<p>・テンプレートに指定されているが、リソース グループに存在しないリソースを追加します</p>

<p>・テンプレートに定義されている同じ条件でリソース グループに存在するリソースを再プロビジョニングしません</p>
</blockquote>

<p>2、3番目は増分と同じです。1番目が違います。JSONから定義を消されたリソースを削除するかどうかが、ポイントです。完全モードはスッキリするけどリスクも高そう、そんな印象を受けるのはわたしだけではないでしょう。</p>

<h2 id="動きをつかむ:7f9d18b141fe8baff11274b2e0ae3943">動きをつかむ</h2>

<p>では動きを見ていきましょう。テンプレートはGithubに公開されている<a href="https://github.com/Azure/azure-quickstart-templates/tree/master/101-vm-simple-linux">Very simple deployment of an Linux VM</a>を使います。詳細は説明しませんので、読み進める前にリソース定義テンプレートファイル(azuredeploy.json)を<a href="https://github.com/Azure/azure-quickstart-templates/blob/master/101-vm-simple-linux/azuredeploy.json">リンク先</a>でざっと確認してください。</p>

<p>パラメータファイル(azuredeploy.parameters.json)は以下とします。</p>

<pre><code>{
  &quot;$schema&quot;: &quot;http://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#&quot;,
  &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
  &quot;parameters&quot;: {
    &quot;adminUsername&quot;: {
      &quot;value&quot;: &quot;azureUser&quot;
    },
    &quot;adminPassword&quot;: {
      &quot;value&quot;: &quot;password1234!&quot;
    },
    &quot;dnsLabelPrefix&quot;: {
      &quot;value&quot;: &quot;armpocps&quot;
    },
    &quot;ubuntuOSVersion&quot;: {
      &quot;value&quot;: &quot;14.04.2-LTS&quot;
    }    
  }
}
</code></pre>

<p>まず、1回目の実行です。リソースグループ &ldquo;ARMEval&rdquo;に対しデプロイします。このリソースグループは前もって作っておいた空の箱です。</p>

<pre><code>PS C:\Workspace&gt; New-AzureRmResourceGroupDeployment -ResourceGroupName ARMEval -TemplateFile .\azuredeploy.json -TemplateParameterFile .\azuredeploy.parameters.json 

DeploymentName    : azuredeploy
ResourceGroupName : ARMEval
ProvisioningState : Succeeded
Timestamp         : 2016/01/04 11:46:41
Mode              : Incremental
TemplateLink      :
Parameters        :
                Name             Type                       Value
                ===============  =========================  ==========
                adminUsername    String                     azureUser
                adminPassword    SecureString
                dnsLabelPrefix   String                     armpocps
                ubuntuOSVersion  String                     14.04.2-LTS

Outputs           :
</code></pre>

<p>できあがりです。空のリソースグループ にLinux VM、ストレージ、仮想ネットワーク、パブリックIPなどがデプロイされました。Modeを指定しない場合は増分(Incremental)となります。</p>

<p>この環境にじわじわと変更を入れていきましょう。まずはazuredeploy.parameter.json上のパラメータ、DNS名のPrefix(dnsLabelPrefix)をarmpocps -&gt; armpocps2と変えます。</p>

<pre><code>&quot;dnsLabelPrefix&quot;: {
  &quot;value&quot;: &quot;armpocps2&quot;
},
</code></pre>

<p>では再投入です。パラメータファイルの内容は変えましたが、コマンドは同じです。</p>

<pre><code>PS C:\Workspace&gt; New-AzureRmResourceGroupDeployment -ResourceGroupName ARMEval -TemplateFile .\azuredeploy.json -TemplateParameterFile .\azuredeploy.parameters.json 
[snip]
Parameters        :
                Name             Type                       Value
                ===============  =========================  ==========
                adminUsername    String                     azureUser
                adminPassword    SecureString
                dnsLabelPrefix   String                     armpocps2
                ubuntuOSVersion  String                     14.04.2-LTS
</code></pre>

<p>変更内容の確認です。</p>

<pre><code>PS C:\Workspace&gt; Get-AzureRmPublicIpAddress
[snip]
DnsSettings              : {
                             &quot;DomainNameLabel&quot;: &quot;armpocps2&quot;,
                             &quot;Fqdn&quot;: &quot;armpocps2.japanwest.cloudapp.azure.com&quot;
                           }
</code></pre>

<p>問題なく変わっていますね。冪等チックです。この例ではシンプルにDNS名のPrefixを変えましたが、VMインスタンス数やsubnet名を変えたりもできます。関心のある方は<a href="https://gallery.technet.microsoft.com/Cloud-Consistency-with-0b79b775">ドキュメント</a>を。</p>

<p>増分モードによる変更は期待できそうです。が、さて、ここからが探検です。リソース削除が可能な完全モードを試してみましょう。
リソース定義ファイル(azuredeploy.json)から、大胆にVMの定義を削ってみます。下記リソースをファイルからごっそり消します。</p>

<pre><code>{
  &quot;apiVersion&quot;: &quot;[variables('apiVersion')]&quot;,
  &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines&quot;,
  &quot;name&quot;: &quot;[variables('vmName')]&quot;,
[snip]
</code></pre>

<p>では、完全モード &ldquo;-Mode complete&rdquo;付きでコマンドを再投入します。</p>

<pre><code>PS C:\Workspace&gt; New-AzureRmResourceGroupDeployment -ResourceGroupName ARMEval -TemplateFile .\azuredeploy.json -TemplateParameterFile .\azuredeploy.parameters.json  -Mode complete

確認
Are you sure you want to use the complete deployment mode? Resources in the resource group 'ARMEval' which are not included in the template will be deleted.
[Y] はい(Y)  [N] いいえ(N)  [S] 中断(S)  [?] ヘルプ (既定値は &quot;Y&quot;): Y

DeploymentName    : azuredeploy
ResourceGroupName : ARMEval
ProvisioningState : Succeeded
Timestamp         : 2016/01/04 12:01:00
Mode              : Complete
TemplateLink      :
Parameters        :
                Name             Type                       Value
                ===============  =========================  ==========
                adminUsername    String                     azureUser
                adminPassword    SecureString
                dnsLabelPrefix   String                     armpocps2
                ubuntuOSVersion  String                     14.04.2-LTS

Outputs           :
</code></pre>

<p>あっさり完了しました。本当にVMが消えているが確認します。出力が冗長ですがご容赦ください。</p>

<pre><code>PS C:\Workspace&gt; Find-AzureRmResource -ResourceGroupNameContains ARMEval

Name              : myPublicIP
ResourceId        :     /subscriptions/your-subscription-id/resourceGroups/ARMEval/providers/Microsoft.Network/publicIPAddresses/myPublicIP
ResourceName      : myPublicIP
ResourceType      : Microsoft.Network/publicIPAddresses
ResourceGroupName : ARMEval
Location          : japanwest
SubscriptionId    : your-subscription-id

Name              : myVMNic
ResourceId        : /subscriptions/your-subscription-id/resourceGroups/ARMEval/providers/Microsoft.Network/networkInterfaces/myVMNic
ResourceName      : myVMNic
ResourceType      : Microsoft.Network/networkInterfaces
ResourceGroupName : ARMEval
Location          : japanwest
SubscriptionId    : your-subscription-id

Name              : MyVNET
ResourceId        : /subscriptions/your-subscription-id/resourceGroups/ARMEval/providers/Microsoft.Network/virtualNetworks/MyVNET
ResourceName      : MyVNET
ResourceType      : Microsoft.Network/virtualNetworks
ResourceGroupName : ARMEval
Location          : japanwest
SubscriptionId    : your-subscription-id

Name              : yourstorageaccount
ResourceId        : /subscriptions/your-subscription-id/resourceGroups/ARMEval/providers/Microsoft.Storage/storageAccounts/yourstorageaccount
ResourceName      : yourstorageaccount
ResourceType      : Microsoft.Storage/storageAccounts
ResourceGroupName : ARMEval
Location          : japanwest
SubscriptionId    : your-subscription-id
Tags              : {}
</code></pre>

<p>VMだけが消えています。定義からリソースがなくなれば、存在するリソースも消す、これが完全モードです。</p>

<p>さらに検証。冪等さを求めるのであれば、またリソース定義にVMを加えて再投入したら、涼しい顔で復活してほしい。先ほどazuredeploy.jsonから消したVMリソース定義を、そのまま書き戻して再投入してみます。</p>

<pre><code>PS C:\Workspace&gt; New-AzureRmResourceGroupDeployment -ResourceGroupName ARMEval -TemplateFile .\azuredeploy.json -TemplateParameterFile .\azuredeploy.parameters.json  -Mode complete

確認
Are you sure you want to use the complete deployment mode? Resources in the resource group 'ARMEval' which are not included in the template will be deleted.
[Y] はい(Y)  [N] いいえ(N)  [S] 中断(S)  [?] ヘルプ (既定値は &quot;Y&quot;): Y

New-AzureRmResourceGroupDeployment : 21:05:52 - Resource Microsoft.Compute/virtualMachines 'MyUbuntuVM' failed with message 'The resource operation completed with terminal provisioning state 'Failed'.'
[snip]
New-AzureRmResourceGroupDeployment : 21:05:52 - One or more errors occurred while preparing VM disks. See disk instance view for details.
</code></pre>

<p>残念ながら失敗しました。どうやらdiskまわりのエラーが発生したようです。</p>

<p>これは、完全モードでのリソース削除の仕様が原因です。ARMは該当のVMリソースは消すのですが、VMが格納されているストレージを削除しません。リソース作成時は依存関係が考慮されますが、削除時は異なります。</p>

<p>試しにストレージを消して再実行してみましょう。</p>

<pre><code>PS C:\Workspace&gt; New-AzureRmResourceGroupDeployment -ResourceGroupName ARMEval -TemplateFile .\azuredeploy.json -TemplateParameterFile .\azuredeploy.parameters.json  -Mode complete

[snip]
ProvisioningState : Succeeded
</code></pre>

<p>定義通りの環境になりました。依存関係をたどって消してほしいのが人情ですが、残したほうがいいケースもあるので、今後の改善を期待しましょう。</p>

<h2 id="使い方:7f9d18b141fe8baff11274b2e0ae3943">使い方</h2>

<p>冪等であると言い切れないものの、リソース定義と実行モードを理解したうえで使えば有用。ただ、完全モードによる削除は使い方が難しい。現状ではそんな印象です。</p>

<p>そこで、ARM Templateをデプロイに組み込む際、ARMによるデプロイはBootstrap用途に限定し、より構成頻度が高いConfiguration用途には、冪等性を持った別のツールを組み合わせるのが現実解と考えます。</p>

<p>Bootstrap用途では、プラットフォームの提供機能を使ったほうが、機能も多いし最適化されています。Azureで今後この層を担当していくのはARMです。そして、この用途ではChefやAnsibleなど汎用ツールに物足りなさがあります。</p>

<p>また、Bootstrapは1回切りであるケースが多いので、失敗したらリソースグループをばっさり消して再作成する、と割り切りやすいです。それならば冪等でなくともいいでしょう。</p>

<p>長くなったので、デプロイツールの組み合わせについては、あたらめて書きたいと思います。</p>

<p>参考: <a href="http://mizzy.org/blog/2013/10/29/1/">インフラ系技術の流れ Bootstrapping/Configuration/Orchestration</a></p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
