<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.15" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Docker &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Docker &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">29 Apr 2016, 17:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_batch_docker/" class="post-title">Azure BatchとDockerで管理サーバレスバッチ環境を作る</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="サーバレスって言ってみたかっただけじゃないです:1e958ca6820e4dcff939a22a84382ed3">サーバレスって言ってみたかっただけじゃないです</h2>

<p>Linux向けAzure BatchのPreviewが<a href="https://azure.microsoft.com/ja-jp/blog/announcing-support-of-linux-vm-on-azure-batch-service/">はじまり</a>ました。地味ですが、なかなかのポテンシャルです。</p>

<p>クラウドでバッチを走らせる時にチャレンジしたいのは、「ジョブを走らせる時だけサーバー使う。待機時間は消しておいて、
節約」でしょう。</p>

<p>ですが、仕組み作りが意外に面倒なんですよね。管理サーバーを作って、ジョブ管理ソフト入れて、Azure SDK/CLI入れて。クレデンシャルを安全に管理して。可用性確保して。バックアップして。で、管理サーバーは消せない。なんか中途半端です。</p>

<p>その課題、Azure Batchを使って解決しましょう。レッツ管理サーバーレスバッチ処理。</p>

<h2 id="コンセプト:1e958ca6820e4dcff939a22a84382ed3">コンセプト</h2>

<ul>
<li>管理サーバーを作らない</li>
<li>Azure Batchコマンドでジョブを投入したら、あとはスケジュール通りに定期実行される</li>
<li>ジョブ実行サーバーは必要な時に作成され、処理が終わったら削除される</li>
<li>サーバーの迅速な作成とアプリ可搬性担保のため、dockerを使う</li>
<li>セットアップスクリプト、タスク実行ファイル、アプリ向け入力/出力ファイルはオブジェクトストレージに格納</li>
</ul>

<h2 id="サンプル:1e958ca6820e4dcff939a22a84382ed3">サンプル</h2>

<p>Githubにソースを<a href="https://github.com/ToruMakabe/Azure_Batch_Sample">置いておきます</a>。</p>

<h3 id="バッチアカウントとストレージアカウント-コンテナーの作成とアプリ-データの配置:1e958ca6820e4dcff939a22a84382ed3">バッチアカウントとストレージアカウント、コンテナーの作成とアプリ、データの配置</h3>

<p><a href="https://azure.microsoft.com/ja-jp/documentation/articles/batch-technical-overview/">公式ドキュメント</a>で概要を確認しましょう。うっすら理解できたら、バッチアカウントとストレージアカウントを作成します。</p>

<p>ストレージアカウントに、Blobコンテナーを作ります。サンプルの構成は以下の通り。</p>

<pre><code>.
├── blob
│   ├── application
│   │   ├── starttask.sh
│   │   └── task.sh
│   ├── input
│   │   └── the_star_spangled_banner.txt
│   └── output
</code></pre>

<p>applicationコンテナーに、ジョブ実行サーバー(Pool)作成時のスクリプト(starttask.sh)と、タスク実行時のスクリプト(task.sh)を配置します。</p>

<ul>
<li><a href="https://github.com/ToruMakabe/Azure_Batch_Sample/blob/master/blob/application/starttask.sh">starttask.sh</a> - docker engineをインストールします</li>
<li><a href="https://github.com/ToruMakabe/Azure_Batch_Sample/blob/master/blob/application/task.sh">task.sh</a> - docker hubからサンプルアプリが入ったコンテナーを持ってきて実行します。<a href="https://github.com/ToruMakabe/Azure_Batch_Sample/tree/master/docker">サンプル</a>はPythonで書いたシンプルなWord Countアプリです</li>
</ul>

<p>また、アプリにデータをわたすinputコンテナーと、実行結果を書き込むoutputコンテナーも作ります。サンプルのinputデータはアメリカ国歌です。</p>

<p>さて、いよいよジョブをJSONで定義します。詳細は<a href="https://msdn.microsoft.com/en-us/library/azure/dn820158.aspx?f=255&amp;MSPPError=-2147217396">公式ドキュメント</a>を確認してください。ポイントだけまとめます。</p>

<ul>
<li>2016/04/29 05:30(UTC)から開始する - schedule/doNotRunUntil</li>
<li>4時間ごとに実行する - schedule/recurrenceInterval</li>
<li>ジョブ実行後にサーバープールを削除する - jobSpecification/poolInfo/autoPoolSpecification/poolLifetimeOption</li>
<li>ジョブ実行時にtask.shを呼び出す  - jobSpecification/jobManagerTask/commandLine</li>
<li>サーバーはUbuntu 14.04とする - jobSpecification/poolInfo/autoPoolSpecification/virtualMachineConfiguration</li>
<li>サーバー数は1台とする - jobSpecification/poolInfo/autoPoolSpecification/pool/targetDedicated</li>

<li><p>サーバープール作成時にstarttask.shを呼び出す - jobSpecification/poolInfo/autoPoolSpecification/pool/startTask</p>

<p>{
&ldquo;odata.metadata&rdquo;:&ldquo;<a href="https://myaccount.myregion.batch.azure.com/$metadata#jobschedules/@Element&quot;">https://myaccount.myregion.batch.azure.com/$metadata#jobschedules/@Element&quot;</a>,
&ldquo;id&rdquo;:&ldquo;myjobschedule1&rdquo;,
&ldquo;schedule&rdquo;: {
    &ldquo;doNotRunUntil&rdquo;:&ldquo;2016-04-29T05:30:00.000Z&rdquo;,
    &ldquo;recurrenceInterval&rdquo;:&ldquo;PT4H&rdquo;
},
&ldquo;jobSpecification&rdquo;: {
    &ldquo;priority&rdquo;:100,
    &ldquo;constraints&rdquo;: {
        &ldquo;maxWallClockTime&rdquo;:&ldquo;PT1H&rdquo;,
        &ldquo;maxTaskRetryCount&rdquo;:-1
    },
    &ldquo;jobManagerTask&rdquo;: {
        &ldquo;id&rdquo;:&ldquo;mytask1&rdquo;,
        &ldquo;commandLine&rdquo;:&ldquo;/bin/bash -c &lsquo;export LC_ALL=en_US.UTF-8; ./task.sh&rsquo;&ldquo;,
        &ldquo;resourceFiles&rdquo;: [ {
            &ldquo;blobSource&rdquo;:&ldquo;yourbloburi&amp;sas&rdquo;,
            &ldquo;filePath&rdquo;:&ldquo;task.sh&rdquo;
        }],
        &ldquo;environmentSettings&rdquo;: [ {
            &ldquo;name&rdquo;:&ldquo;VAR1&rdquo;,
            &ldquo;value&rdquo;:&ldquo;hello&rdquo;
        } ],
        &ldquo;constraints&rdquo;: {
            &ldquo;maxWallClockTime&rdquo;:&ldquo;PT1H&rdquo;,
            &ldquo;maxTaskRetryCount&rdquo;:0,
            &ldquo;retentionTime&rdquo;:&ldquo;PT1H&rdquo;
        },
        &ldquo;killJobOnCompletion&rdquo;:false,
        &ldquo;runElevated&rdquo;:true,
        &ldquo;runExclusive&rdquo;:true
        },
        &ldquo;poolInfo&rdquo;: {
            &ldquo;autoPoolSpecification&rdquo;: {
                &ldquo;autoPoolIdPrefix&rdquo;:&ldquo;mypool&rdquo;,
                &ldquo;poolLifetimeOption&rdquo;:&ldquo;job&rdquo;,
                &ldquo;pool&rdquo;: {
                    &ldquo;vmSize&rdquo;:&ldquo;STANDARD_D1&rdquo;,
                    &ldquo;virtualMachineConfiguration&rdquo;: {
                        &ldquo;imageReference&rdquo;: {
                        &ldquo;publisher&rdquo;:&ldquo;Canonical&rdquo;,
                        &ldquo;offer&rdquo;:&ldquo;UbuntuServer&rdquo;,
                        &ldquo;sku&rdquo;:&ldquo;14.04.4-LTS&rdquo;,
                        &ldquo;version&rdquo;:&ldquo;latest&rdquo;
                        },
                        &ldquo;nodeAgentSKUId&rdquo;:&ldquo;batch.node.ubuntu 14.04&rdquo;
                    },
                    &ldquo;resizeTimeout&rdquo;:&ldquo;PT15M&rdquo;,
                    &ldquo;targetDedicated&rdquo;:1,
                    &ldquo;maxTasksPerNode&rdquo;:1,
                    &ldquo;taskSchedulingPolicy&rdquo;: {
                        &ldquo;nodeFillType&rdquo;:&ldquo;Spread&rdquo;
                    },
                    &ldquo;enableAutoScale&rdquo;:false,
                    &ldquo;enableInterNodeCommunication&rdquo;:false,
                    &ldquo;startTask&rdquo;: {
                        &ldquo;commandLine&rdquo;:&ldquo;/bin/bash -c &lsquo;export LC_ALL=en_US.UTF-8; ./starttask.sh&rsquo;&ldquo;,
                        &ldquo;resourceFiles&rdquo;: [ {
                        &ldquo;blobSource&rdquo;:&ldquo;yourbloburi&amp;sas&rdquo;,
                        &ldquo;filePath&rdquo;:&ldquo;starttask.sh&rdquo;
                        } ],
                        &ldquo;environmentSettings&rdquo;: [ {
                        &ldquo;name&rdquo;:&ldquo;VAR2&rdquo;,
                        &ldquo;value&rdquo;:&ldquo;Chao&rdquo;
                        } ],
                        &ldquo;runElevated&rdquo;:true,
                        &ldquo;waitForSuccess&rdquo;:true
                    },
                    &ldquo;metadata&rdquo;: [ {
                        &ldquo;name&rdquo;:&ldquo;myproperty&rdquo;,
                        &ldquo;value&rdquo;:&ldquo;myvalue&rdquo;
                    } ]
                }
            }
        }
     }
}</p></li>
</ul>

<p>他にも面白そうなパラメータがありますね。またの機会に。</p>

<p>ではスケジュールジョブをAzure Batchに送り込みます。</p>

<pre><code>azure batch job-schedule create -f ./create_jobsched.json -u https://yourendpoint.location.batch.azure.com -a yourbatchaccount -k yourbatchaccountkey
</code></pre>

<p>以上です。あとはAzureにお任せです。4時間に1回、アメリカ国歌の単語を数える刺身タンポポなジョブですが、はじめはシンプルに。</p>

<h2 id="azure-automationとの使い分け:1e958ca6820e4dcff939a22a84382ed3">Azure Automationとの使い分け</h2>

<p>Azure Automationを使っても、ジョブの定期実行はできます。大きな違いは、PowerShellの要否と並列実行フレームワークの有無です。Azure AutomationはPowerShell前提ですが、Azure BatchはPowerShellに馴染みのない人でも使うことができます。また、今回は触れませんでしたが、Azure Batchはオートスケールなど、バッチ処理に特化した機能を提供していることも特長です。うまく使い分けてください。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">17 Apr 2016, 10:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_docker_cntk/" class="post-title">AzureとDockerでDeep Learning(CNTK)環境をサク作する</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="気軽に作って壊せる環境を作る:7c419a069d08019c3093e0308a68c463">気軽に作って壊せる環境を作る</h2>

<p>Deep Learning環境設計のお手伝いをする機会に恵まれまして。インフラおじさんはDeep Learningであれこれする主役ではないのですが、ちょっとは中身を理解しておきたいなと思い、環境作ってます。</p>

<p>試行錯誤するでしょうから、萎えないようにデプロイは自動化します。</p>

<h2 id="方針:7c419a069d08019c3093e0308a68c463">方針</h2>

<ul>
<li>インフラはAzure Resource Manager Templateでデプロイする

<ul>
<li>Linux (Ubuntu 14.04) VM, 仮想ネットワーク/ストレージ関連リソース</li>
</ul></li>
<li>CNTKをビルド済みのdockerリポジトリをDocker Hubに置いておく

<ul>
<li>Dockerfileの元ネタは<a href="https://github.com/Microsoft/CNTK/tree/master/Tools/docker">ここ</a>

<ul>
<li>GPUむけもあるけどグッと我慢、今回はCPUで</li>
</ul></li>
<li>Docker Hub上のリポジトリは <a href="https://hub.docker.com/r/torumakabe/cntk-cpu/">torumakabe/cntk-cpu</a></li>
</ul></li>
<li>ARM TemplateデプロイでVM Extensionを仕込んで、上物のセットアップもやっつける

<ul>
<li>docker extensionでdocker engineを導入</li>
<li>custom script extensionでdockerリポジトリ(torumakabe/cntk-cpu)をpull</li>
</ul></li>
<li>VMにログインしたら即CNTKを使える、幸せ</li>
</ul>

<h2 id="使い方:7c419a069d08019c3093e0308a68c463">使い方</h2>

<p>Azure CLIでARM Templateデプロイします。WindowsでもMacでもLinuxでもOK。</p>

<p>リソースグループを作ります。</p>

<pre><code>C:\Work&gt; azure group create CNTK -l &quot;Japan West&quot;
</code></pre>

<p>ARMテンプレートの準備をします。テンプレートはGithubに置いておきました。</p>

<ul>
<li><a href="https://github.com/ToruMakabe/CNTK/blob/master/deploy_singlenode/azuredeploy.json">azuredeploy.json</a>

<ul>
<li>編集不要です</li>
</ul></li>
<li><a href="https://github.com/ToruMakabe/CNTK/blob/master/deploy_singlenode/azuredeploy.parameters.sample.json">azuredeploy.parameters.json</a>

<ul>
<li>テンプレートに直で書かきたくないパラメータです</li>
<li>fileUris、commandToExecute以外は、各々で</li>
<li>fileUris、commandToExecuteもGist読んでdocker pullしているだけなので、お好みで変えてください</li>
<li>ファイル名がazuredeploy.parameters.&ldquo;sample&rdquo;.jsonなので、以降の手順では&rdquo;sample&rdquo;を外して読み替えてください</li>
</ul></li>
</ul>

<p>うし、デプロイ。</p>

<pre><code>C:\Work&gt; azure group deployment create CNTK dep01 -f .\azuredeploy.json -e .\azuredeploy.parameters.json
</code></pre>

<p>10分くらい待つと、できあがります。VMのパブリックIPを確認し、sshしましょう。</p>

<p>docker engine入ってますかね。</p>

<pre><code>yourname@yournamecntkr0:~$ docker -v
Docker version 1.11.0, build 4dc5990
</code></pre>

<p>CNTKビルド済みのdockerイメージ、pullできてますかね。</p>

<pre><code>yourname@yournamecntkr0:~$ docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
yournamebe/cntk-cpu   latest              9abab8a76543        9 hours ago         2.049 GB
</code></pre>

<p>問題なし。ではエンジョイ Deep Learning。</p>

<pre><code>yourname@yournamecntkr0:~$ docker run -it torumakabe/cntk-cpu
root@a1234bc5d67d:/cntk#
</code></pre>

<p>CNTKの利用例は、<a href="https://github.com/Microsoft/CNTK/tree/master/Examples">Github</a>にあります。</p>

<h2 id="今後の展開:7c419a069d08019c3093e0308a68c463">今後の展開</h2>

<p>インフラおじさんは、最近Linuxむけに<a href="https://azure.microsoft.com/ja-jp/blog/announcing-support-of-linux-vm-on-azure-batch-service/">Previewがはじまった</a>Azure Batchと、このエントリで使った仕掛けを組み合わせて、大規模並列Deep Learning環境の自動化と使い捨て化を企んでいます。</p>

<p>これだけ簡単に再現性ある環境を作れるなら、常時インフラ起動しておく必要ないですものね。使い捨てでいいです。</p>

<p>もちろんdockerやGPUまわりの性能など別の課題にぶつかりそうですが、人間がどれだけ楽できるかとのトレードオフかと。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">19 Dec 2015, 00:01</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_openstack_swarm/" class="post-title">OpenStackとAzureにDocker Swarmをかぶせてみた</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="どこいってもいじられる:9e7f40e1d4e6f185223966639b28e39a">どこいってもいじられる</h2>

<p><a href="http://www.adventar.org/calendars/968">OpenStack Advent Calendar 2015</a> 参加作品、19夜目のエントリです。</p>

<p>OpenStackの最前線から離れて3か月がたちました。OpenStackつながりな方にお会いするたび、マイルドなかわいがりをうけます。ほんとうにありがとうございます。仕事としては専門でなくなりましたが、ユーザ会副会長の任期はまだ残っているので、積極的にいじられに行く所存です。でも笑いながら蹴ったりするのはやめてください。</p>

<p>さて、毎年参加しているOpenStack Advent Calendarですが、せっかくだからいまの専門とOpenStackを組み合わせたいと思います。ここはひとつ、OpenStackとAzureを組み合わせて何かやってみましょう。</p>

<h2 id="乗るしかないこのdockerウェーブに:9e7f40e1d4e6f185223966639b28e39a">乗るしかないこのDockerウェーブに</h2>

<p>どうせなら注目されている技術でフュージョンしたいですね。2015年を振り返って、ビッグウェーブ感が高かったのはなんでしょう。はい、Dockerです。Dockerを使ってOpenStackとAzureを組み合わせてみます。あまり難しいことをせず、シンプルにサクッとできることを。年末ですし、「正月休みにやってみっか」というニーズにこたえます。</p>

<p>ところでOpenStack環境はどうやって調達しましょう。ちょっと前までは身の回りに売るほどあったのですが。探さないといけないですね。せっかくなので日本のサービスを探してみましょう。</p>

<p>条件はAPIを公開していること。じゃないと、Dockerの便利なツール群が使えません。Linuxが動くサービスであれば、Docker環境をしみじみ手作業で夜なべして作れなくもないですが、嫌ですよね。正月休みは修行じゃなくて餅食って酒飲みたい。安心してください、わかってます。人力主義では、せっかくサクサク使えるDockerが台無しです。</p>

<p>あと、当然ですが個人で気軽にオンラインで契約できることも条件です。</p>

<p>そうすると、ほぼ一択。<a href="https://www.conoha.jp/">Conoha</a>です。かわいらしい座敷童の<a href="https://www.conoha.jp/conohadocs/?btn_id=top_footer_conotsu">&ldquo;このは&rdquo;</a>がイメージキャラのサービスです。作っているのは手練れなOSSANたちですが。</p>

<p>では、AzureとConohaにDocker環境をサクッと作り、どちらにもサクッと同じコンテナを作る。もちろん同じCLIから。ということをしてみようと思います。</p>

<p>今回大活躍するDoker Machine、Swarmの説明はしませんが、関心のある方は<a href="http://www.slideshare.net/zembutsu/whats-new-aobut-docker-2015-network-and-orchestration">前佛さんの資料</a>を参考にしてください。</p>

<h2 id="ローカル環境:9e7f40e1d4e6f185223966639b28e39a">ローカル環境</h2>

<ul>
<li>Mac OS X (El Capitan)

<ul>
<li>Docker Toolbox 1.9.1</li>
</ul></li>
</ul>

<p>ローカル、Azure、ConohaすべてのDocker環境はDocker Machineでサクッと作ります。
また、Swarmのマスタはローカルに配置します。</p>

<h2 id="いざ実行:9e7f40e1d4e6f185223966639b28e39a">いざ実行</h2>

<p>まず、Docker Machineにクラウドの諸設定を食わせます。</p>

<p>Azure向けにサブスクリプションIDとCertファイルの場所を指定します。詳細は<a href="https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-docker-machine/">ここ</a>を。</p>

<pre><code>$ export AZURE_SUBSCRIPTION_ID=hoge-fuga-hoge-fuga-hoge
$ export AZURE_SUBSCRIPTION_CERT=~/.ssh/yourcert.pem
</code></pre>

<p>Conoha向けにOpenStack関連の環境変数をセットします。</p>

<pre><code>$ export OS_USERNAME=yourname
$ export OS_TENANT_NAME=yourtenantname
$ export OS_PASSWORD=yourpass
$ export OS_AUTH_URL=https://identity.tyo1.conoha.io/v2.0
</code></pre>

<p>次はローカルコンテナ環境を整えます。</p>

<p>Swarmコンテナを起動し、ディスカバリトークンを生成します。このトークンがSwarmクラスタの識別子です。</p>

<pre><code>$ docker-machine create -d virtualbox local
$ eval &quot;$(docker-machine env local)&quot;
$ docker run swarm create    
Status: Downloaded newer image for swarm:latest
tokentokentokentoken
</code></pre>

<p>このトークンは控えておきましょう。</p>

<p>ではSwarmのマスタをローカルに作ります。先ほど生成したトークン指定を忘れずに。</p>

<pre><code>$ docker-machine create -d virtualbox --swarm --swarm-master --swarm-discovery token://tokentokentokentoken head
</code></pre>

<p>SwarmのエージェントをAzureに作ります。VMを作って、OSとDockerをインストールして、なんて不要です。Docker Machineがやってくれます。ここでもトークン指定を忘れずに。</p>

<pre><code>$ eval &quot;$(docker-machine env head)&quot;
$ docker-machine create -d azure --swarm --swarm-discovery token://tokentokentokentoken worker-azure01 --azure-location &quot;East Asia&quot; worker-azure00
</code></pre>

<p>Conohaにも同様に。</p>

<pre><code>$ docker-machine create -d openstack --openstack-flavor-name g-1gb --openstack-image-name vmi-ubuntu-14.04-amd64 --openstack-sec-groups &quot;default,gncs-ipv4-all&quot; --swarm --swarm-discovery token://tokentokentokentoken worker-conoha00
</code></pre>

<p>さあ環境がサクッと出来上がりました。これ以降はSwarmクラスタ全体を操作対象にします。</p>

<pre><code>$ eval &quot;$(docker-machine env --swarm head)&quot;
</code></pre>

<p>環境をチラ見してみましょう。</p>

<pre><code>$ docker info
Containers: 4
Images: 3
 Role: primary
 Strategy: spread
 Filters: health, port, dependency, affinity, constraint
 Nodes: 3
 head: 192.168.99.101:2376
  └ Containers: 2
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.021 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.13-boot2docker, operatingsystem=Boot2Docker 1.9.1 (TCL 6.4.1); master : cef800b - Fri Dec 18 19:33:59 UTC 2015, provider=virtualbox, storagedriver=aufs
 worker-azure00: xxx.cloudapp.net:2376
  └ Containers: 1
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.721 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=3.13.0-36-generic, operatingsystem=Ubuntu 14.04.1 LTS, provider=azure, storagedriver=aufs
 worker-conoha00: www.xxx.yyy.zzz:2376
  └ Containers: 1
  └ Reserved CPUs: 0 / 2
  └ Reserved Memory: 0 B / 1.019 GiB
  └ Labels: executiondriver=native-0.2, kernelversion=3.16.0-51-generic, operatingsystem=Ubuntu 14.04.3 LTS, provider=openstack, storagedriver=aufs
CPUs: 4
Total Memory: 3.761 GiB
Name: 1234abcd
</code></pre>

<p>どこにどんな環境が作られたかが分かりますね。出力結果の4行目&rdquo;Strategy: spread&rdquo;を覚えておいてください。</p>

<p>ではコンテナを作ってみましょう。Nginxコンテナ三連星です。どの環境に作るか、という指定はしません。</p>

<pre><code>$ for i in `seq 1 3`; do docker run -d -p 80:80 nginx; done
</code></pre>

<p>どんな具合でしょう。</p>

<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                NAMES
9cc2f5594fa5        nginx               &quot;nginx -g 'daemon off&quot;   5 seconds ago       Up 4 seconds        192.168.99.101:80-&gt;80/tcp, 443/tcp   head/goofy_goldberg
b9d54d794a85        nginx               &quot;nginx -g 'daemon off&quot;   32 seconds ago      Up 31 seconds       www.xxx.yyy.zzz:80-&gt;80/tcp, 443/tcp   worker-conoha00/clever_chandrasekhar
19e9d0e229a2        nginx               &quot;nginx -g 'daemon off&quot;   45 seconds ago      Up 42 seconds       zzz.yyy.xxx.www:80-&gt;80/tcp, 443/tcp    worker-azure00/reverent_bhaskara
</code></pre>

<p>Nginxコンテナがきれいに散らばっているのが分かります。これは先ほど覚えた&rdquo;Strategy: spread&rdquo;が効いているからです。StrategyはSwarmのコンテナ配置ポリシーで、speradを指定すると散らしにいきます。Strategyをbinpackにしておけば、ノードを埋めようとします。埋まったら他、です。randomであれば、ランダムに。</p>

<p>まだシンプルですが、今後このStrategyやリソース管理が賢くなると、「ローカルが埋まったら、リモートを使う」とか、使い道が広がりそうですね。最近Docker社が買収した<a href="https://www.tutum.co/">Tutum</a>との関係、今後どう進化していくのか、注目です。</p>

<h2 id="ツールから入るハイブリッドクラウドも-またよし:9e7f40e1d4e6f185223966639b28e39a">ツールから入るハイブリッドクラウドも、またよし</h2>

<p>ハイブリッドクラウドはまだ言葉先行です。まだクラウドを使ってない、使いこなしていない段階でツールの話だけが先行することも多いです。ナイフとフォークしか使ったことのない人が、お箸を使う和食や中華を選ぶ前に「どんなお箸がいいかねぇ」と議論している感じ。僕は、そうじゃなくて、その前に食べたいもの = クラウドを選びましょうよ、というスタンスでした。</p>

<p>でも、コンテナ+Dockerって、お箸に弁当ついてきたような感じなんですよね。お箸が使える人であれば、弁当持ち込める場所さえ確保すればいい。インパクトでかいです。ちょっと考えを改めました。</p>

<p>もちろん、だからクラウドは何でもいい、と言っているわけではありません。弁当持ち込みとしても、スペースが広い、個室で静か、お茶がうまい、お茶がタダ、揚げたてのから揚げを出してくれる、などなど、特徴は出てくるでしょう。APIを公開していないような「持ち込みやめて」のクラウドは、先々心配ですが。</p>

<p>簡単 = 正義です。簡単であれば使う人が増えて、要望が増えて、育ちます。かっちり感は後からついてくる。もしDockerで複数のクラウド環境を簡単に使いこなせるようになるのであれば、順番が逆ではありますが、お箸、Dockerというツールから入るのもいいかもしれません。</p>

<p>まずは開発、検証環境など、リスク低いところから試して慣れていくのがおすすめです。触っていくうちに、いろいろ見えてくるでしょう。Dockerはもちろんですが、それぞれのクラウドの特徴も。</p>

<p>OpenStackもAzureも、特徴を活かし、うまく使いこなしてほしいと思っております。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">05 Nov 2015, 15:40</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_docker_extension/" class="post-title">Azure Docker VM Extensionを使う3つの理由</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="まずはじめに:488dcbba59f3c8d3d94b3ed8ace3af66">まずはじめに</h2>

<p>先月からMicrosoftで働いてます。Azure担当のソリューションアーキテクトになりました。これからAzureネタが増えると思いますが、ひとつよろしくお願いします。Microsoftテクノロジーとオープンソースの間あたりを、積極的にこすっていく所存です。</p>

<p>もちろん、技術者個人として、中立的に、公開できるネタを書きます。</p>

<p>AzureはMicrosoftテクノロジーとオープンソースの交差点です。できないと思っていたことが、実はできたりします。いまだに「AzureでLinux動くのね、知らなかった」と言われたり。また、その逆もしかり。SDKが色々あるからできると思っていたら、制約があった、とか。</p>

<p>なので、小ネタであっても、実践的な情報には価値があります。今後、公式ドキュメントでカバーされなかったり、細かすぎて伝わりづらいなことを、書いていこうかと。</p>

<h2 id="azure-docker-vm-extension-を使う3つの理由:488dcbba59f3c8d3d94b3ed8ace3af66">Azure Docker VM Extension を使う3つの理由</h2>

<p>さて、今回は話題沸騰のDocker関連のネタ、<a href="https://github.com/Azure/azure-docker-extension">Azure Docker VM Extension</a>について。名前通り、Azure上でDockerをのせたVMを動かすときに便利な拡張機能です。</p>

<p>このDocker VM Extension、AzureのARMテンプレートによく登場します。なんとなくおすすめっぽいです。ですが「自分でDockerをインストールするのと何が違うのよ」という疑問も、あるかと思います。実際、よく聞かれます。</p>

<p>ずばり、答えはGithubの<a href="https://github.com/Azure/azure-docker-extension">README</a>にまとまっています。この拡張機能のうれしさは、</p>

<ol>
<li>Docker EngineのStable最新版をインストールしてくれる</li>
<li>Docker デーモンの起動オプションや認証まわりを設定できる (オプション)

<ul>
<li>ポートマッピング、認証まわり、Docker Registoryサーバの定義など</li>
</ul></li>
<li>Docker Composeのパラメータを渡すことができる (オプション)</li>
</ol>

<p>以上です。2と3はJSONで記述できます。要するに、毎度山ほどオプションつけてdockerコマンド打つよりは、宣言的にDockerを楽に使えますよ、ということです。必須ではありません。また、山ほどあるDockerのオプションを隅々まで網羅しているわけではありません。カバー範囲は基本的なところです。</p>

<p>Dockerの環境構築、はじめはコマンドを打つことをおすすめします。オプションがいろいろあるので、その中身を理解することには意味があります。</p>

<p>ですが、一度理解したあとは、かったるいことこの上ないので、この手のツールはあったほうがいいですね。</p>

<p>Dockerは本家のみならずエコシステムも急激に変化しているので、まだ環境構築ツールのファイナルアンサーはないでしょう。どれを学ぶか悩ましいところです。ですが、この拡張は気軽に使えますし、依存性も低いので、おすすめです。</p>

<p>なお、このDocker拡張、ARM属性で言うpublisherは&rdquo;Microsoft.Azure.Extensions&rdquo;ですが、古い&rdquo;MSOpenTech.Extensions&rdquo;を指定しているARMテンプレートがまだあったりします。拡張のインストール時に「そんなのねぇよ」と怒られたら、疑ってみてください。伝統を重んじるUSのリージョンでは動いて、Japanで動かないテンプレートでは、MSOpenTechが指定されているかもしれません。</p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
