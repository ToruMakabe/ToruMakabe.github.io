<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>re-imagine</title>
    <link>http://torumakabe.github.io/tags/functions/index.xml</link>
    <description>Recent content on re-imagine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://torumakabe.github.io/tags/functions/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Azure Event GridでBlobイベントを拾う</title>
      <link>http://torumakabe.github.io/post/azure_blobevent/</link>
      <pubDate>Tue, 05 Sep 2017 12:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_blobevent/</guid>
      <description>

&lt;h2 id=&#34;event-gridがblobに対応&#34;&gt;Event GridがBlobに対応&lt;/h2&gt;

&lt;p&gt;Event GridがBlobのイベントを拾えるように&lt;a href=&#34;https://azure.microsoft.com/en-us/blog/announcing-azure-blob-storage-events-preview/&#34;&gt;なりました&lt;/a&gt;。まだ申請が必要なプライベートプレビュー段階ですが、使い勝手の良いサービスに育つ予感がします。このたび検証する機会があったので、共有を。&lt;/p&gt;

&lt;p&gt;プレビュー中なので、今後仕様が変わるかもしれないこと、不具合やメンテナンス作業の可能性などは、ご承知おきください。&lt;/p&gt;

&lt;h2 id=&#34;event-gridがblobに対応して何がうれしいか&#34;&gt;Event GridがBlobに対応して何がうれしいか&lt;/h2&gt;

&lt;p&gt;Event Gridは、Azureで発生した様々なイベントを検知してWebhookで通知するサービスです。カスタムトピックも作成できます。&lt;/p&gt;

&lt;p&gt;イベントの発生元をPublisherと呼びますが、このたびPublisherとしてAzureのBlobがサポートされました。Blobの作成、削除イベントを検知し、Event GridがWebhookで通知します。通知先はHandlerと呼びます。Publisherとそこで拾うイベント、Handlerを紐づけるのがSubscriptionです。Subscriptionにはフィルタも定義できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ff3644c9-58ab-4729-8939-66a83ab0605d.png&#34; alt=&#34;コンセプト&#34; title=&#34;Concept&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Event Gridに期待する理由はいくつかあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;フィルタ

&lt;ul&gt;
&lt;li&gt;特定のBlobコンテナーにあるjpegファイルの作成イベントのみで発火させる、なんてことができます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;信頼性

&lt;ul&gt;
&lt;li&gt;リトライ機能があるので、Handlerが一時的に黙ってしまっても対応できます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;スケールと高スループット

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/azure-functions/functions-bindings-storage-blob#blob-storage-triggers-and-bindings&#34;&gt;Azure Functions Blobトリガー&lt;/a&gt;のようにHandler側で定期的にスキャンする必要がありません。これまではファイル数が多いとつらかった&lt;/li&gt;
&lt;li&gt;具体的な数値はプレビュー後に期待しましょう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ファンアウト

&lt;ul&gt;
&lt;li&gt;ひとつのイベントを複数のHandlerに紐づけられます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Azureの外やサードパーティーとの連携

&lt;ul&gt;
&lt;li&gt;Webhookでシンプルにできます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前提条件&#34;&gt;前提条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Publisherに設定できるストレージアカウントはBlobストレージアカウントのみです。汎用ストレージアカウントは対応していません&lt;/li&gt;
&lt;li&gt;現時点ではWest Central USリージョンのみで提供しています&lt;/li&gt;
&lt;li&gt;プライベートプレビューは申請が必要です&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Azure CLIの下記コマンドでプレビューに申請できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;az provider register --namespace  Microsoft.EventGrid
az feature register --name storageEventSubscriptions --namespace Microsoft.EventGrid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドで確認し、statusが&amp;rdquo;Registered&amp;rdquo;であれば使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;az feature show --name storageEventSubscriptions --namespace Microsoft.EventGrid
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;ストレージアカウントの作成からSubscription作成までの流れを追ってみましょう。&lt;/p&gt;

&lt;p&gt;リソースグループを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az group create -n blobeventpoc-rg -l westcentralus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Blobストレージアカウントを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az storage account create -n blobeventpoc01 -l westcentralus -g blobeventpoc-rg --sku Standard_LRS --kind BlobStorage --access-tier Hot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではいよいよEvent GridのSubscriptionを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az eventgrid resource event-subscription create --endpoint https://requestb.in/y4jgj2x0 -n blobeventpocsub-jpg --prov
ider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types Microsoft.Storage.BlobCreated
-g blobeventpoc-rg --resource-name blobeventpoc01 --subject-ends-with jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下はパラメーターの補足です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;endpoint

&lt;ul&gt;
&lt;li&gt;Handlerのエンドポイントを指定します。ここではテストのために&lt;a href=&#34;https://requestb.in/&#34;&gt;RequestBin&lt;/a&gt;に作ったエンドポイントを指定します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&amp;ndash;included-event-types

&lt;ul&gt;
&lt;li&gt;イベントの種類をフィルタします。Blobの削除イベントは不要で、作成のみ拾いたいため、Microsoft.Storage.BlobCreatedを指定します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&amp;ndash;subject-ends-with

&lt;ul&gt;
&lt;li&gt;対象ファイルをフィルタします。Blob名の末尾文字列がjpgであるBlobのみイベントの対象にしました&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では作成したストレージアカウントにBlobコンテナーを作成し、jpgファイルを置いてみましょう。テストには&lt;a href=&#34;https://azure.microsoft.com/ja-jp/features/storage-explorer/&#34;&gt;Azure Storage Explorer&lt;/a&gt;が便利です。&lt;/p&gt;

&lt;p&gt;RequestBinにWebhookが飛び、中身を見られます。スキーマの確認は&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-event-overview#event-schema&#34;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
  &amp;quot;topic&amp;quot;: &amp;quot;/subscriptions/xxxxx-xxxxx-xxxxx-xxxxx/resourceGroups/blobeventpoc-rg/providers/Microsoft.Storage/storageAccounts/blobeventpoc01&amp;quot;,
  &amp;quot;subject&amp;quot;: &amp;quot;/blobServices/default/containers/images/blobs/handsomeyoungman.jpg&amp;quot;,
  &amp;quot;eventType&amp;quot;: &amp;quot;Microsoft.Storage.BlobCreated&amp;quot;,
  &amp;quot;eventTime&amp;quot;: &amp;quot;2017-09-02T02:25:15.2635962Z&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;f3ff6b96-001e-001d-6e92-23bdea0684d2&amp;quot;,
  &amp;quot;data&amp;quot;: {
    &amp;quot;api&amp;quot;: &amp;quot;PutBlob&amp;quot;,
    &amp;quot;clientRequestId&amp;quot;: &amp;quot;f3cab560-8f85-11e7-bad1-53b58c70ab53&amp;quot;,
    &amp;quot;requestId&amp;quot;: &amp;quot;f3ff6b96-001e-001d-6e92-23bdea000000&amp;quot;,
    &amp;quot;eTag&amp;quot;: &amp;quot;0x8D4F1A9D8A6703A&amp;quot;,
    &amp;quot;contentType&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
    &amp;quot;contentLength&amp;quot;: 42497,
    &amp;quot;blobType&amp;quot;: &amp;quot;BlockBlob&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://blobeventpoc01.blob.core.windows.net/images/handsomeyoungman.jpg&amp;quot;,
    &amp;quot;sequencer&amp;quot;: &amp;quot;0000000000000BAB0000000000060986&amp;quot;,
    &amp;quot;storageDiagnostics&amp;quot;: {
      &amp;quot;batchId&amp;quot;: &amp;quot;f3a538cf-5b88-4bbf-908a-20a37c65e238&amp;quot;
    }
  }
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.jpgだけじゃなくて.jpegも使われるかもしれませんね。ということで、エンドポイントが同じでフィルタ定義を変えたSubscriptionを追加します。&amp;ndash;subject-ends-withをjpegとします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az eventgrid resource event-subscription create --endpoint https://requestb.in/y0jbj1y0 -n blobeventpocsub-jpeg --pro
vider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types Microsoft.Storage.BlobCreated -
g blobeventpoc-rg --resource-name blobeventpoc01 --subject-ends-with jpeg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、拡張子.jpegのファイルをアップロードしても発火しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
  &amp;quot;topic&amp;quot;: &amp;quot;/subscriptions/xxxxx-xxxxx-xxxxx-xxxxx/resourceGroups/blobeventpoc-rg/providers/Microsoft.Storage/storageAccounts/blobeventpoc01&amp;quot;,
  &amp;quot;subject&amp;quot;: &amp;quot;/blobServices/default/containers/images/blobs/handsomeyoungman.jpeg&amp;quot;,
  &amp;quot;eventType&amp;quot;: &amp;quot;Microsoft.Storage.BlobCreated&amp;quot;,
  &amp;quot;eventTime&amp;quot;: &amp;quot;2017-09-02T02:36:33.827967Z&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;e8b036ee-001e-00e7-4994-23740d06225b&amp;quot;,
  &amp;quot;data&amp;quot;: {
    &amp;quot;api&amp;quot;: &amp;quot;PutBlob&amp;quot;,
    &amp;quot;clientRequestId&amp;quot;: &amp;quot;883ff7e0-8f87-11e7-bad1-53b58c70ab53&amp;quot;,
    &amp;quot;requestId&amp;quot;: &amp;quot;e8b036ee-001e-00e7-4994-23740d000000&amp;quot;,
    &amp;quot;eTag&amp;quot;: &amp;quot;0x8D4F1AB6D1B24F6&amp;quot;,
    &amp;quot;contentType&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
    &amp;quot;contentLength&amp;quot;: 42497,
    &amp;quot;blobType&amp;quot;: &amp;quot;BlockBlob&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://blobeventpoc01.blob.core.windows.net/images/handsomeyoungman.jpeg&amp;quot;,
    &amp;quot;sequencer&amp;quot;: &amp;quot;0000000000000BAB0000000000060D42&amp;quot;,
    &amp;quot;storageDiagnostics&amp;quot;: {
      &amp;quot;batchId&amp;quot;: &amp;quot;9ec5c091-061d-4111-ad82-52d9803ce373&amp;quot;
    }
  }
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;azure-functionsに画像リサイズファンクションを作って連携してみる&#34;&gt;Azure Functionsに画像リサイズファンクションを作って連携してみる&lt;/h2&gt;

&lt;p&gt;Gvent Grid側の動きが確認できたので、サンプルアプリを作って検証してみましょう。Azure Functions上に画像ファイルのサイズを変えるHandlerアプリを作ってみます。&lt;/p&gt;

&lt;h3 id=&#34;概要&#34;&gt;概要&lt;/h3&gt;

&lt;p&gt;当初想定したのは、ひとつのファンクションで、トリガーはEventGrid、入出力バインドにBlob、という作りでした。ですが、以下のように設計を変えました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ToruMakabe/Images/master/blobevent-function-bindings.png&#34; alt=&#34;Bindings&#34; title=&#34;Bindings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using &lt;a href=&#34;https://functions-visualizer.azurewebsites.net/&#34;&gt;Azure Functions Bindings Visualizer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;その理由はEvent Grid Blobイベントのペイロードです。Blobファイル名がURLで渡されます。Azure FunctionsのBlob入出力バインド属性、&amp;rdquo;path&amp;rdquo;にURLは使えません。使えるのはコンテナー名+ファイル名です。&lt;/p&gt;

&lt;p&gt;入出力バインドを使わず、アプリのロジック内でStorage SDKを使って入出力してもいいのですが、Azure Functionsの魅力のひとつは宣言的にトリガーとバインドを定義し、アプリをシンプルに書けることなので、あまりやりたくないです。&lt;/p&gt;

&lt;p&gt;そこでイベントを受けてファイル名を取り出してQueueに入れるファンクションと、そのQueueをトリガーに画像をリサイズするファンクションに分けました。&lt;/p&gt;

&lt;p&gt;なお、この悩みはAzureの開発チームも認識しており、Functions側で対応する方針とのことです。&lt;/p&gt;

&lt;h3 id=&#34;handler&#34;&gt;Handler&lt;/h3&gt;

&lt;p&gt;C#(csx)で、Event GridからのWebhookを受けるHandlerを作ります。PublisherがBlobの場合、ペイロードにBlobのURLが入っていますので、そこからファイル名を抽出します。そして、そのファイル名をQueueに送ります。ファンクション名はBlobEventHandlerとしました。&lt;/p&gt;

&lt;p&gt;[run.csx]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#r &amp;quot;Newtonsoft.json&amp;quot;
using Microsoft.Azure.WebJobs.Extensions.EventGrid;

public static void Run(EventGridEvent eventGridEvent, out string outputQueueItem, TraceWriter log)
{
    string imageUrl = eventGridEvent.Data[&amp;quot;url&amp;quot;].ToString();
    outputQueueItem = System.IO.Path.GetFileName(imageUrl);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Event GridのWebJobs拡張向けパッケージを指定します。&lt;/p&gt;

&lt;p&gt;[project.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&amp;quot;frameworks&amp;quot;: {
  &amp;quot;net46&amp;quot;:{
    &amp;quot;dependencies&amp;quot;: {
      &amp;quot;Microsoft.Azure.WebJobs.Extensions.EventGrid&amp;quot;: &amp;quot;1.0.0-beta1-10006&amp;quot;
    }
  }
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トリガーとバインドは以下の通りです。&lt;/p&gt;

&lt;p&gt;[function.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;bindings&amp;quot;: [
    {
      &amp;quot;type&amp;quot;: &amp;quot;eventGridTrigger&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;eventGridEvent&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;in&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;queue&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;outputQueueItem&amp;quot;,
      &amp;quot;queueName&amp;quot;: &amp;quot;imagefilename&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;AzureWebJobsStorage&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;out&amp;quot;
    }
  ],
  &amp;quot;disabled&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resizer&#34;&gt;Resizer&lt;/h3&gt;

&lt;p&gt;Queueをトリガーに、Blobから画像ファイルを取り出し、縮小、出力するファンクションを作ります。ファンクション名はResizerとしました。&lt;/p&gt;

&lt;p&gt;[run.csx]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using ImageResizer;

public static void Run(string myQueueItem, Stream inputBlob, Stream outputBlob, TraceWriter log)
{
  var imageBuilder = ImageResizer.ImageBuilder.Current;
  var size = imageDimensionsTable[ImageSize.Small];

  imageBuilder.Build(inputBlob, outputBlob,
    new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);

}

public enum ImageSize
{
  Small
}

private static Dictionary&amp;lt;ImageSize, Tuple&amp;lt;int, int&amp;gt;&amp;gt; imageDimensionsTable = new Dictionary&amp;lt;ImageSize, Tuple&amp;lt;int, int&amp;gt;&amp;gt;()
{
  { ImageSize.Small, Tuple.Create(100, 100) }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImageResizerのパッケージを指定します。&lt;/p&gt;

&lt;p&gt;[project.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&amp;quot;frameworks&amp;quot;: {
  &amp;quot;net46&amp;quot;:{
    &amp;quot;dependencies&amp;quot;: {
      &amp;quot;ImageResizer&amp;quot;: &amp;quot;4.1.9&amp;quot;
    }
  }
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トリガーとバインドは以下の通りです。{QueueTrigger}メタデータで、QueueのペイロードをBlobのpathに使います。ペイロードにはファイル名が入っています。&lt;/p&gt;

&lt;p&gt;また、画像を保存するBlobストレージアカウントの接続文字列は、環境変数BLOB_IMAGESへ事前に設定しています。なお、リサイズ後の画像を格納するBlobコンテナーは、&amp;rdquo;images-s&amp;rdquo;として別途作成しました。コンテナー&amp;rdquo;images&amp;rdquo;をイベントの発火対象コンテナーとして、Subscriptionにフィルタを定義したいからです。&lt;/p&gt;

&lt;p&gt;[function.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;bindings&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;myQueueItem&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;queueTrigger&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;in&amp;quot;,
      &amp;quot;queueName&amp;quot;: &amp;quot;imagefilename&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;AzureWebJobsStorage&amp;quot;
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;inputBlob&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;blob&amp;quot;,
      &amp;quot;path&amp;quot;: &amp;quot;images/{QueueTrigger}&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;BLOB_IMAGES&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;in&amp;quot;
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;outputBlob&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;blob&amp;quot;,
      &amp;quot;path&amp;quot;: &amp;quot;images-s/{QueueTrigger}&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;BLOB_IMAGES&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;out&amp;quot;
    }
  ],
  &amp;quot;disabled&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handlerの準備が整いました。最後にEvent GridのSubscriptionを作成します。Azure FunctionsのBlobEventHandlerのトークン付きエンドポイントは、ポータルの[統合]で確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az eventgrid resource event-subscription create --endpoint &amp;quot;https://blobeventpoc.azurewebsites.net/admin/exte
nsions/EventGridExtensionConfig?functionName=BlobEventHandler&amp;amp;code=tokenTOKEN1234567890==&amp;quot; -n blobeventpocsub-jpg --provider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types &amp;quot;Microsoft.Storage.BlobCreated&amp;quot; -g blobeventpoc-rg --resource-name blobeventpoc01 --subject-begins-with &amp;quot;/blobServices/default/containers/images/&amp;quot;  --subject-ends-with jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、コンテナー&amp;rdquo;images&amp;rdquo;にjpgファイルがアップロードされると、コンテナー&amp;rdquo;images-s&amp;rdquo;に、リサイズされた同じファイル名の画像ファイルが出来上がります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SlackとAzure FunctionsでChatOpsする</title>
      <link>http://torumakabe.github.io/post/azure_chatops_onfunctions/</link>
      <pubDate>Fri, 07 Oct 2016 17:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_chatops_onfunctions/</guid>
      <description>

&lt;h2 id=&#34;azure-functionsでやってみよう&#34;&gt;Azure Functionsでやってみよう&lt;/h2&gt;

&lt;p&gt;Azure上でChatOpsしたい、と相談をいただきました。&lt;/p&gt;

&lt;p&gt;AzureでChatOpsと言えば、Auth0のSandrino Di Mattia氏が作った素敵な&lt;a href=&#34;http://fabriccontroller.net/chatops-deploy-and-manage-complete-environments-on-azure-using-slack/&#34;&gt;サンプル&lt;/a&gt;があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fabriccontroller.net/static/chatops-how-this-works.png.pagespeed.ce.lN444drUKd.png&#34; alt=&#34;Azure Runスラッシュ&#34; title=&#34;from fabriccontroller.net&#34; /&gt;&lt;/p&gt;

&lt;p&gt;素晴らしい。これで十分、という気もしますが、実装のバリエーションがあったほうが後々参考になる人も多いかなと思い、Web App/Web JobをAzure Functionsで置き換えてみました。&lt;/p&gt;

&lt;h2 id=&#34;slackからrunbookを実行できて-何がうれしいか&#34;&gt;SlackからRunbookを実行できて、何がうれしいか&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;誰がいつ、どんな文脈でRunbookを実行したかを可視化する&lt;/li&gt;
&lt;li&gt;CLIやAPIをRunbookで隠蔽し、おぼえることを減らす&lt;/li&gt;
&lt;li&gt;CLIやAPIをRunbookで隠蔽し、できることを制限する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ブツ&#34;&gt;ブツ&lt;/h2&gt;

&lt;p&gt;Githubに上げておきました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ToruMakabe/AZChatOpsSample&#34;&gt;AZChatOpsSample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;おおまかな流れ&#34;&gt;おおまかな流れ&lt;/h2&gt;

&lt;p&gt;手順書つらいのでポイントだけ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SlackのSlash CommandとIncoming Webhookを作る&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;流れは氏の&lt;a href=&#34;http://fabriccontroller.net/chatops-deploy-and-manage-complete-environments-on-azure-using-slack/&#34;&gt;元ネタ&lt;/a&gt;と同じ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ARM TemplateでFunction Appをデプロイ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Github上のDeployボタンからでもいいですが、パラメータファイルを作っておけばCLIで楽に繰り返せます&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;パラメータファイルのサンプルは&lt;a href=&#34;https://github.com/ToruMakabe/AZChatOpsSample/blob/master/sample.azuredeploy.parameters.json&#34;&gt;sample.azuredeploy.parameters.json&lt;/a&gt;です。GUIでデプロイするにしても、パラメータの意味を理解するためにざっと読むと幸せになれると思います&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function AppのデプロイはGithubからのCIです。クローンしたリポジトリとブランチを指定してください&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GithubからのCIは、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/app-service-deploy-complex-application-predictably/&#34;&gt;はじめてのケースを考慮し&lt;/a&gt;ARM Templateのリソースプロパティ&amp;rdquo;IsManualIntegration&amp;rdquo;をtrueにしています&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure Automationのジョブ実行権限を持つサービスプリンシパルが必要です (パラメータ SUBSCRIPTION_ID、TENANT_ID、CLIENT_ID、CLIENT_SECRET で指定)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure Automationについて詳しく説明しませんが、Slackから呼び出すRunbookを準備しておいてください。そのAutomationアカウントと所属するリソースグループを指定します&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作成済みのSlack関連パラメータを指定します&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ARM Templateデプロイ後にkuduのデプロイメントスクリプトが走るので、しばし待つ(Function Appの設定-&amp;gt;継続的インテグレーションの構成から進捗が見えます)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;デプロイ後、Slash Commandで呼び出すhttptrigger function(postJob)のtokenを変更&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kuduでdata/Functions/secrets/postJob.jsonの値を、Slackが生成したSlash Commandのtokenに書き換え&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slack上で、Slash Commandのリクエスト先URLを変更 (例: &lt;a href=&#34;https://yourchatops.azurewebsites.net/api/postJob?code=TokenTokenToken&#34;&gt;https://yourchatops.azurewebsites.net/api/postJob?code=TokenTokenToken&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファンクションが動いたら、Slackの指定チャンネルでSlash Commandが打てるようになる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/runbook [runbook名] [parm1] [parm2] [parm&amp;hellip;]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;パラメータはrunbook次第&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runbookの進捗はIncoming Webhookでslackに通知される&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Runbookのステータスが変わったときに通知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;よもやま話&#34;&gt;よもやま話&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SlackのSlash Commandは、3秒以内に返事を返さないとタイムアウトします。なのでいくつか工夫しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ファンクションはトリガーされるまで寝ています。また、5分間動きがないとこれまた寝ます(cold状態になる)。寝た子を起こすのには時間がかかるので、Slackの3秒ルールに間に合わない可能性があります。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure FunctionsのWebコンソールログが無活動だと30分で停止するので、coldに入る条件も30分と誤解していたのですが、正しくは5分。ソースは&lt;a href=&#34;https://github.com/Azure/azure-webjobs-sdk-script/issues/529&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;そこで、4分周期でTimer Triggerし、postJobにダミーPOSTするpingFuncを作りました。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファンクションのコードに更新があった場合、リロード処理が走ります。リロード後、またしてもトリガーを待って寝てしまうので、コード変更直後にSlash Commandを打つとタイムアウトする可能性大です。あせらずpingまで待ちましょう。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;でもAzure AutomationのAPI応答待ちなど、外部要因で3秒超えちゃう可能性はあります。非同期にしてひとまずSlackに応答返す作りに変えたほうがいいですね。これはSlackのSlash Commandに限らず、呼び出し元に待ってもらえないケース全てに言える考慮点です。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure Functionsはまだプレビューなので、&lt;a href=&#34;https://github.com/Azure/azure-webjobs-sdk-script/issues/529&#34;&gt;議論されているとおり&lt;/a&gt;改善の余地が多くあります。期待しましょう。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Azure Functionsで運用管理サーバレス生活(使用量データ取得編)</title>
      <link>http://torumakabe.github.io/post/azurefunctions_getusagedata/</link>
      <pubDate>Tue, 13 Sep 2016 17:30:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azurefunctions_getusagedata/</guid>
      <description>

&lt;h2 id=&#34;背景と動機&#34;&gt;背景と動機&lt;/h2&gt;

&lt;p&gt;Azure Functions使ってますか。「サーバレス」という、ネーミングに突っ込みたい衝動を抑えられないカテゴリに属するため損をしている気もしますが、システムのつくり方を変える可能性がある、潜在能力高めなヤツです。キャッチアップして損はないです。&lt;/p&gt;

&lt;p&gt;さて、Azure Functionsを使ってAzureの使用量データを取得、蓄積したいというリクエストを最近いくつかいただきました。いい機会なのでまとめておきます。以下、その背景。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;運用管理業務がビジネスの差別化要素であるユーザは少ない。可能な限り省力化したい。運用管理ソフトの導入維持はもちろん、その土台になるサーバの導入、維持は真っ先に無くしたいオーバヘッド。もうパッチ当てとか監視システムの監視とか、やりたくない。&lt;/li&gt;
&lt;li&gt;Azure自身が持つ運用管理の機能が充実し、また、運用管理SaaS(&lt;a href=&#34;https://www.microsoft.com/ja-jp/server-cloud/products-operations-management-suite.aspx&#34;&gt;MS OMS&lt;/a&gt;、New Relic、Datadogなど)が魅力的になっており、使い始めている。いつかは運用管理サーバを無くしたい。&lt;/li&gt;
&lt;li&gt;でも、それら標準的なサービスでカバーされていない、ちょっとした機能が欲しいことがある。&lt;/li&gt;
&lt;li&gt;Azureリソースの使用量データ取得が一例。Azureでは使用量データを&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/billing-understand-your-bill/&#34;&gt;ポータルからダウンロード&lt;/a&gt;したり、&lt;a href=&#34;https://powerbi.microsoft.com/ja-jp/documentation/powerbi-content-pack-azure-enterprise/&#34;&gt;Power BIで分析&lt;/a&gt;できたりするが、元データは自分でコントロールできるようためておきたい。もちろん手作業なし、自動で。&lt;/li&gt;
&lt;li&gt;ちょっとしたコードを気軽に動かせる仕組みがあるなら、使いたい。インフラエンジニアがさくっと書くレベルで。&lt;/li&gt;
&lt;li&gt;それAzure Functionsで出来るよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方針&#34;&gt;方針&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Azure FunctionsのTimer Triggerを使って、日次で実行&lt;/li&gt;
&lt;li&gt;Azure Resource Usage APIを使って使用量を取得し、ファイルに書き込み&lt;/li&gt;
&lt;li&gt;Nodeで書く (C#のサンプルはたくさんあるので)&lt;/li&gt;
&lt;li&gt;業務、チームでの運用を考慮して、ブラウザでコード書かずにソース管理ツールと繋げる (Githubを使う)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick Start&lt;/h2&gt;

&lt;h3 id=&#34;準備&#34;&gt;準備&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ところでAzure Funtionsって何よ、って人はまず&lt;a href=&#34;https://blogs.technet.microsoft.com/azure-sa-members/azurefunctions/&#34;&gt;いい資料1&lt;/a&gt;と&lt;a href=&#34;https://buchizo.wordpress.com/2016/06/04/azure-functions-overview-and-under-the-hood/&#34;&gt;いい資料2&lt;/a&gt;でざっと把握を&lt;/li&gt;
&lt;li&gt;AzureのAPIにプログラムからアクセスするため、サービスプリンシパルを作成 (&lt;a href=&#34;https://doc.co/66mYfB&#34;&gt;ここ&lt;/a&gt;とか&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/resource-group-authenticate-service-principal/&#34;&gt;ここ&lt;/a&gt;を参考に)

&lt;ul&gt;
&lt;li&gt;後ほど環境変数に設定するので、Domain(Tenant ID)、Client ID(App ID)、Client Secret(Password)、Subscription IDを控えておいてください&lt;/li&gt;
&lt;li&gt;権限はsubscriptionに対するreaderが妥当でしょう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Githubのリポジトリを作成 (VSTSやBitbucketも使えます)&lt;/li&gt;
&lt;li&gt;使用量データを貯めるストレージアカウントを作成

&lt;ul&gt;
&lt;li&gt;後ほど環境変数に設定するので、接続文字列を控えておいてください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;デプロイ&#34;&gt;デプロイ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Function Appを作成

&lt;ul&gt;
&lt;li&gt;ポータル左上&amp;rdquo;+新規&amp;rdquo; -&amp;gt; Web + モバイル -&amp;gt; Function App&lt;/li&gt;
&lt;li&gt;アプリ名は.azurewebsites.net空間でユニークになるように&lt;/li&gt;
&lt;li&gt;App Seriviceプランは、占有型の&amp;rdquo;クラシック&amp;rdquo;か、共有で実行したぶん課金の&amp;rdquo;動的&amp;rdquo;かを選べます。今回の使い方だと動的がお得でしょう&lt;/li&gt;
&lt;li&gt;メモリは128MBあれば十分です&lt;/li&gt;
&lt;li&gt;他のパラメータはお好みで&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;環境変数の設定

&lt;ul&gt;
&lt;li&gt;Function Appへポータルからアクセス -&amp;gt; Function Appの設定 -&amp;gt; アプリケーション設定の構成 -&amp;gt; アプリ設定&lt;/li&gt;
&lt;li&gt;先ほど控えた環境変数を設定します(CLIENT_ID、DOMAIN、APPLICATION_SECRET、AZURE_SUBSCRIPTION_ID、azfuncpoc_STORAGE)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードを取得

&lt;ul&gt;
&lt;li&gt;githubに置いてますので、作業するマシンにcloneしてください -&amp;gt; &lt;a href=&#34;https://github.com/ToruMakabe/AZFuncTimerTriggerSample&#34;&gt;AZFuncTimerTriggerSample&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;準備済みのGithubリポジトリにpush&lt;/li&gt;
&lt;li&gt;リポジトリとFunction Appを同期

&lt;ul&gt;
&lt;li&gt;Function Appへポータルからアクセス -&amp;gt; Function Appの設定 -&amp;gt; 継続的インテグレーションの構成 -&amp;gt; セットアップ&lt;/li&gt;
&lt;li&gt;Githubリポジトリとブランチを設定し、同期を待ちます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Nodeのモジュールをインストール

&lt;ul&gt;
&lt;li&gt;&lt;del&gt;Function Appへポータルからアクセス -&amp;gt; Function Appの設定 -&amp;gt; kuduに移動 -&amp;gt; site/wwwroot/getUsageData へ移動&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;このディレクトリが、実行する関数、functionの単位です&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&amp;ldquo;npm install&amp;rdquo; を実行 (package.jsonの定義に従ってNodeのモジュールが”node_modules&amp;rdquo;へインストールされます)&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;deploy.cmd で自動的にインストールするよう変えました&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これで、指定ストレージアカウントの&amp;rdquo;usagedata&amp;rdquo;コンテナに日次で使用量データファイルができます。&lt;/p&gt;

&lt;h2 id=&#34;コード解説&#34;&gt;コード解説&lt;/h2&gt;

&lt;p&gt;3つのファイルをデプロイしました。簡単な順に、ざっと解説します。&lt;a href=&#34;https://github.com/ToruMakabe/AZFuncTimerTriggerSample&#34;&gt;コード&lt;/a&gt;を眺めながら読み進めてください。&lt;/p&gt;

&lt;h3 id=&#34;package-json&#34;&gt;package.json&lt;/h3&gt;

&lt;p&gt;主となるコードファイルは後述の&amp;rdquo;index.js&amp;rdquo;ですが、その動作に必要な環境を定義します。依存モジュールのバージョンの違いでトラブらないよう、dependenciesで指定するところがクライマックスです。&lt;/p&gt;

&lt;h3 id=&#34;function-json&#34;&gt;function.json&lt;/h3&gt;

&lt;p&gt;Azure Functionsの特徴である、TriggerとBindingsを定義します。サンプルはTimer Triggerなので、実行タイミングをここに書きます。&amp;rdquo;schedule&amp;rdquo;属性に、cron形式({秒}{分}{時}{日}{月}{曜日})で。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;0 0 0 * * *&amp;rdquo; と指定しているので、毎日0時0分0秒に起動します。UTCです。&lt;/p&gt;

&lt;h3 id=&#34;index-js&#34;&gt;index.js&lt;/h3&gt;

&lt;p&gt;メインロジックです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先ほど設定した環境変数は、&amp;rdquo;process.env.HOGE&amp;rdquo;を通じ実行時に読み込まれます。認証関連情報はハードコードせず、このやり口で。&lt;/li&gt;
&lt;li&gt;日付関連処理はUTCの明示を徹底しています。Azure Functions実行環境はUTCですが、ローカルでのテストなど他環境を考えると、指定できるところはしておくのがおすすめです。これはクラウドでグローバル展開する可能性があるコードすべてに言えます。&lt;/li&gt;
&lt;li&gt;0時に起動しますが、使用量データ作成遅延の可能性があるので、処理対象は2日前です。お好みで調整してください。詳細仕様は&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/azure/mt219001.aspx&#34;&gt;こちら&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;module.export からが主フローです。asyncを使って、Blobコンテナの作成、使用量データ取得&amp;amp;ファイル書き込みを、順次処理しています。後ほど豆知識で補足します。&lt;/li&gt;
&lt;li&gt;最後にcontext.done()でFunctionsに対してアプリの終了を伝えます。黙って終わるような行儀の悪い子は嫌いです。&lt;/li&gt;
&lt;li&gt;ヘルパー関数たちは最後にまとめてあります。ポイントはcontinuationTokenを使ったループ処理です。

&lt;ul&gt;
&lt;li&gt;Resource Usage API は、レスポンスで返すデータが多い場合に、途中で切って「次はこのトークンで続きからアクセスしてちょ」という動きをします。&lt;/li&gt;
&lt;li&gt;ループが2周目に入った場合は、データを書きだすファイルが分かれます。フォーマットは&amp;rdquo;YYYY-MM-DD_n.json&amp;rdquo;です。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;豆知識-node-on-azure-functions&#34;&gt;豆知識 (Node on Azure Functions)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通信やI/Oの関数など、非同期処理の拾い忘れ、突き抜けに注意してください

&lt;ul&gt;
&lt;li&gt;NodeはJavascript、シングルスレッドなので時間のかかる処理でブロックしないのが基本です&lt;/li&gt;
&lt;li&gt;Azure FunctionsはNode v6.4.0が使えるのでES6のpromiseが書けるのですが、SDKがまだpromiseを&lt;a href=&#34;https://github.com/Azure/azure-sdk-for-node/issues/1450&#34;&gt;サポートしていない&lt;/a&gt;ので、サポートされるまではcallbackで堅く書きましょう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Nodeに限った話ではないですが、Azure Functions Timer TriggerはInput/Output Bindingと組み合わせられません

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/functions-reference/#-7&#34;&gt;サポートマトリックス&lt;/a&gt;を確認しましょう&lt;/li&gt;
&lt;li&gt;なのでサンプルではOutput Binding使わずに書きました&lt;/li&gt;
&lt;li&gt;Input/Outputを使える他のTriggerでは、楽なのでぜひ活用してください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;豆知識-azure-usage-api&#34;&gt;豆知識 (Azure Usage API)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Resource Usage APIは使用量のためのAPIなので、料金に紐づけたい場合は、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/billing-usage-rate-card-overview/&#34;&gt;Ratecard API&lt;/a&gt;を組み合わせてください&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;それでは、幸せな運用管理サーバレス生活を。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure FunctionsとFacebook Messenger APIで好みなんて聞いてないBotを作る</title>
      <link>http://torumakabe.github.io/post/azure_functions_fbmsgapi/</link>
      <pubDate>Sun, 08 May 2016 14:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_functions_fbmsgapi/</guid>
      <description>

&lt;h2 id=&#34;まだ好みなんて聞いてないぜ&#34;&gt;まだ好みなんて聞いてないぜ&lt;/h2&gt;

&lt;p&gt;Build 2016で、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/services/functions/&#34;&gt;Azure Functions&lt;/a&gt;が発表されました。&lt;/p&gt;

&lt;p&gt;Azure Functionsは、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;アプリを放り込めば動く。サーバの管理が要らない。サーバレス。  #でもこれは従来のPaaSもそう&lt;/li&gt;
&lt;li&gt;利用メモリ単位での、粒度の細かい課金。  #現在プレビュー中にて、詳細は今後発表&lt;/li&gt;
&lt;li&gt;Azure内外機能との、容易なイベント連動。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;が特徴です。AWSのLambdaと似てるっちゃ似ています。&lt;/p&gt;

&lt;p&gt;何が新しいかというと、特に3つ目の特徴、イベント連動です。触ってみなければわからん、ということで、流行りのBotでも作ってみたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;基本方針&#34;&gt;基本方針&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;FunctionsはAzure内の様々な機能と&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/functions-reference/#bindings&#34;&gt;イベント連動&lt;/a&gt;できるが、あえてサンプルの少ないAzure外とつないでみる&lt;/li&gt;
&lt;li&gt;Facebook Messenger APIを使って、webhook連動する&lt;/li&gt;
&lt;li&gt;Facebook Messenger向けに書き込みがあると、ランダムでビールの種類と参考URLを返す&lt;/li&gt;
&lt;li&gt;ビールは&lt;a href=&#34;http://beertaster.org/beerstyle/web/beerstyle_main_j.html&#34;&gt;Craft Beer Association&lt;/a&gt;の分類に従い、協会のビアスタイル・ガイドライン参考ページの該当URLを返す&lt;/li&gt;
&lt;li&gt;Botらしく、それらしい文末表現をランダムで返す&lt;/li&gt;
&lt;li&gt;好みとか文脈は全く聞かないぜSorry&lt;/li&gt;
&lt;li&gt;アプリはNodeで書く。C#のサンプルは増えてきたので&lt;/li&gt;
&lt;li&gt;静的データをランダムに返す、かつ少量なのでメモリ上に広げてもいいが、せっかくなのでNodeと相性のいいDocumentDBを使う&lt;/li&gt;
&lt;li&gt;DocumentDBではSQLでいうORDER BY RAND()のようなランダムな問い合わせを書けないため、ストアドプロシージャで実装する  #&lt;a href=&#34;https://gist.github.com/murdockcrc/12266f9d844be416a6a0&#34;&gt;サンプル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FunctionsとGithubを連携し、GithubへのPush -&amp;gt; Functionsへのデプロイというフローを作る&lt;/li&gt;
&lt;li&gt;拡張性はひとまず目をつぶる  #&lt;a href=&#34;http://qiita.com/yoichiro@github/items/6d4c7309210af20a5c8f&#34;&gt;この辺の話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ひとまずFunctionsとBotの枠組みの理解をゴールとします。ロジックをたくさん書けばそれなりに文脈を意識した返事はできるのですが、書かずに済む仕組みがこれからいろいろ出てきそうなので、書いたら負けの精神でぐっと堪えます。&lt;/p&gt;

&lt;h2 id=&#34;必要な作業&#34;&gt;必要な作業&lt;/h2&gt;

&lt;p&gt;以下が必要な作業の流れです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Azureで

&lt;ul&gt;
&lt;li&gt;Function Appの作成  #1&lt;/li&gt;
&lt;li&gt;Bot用Functionの作成 #2&lt;/li&gt;
&lt;li&gt;Facebook Messenger APIとの接続検証  #6&lt;/li&gt;
&lt;li&gt;Facebook Messenger API接続用Tokenの設定  #8&lt;/li&gt;
&lt;li&gt;DocumentDBのデータベース、コレクション作成、ドキュメント投入  #9&lt;/li&gt;
&lt;li&gt;DocumentDBのストアドプロシージャ作成  #10&lt;/li&gt;
&lt;li&gt;Function Appを書く  #11&lt;/li&gt;
&lt;li&gt;FunctionsのサイトにDocumentDB Node SDKを導入 #12&lt;/li&gt;
&lt;li&gt;Function AppのGithub連携設定  #13&lt;/li&gt;
&lt;li&gt;Function Appのデプロイ (GithubへのPush)  #14&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Facebookで

&lt;ul&gt;
&lt;li&gt;Facebook for Developersへの登録  #3&lt;/li&gt;
&lt;li&gt;Botをひも付けるFacebook Pageの作成  #4&lt;/li&gt;
&lt;li&gt;Bot用マイアプリの作成  #5&lt;/li&gt;
&lt;li&gt;Azure Functionsからのcallback URLを登録、接続検証  #6&lt;/li&gt;
&lt;li&gt;Azure Functions向けTokenを生成 #7&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アプリのコード書きの他はそれほど重くない作業ですが、すべての手順を書くと本ができそうです。Function Appの作りにポイントを絞りたいので、以下、参考になるサイトをご紹介します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function Appを書くまで、#1〜2、#5〜8は、&lt;a href=&#34;http://oauth.jp/blog/2016/04/19/fb-message-callback-with-azure-function/&#34;&gt;こちらのブログエントリ&lt;/a&gt;がとても参考になります。&lt;/li&gt;
&lt;li&gt;Facebook for Developersへの登録、#3は、&lt;a href=&#34;https://developers.facebook.com/&#34;&gt;https://developers.facebook.com/&lt;/a&gt; から。いきなり迷子の人は、&lt;a href=&#34;http://qiita.com/k_kuni/items/3d7176ee4e3009b45dd8&#34;&gt;こちら&lt;/a&gt;も参考に。&lt;/li&gt;
&lt;li&gt;Facebook Pageの作成は、&lt;a href=&#34;http://allabout.co.jp/gm/gc/387840/&#34;&gt;ここ&lt;/a&gt;を。Botで楽しむだけなら細かい設定は後回しでいいです。&lt;/li&gt;
&lt;li&gt;DocumentDBについては、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-introduction/&#34;&gt;公式&lt;/a&gt;を。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-create-account/&#34;&gt;DBアカウント〜コレクション作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-import-data/&#34;&gt;ドキュメントインポート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-programming/&#34;&gt;ストアドプロシージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;FunctionsのサイトにDocumentDB Node SDKを導入する#12は、&lt;a href=&#34;http://tech.guitarrapc.com/entry/2016/04/05/043723&#34;&gt;こちら&lt;/a&gt;を。コンソールからnpm installできます。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Github連携設定、#13〜14は、&lt;a href=&#34;http://tech.guitarrapc.com/entry/2016/04/03/051552&#34;&gt;こちら&lt;/a&gt;がとても参考になります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;function-appのサンプル&#34;&gt;Function Appのサンプル&lt;/h2&gt;

&lt;p&gt;Githubにソースを&lt;a href=&#34;https://github.com/ToruMakabe/MakabeerBot&#34;&gt;置いておきます&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちなみにこのディレクトリ階層はGithub連携を考慮し、Function Appサイトのそれと合わせています。以下がデプロイ後のサイト階層です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\home\site\wwwroot
├── fb-message-callback
│   ├── TestOutput.json
│   ├── function.json
│   └── index.js  #これが今回のアプリ
├── node_modules  #DocumentDB Node SDKが入っている
├── host.json
├── README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、DocumentDBのSDKパッケージは、なぜかfb-message-callbackローカルに置くと読み込まれないため、暫定的にルートへ配置しています。&lt;/p&gt;

&lt;p&gt;ではFunction Appの実体、index.jsを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var https = require(&#39;https&#39;);
var documentClient = require(&amp;quot;documentdb&amp;quot;).DocumentClient;
const databaseUrl = &amp;quot;dbs/&amp;quot; + process.env.APPSETTING_DOCDB_DB_ID;

var client = new documentClient(process.env.APPSETTING_DOCDB_ENDPOINT, { &amp;quot;masterKey&amp;quot;: process.env.APPSETTING_DOCDB_AUTHKEY });

function sendTextMessage(sender, text, context) {
  getDataFromDocDB().then(function (value) {
    var msgAll = value[0].randomDocument.beer + &amp;quot; &amp;quot; + value[1].randomDocument.msg;
    var postData = JSON.stringify({
      recipient: sender,
      message: {
        &amp;quot;attachment&amp;quot;:{
          &amp;quot;type&amp;quot;:&amp;quot;template&amp;quot;,
          &amp;quot;payload&amp;quot;:{
            &amp;quot;template_type&amp;quot;:&amp;quot;button&amp;quot;,
            &amp;quot;text&amp;quot;:msgAll,
            &amp;quot;buttons&amp;quot;:[
              {
                &amp;quot;type&amp;quot;:&amp;quot;web_url&amp;quot;,
                &amp;quot;url&amp;quot;:value[0].randomDocument.url,
                &amp;quot;title&amp;quot;:&amp;quot;詳しく&amp;quot;
              }
            ]
          }
        }
      }
    });
    var req = https.request({
      hostname: &#39;graph.facebook.com&#39;,
      port: 443,
      path: &#39;/v2.6/me/messages&#39;,
      method: &#39;POST&#39;,
      headers: {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;Authorization&#39;: &#39;Bearer &#39; + process.env.APPSETTING_FB_PAGE_TOKEN
      }
    });
    req.write(postData);
    req.end();
  }).catch(function(err){
    context.log(err);
  });  
}

function getRandomDoc(sprocUrl){
  return new Promise(function (resolve, reject) {
    const sprocParams = {};
    client.executeStoredProcedure(sprocUrl, sprocParams, function(err, result, responseHeaders) {
      if (err) {
        reject(err);
      }
      if (result) {
        resolve(result);
      }
    });
  });
}

var results = {
  beer: function getBeer() {
    var collectionUrl = databaseUrl + &amp;quot;/colls/beer&amp;quot;;
    var sprocUrl = collectionUrl + &amp;quot;/sprocs/GetRandomDoc&amp;quot;;
    return getRandomDoc(sprocUrl).then(function (result) {
      return result;
    });
  },
  eom: function getEom() {
    var collectionUrl = databaseUrl + &amp;quot;/colls/eom&amp;quot;;
    var sprocUrl = collectionUrl + &amp;quot;/sprocs/GetRandomDoc&amp;quot;;
    return getRandomDoc(sprocUrl).then(function (result) {
      return result;
    });
  }
}

function getDataFromDocDB() {
  return Promise.all([results.beer(), results.eom()]);
}

module.exports = function (context, req) {
  messaging_evts = req.body.entry[0].messaging;
  for (i = 0; i &amp;lt; messaging_evts.length; i++) {
    evt = req.body.entry[0].messaging[i];
    sender = evt.sender;
    if (evt.message &amp;amp;&amp;amp; evt.message.text, context) {
      sendTextMessage(sender, evt.message.text, context);
    }
  }
  context.done();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;最下部のmodule.export以降のブロックで、webhookイベントを受け取ります&lt;/li&gt;
&lt;li&gt;それがmessageイベントで、テキストが入っていれば、sendTextMessage関数を呼びます

&lt;ul&gt;
&lt;li&gt;好みは聞いてないので、以降、受け取ったテキストが読まれることはありませんが&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sendTextMessage関数内、getDataFromDocDB関数呼び出しでDocumentDBへ問い合わせてビールと文末表現をランダムに取り出します

&lt;ul&gt;
&lt;li&gt;コレクション&amp;rdquo;beer&amp;rdquo;、&amp;rdquo;eom(end of message)&amp;ldquo;の構造はそれぞれこんな感じ
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;url&amp;quot;: &amp;quot;http://beertaster.org/beerstyle/web/001A.html#japanese&amp;quot;,
  &amp;quot;beer&amp;quot;: &amp;quot;酵母なし、ライトアメリカン・ウィートビール&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;bf3636c5-4284-4e7a-b587-9002a771f214&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;msg&amp;quot;: &amp;quot;はウマい&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;acd63222-2138-4e19-894e-dc85a950be64&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DocumentDBの2つのコレクションへの問い合わせが終わった後、Facebookへメッセージを返すため、逐次処理目的でJavaScriptの&lt;a href=&#34;http://azu.github.io/promises-book/&#34;&gt;Promise&lt;/a&gt;を使っています&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いかがでしょう。好みを聞かない気まぐれBotとはいえ、気軽に作れることがわかりました。ゼロからこの手のイベント処理を作るの、面倒ですものね。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;なお、Facebook Messenger API連動アプリの外部公開には、審査が必要とのことです&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>