<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terraform &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.17" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Terraform &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Terraform &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">09 Apr 2018, 15:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/myazurecli201804/" class="post-title">俺のAzure CLI 2018春版</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="春の環境リフレッシュ祭り">春の環境リフレッシュ祭り</h2>

<p>最近KubernetesのCLI、kubectlを使う機会が多いのですが、なかなかイケてるんですよ。かゆい所に手が届く感じ。そこで、いい機会なのでAzure CLIまわりも最新の機能やツールで整えようか、というのが今回の動機。気づかないうちに、界隈が充実していた。</p>

<h2 id="俺のおすすめ-3選">俺のおすすめ 3選</h2>

<ul>
<li>デフォルト設定

<ul>
<li>リソースグループやロケーション、出力形式などのデフォルト設定ができる</li>
</ul></li>
<li>エイリアス

<ul>
<li>サブコマンドにエイリアスを付けられる</li>
<li>引数付きの込み入った表現もできる</li>
</ul></li>
<li>VS Code プラグイン

<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli">Azure CLI Toolsプラグイン</a> でazコマンドの編集をコードアシストしてくれる</li>
<li>編集画面上でコマンド選択して実行できる</li>
</ul></li>
</ul>

<h2 id="デフォルト設定">デフォルト設定</h2>

<p>$AZURE_CONFIG_DIR/configファイルで構成設定ができます。$AZURE_CONFIG_DIR の既定値は、Linux/macOS の場合$HOME/.azure、Windowsは%USERPROFILE%.azure。</p>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-configuration?view=azure-cli-latest">Azure CLI 2.0 の構成</a></p>

<p>まず変えたいところは、コマンドの出力形式。デフォルトはJSON。わたしのお気持ちは、普段はTable形式、掘りたい時だけJSON。なのでデフォルトをtableに変えます。</p>

<pre><code>[core]
output = table
</code></pre>

<p>そしてデフォルトのリソースグループを設定します。以前は「デフォルト設定すると、気づかないところで事故るから、やらない」という主義だったのですが、Kubernetesのdefault namespaceの扱いを見て「ああ、これもありかなぁ」と改宗したところ。</p>

<pre><code>[defaults]
group = default-ejp-rg
</code></pre>

<p>他にもロケーションやストレージアカウントなどを設定できます。ロケーションはリソースグループの属性を継承させたい、もしくは明示したい場合が多いので、設定していません。</p>

<p>ということで、急ぎUbuntuの仮想マシンが欲しいぜという場合、az vm createコマンドの必須パラメーター、-gと-lを省略できるようになったので、さくっと以下のコマンドでできるようになりました。</p>

<p>デフォルト指定したリソースグループを、任意のロケーションに作ってある前提です。</p>

<pre><code>az vm create -n yoursmplvm01 --image UbuntuLTS
</code></pre>

<h2 id="エイリアス">エイリアス</h2>

<p>$AZURE_CONFIG_DIR/aliasにエイリアスを書けます。</p>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest">Azure CLI 2.0 のエイリアス拡張機能</a></p>

<p>前提はAzure CLI v2.0.28以降です。以下のコマンドでエイリアス拡張を導入できます。現時点ではプレビュー扱いなのでご注意を。</p>

<pre><code>az extension add --name alias
</code></pre>

<p>ひとまずわたしは以下3カテゴリのエイリアスを登録しました。</p>

<h3 id="頻繁に打つからできる限り短くしたい系">頻繁に打つからできる限り短くしたい系</h3>

<pre><code>[ls]
command = list

[nw]
command = network

[pip]
command = public-ip

[fa]
command = functionapp
</code></pre>

<p>例えばデフォルトリソースグループでパブリックIP公開してるか確認したいな、と思った時は、az network public-ip listじゃなくて、こう打てます。</p>

<pre><code>$ az nw pip ls
Name                  ResourceGroup    Location    Zones    AddressVersion    AllocationMethod      IdleTimeoutInMinutes
ProvisioningState
--------------------  ---------------  ----------  -------  ----------------  ------------------  ----------------------
-------------------
yoursmplvm01PublicIP  default-ejp-rg   japaneast            IPv4              Dynamic                                  4
Succeeded
</code></pre>

<h3 id="クエリー打つのがめんどくさい系">クエリー打つのがめんどくさい系</h3>

<p>VMに紐づいてるパブリックIPを確認したいときは、こんなエイリアス。</p>

<pre><code>[get-vm-pip]
command = vm list-ip-addresses --query [0].virtualMachine.network.publicIpAddresses[0].ipAddress
</code></pre>

<p>実行すると。</p>

<pre><code>$ az get-vm-pip -n yoursmplvm01
Result
-------------
52.185.133.68
</code></pre>

<h3 id="引数を確認するのがめんどくさい系">引数を確認するのがめんどくさい系</h3>

<p>リソースグループを消したくないけど、中身だけ消したいってケース、よくありますよね。そんなエイリアスも作りました。&ndash;template-uriで指定しているGistには、空っぽのAzure Resource Manager デプロイメントテンプレートが置いてあります。このuriをいちいち確認するのがめんどくさいので、エイリアスに。</p>

<pre><code>[empty-rg]
command = group deployment create --mode Complete --template-uri https://gist.githubusercontent.com/ToruMakabe/28ad5177a6de525866027961aa33b1e7/raw/9b455bfc9608c637e1980d9286b7f77e76a5c74b/azuredeploy_empty.json
</code></pre>

<p>以下のコマンドを打つだけで、リソースグループの中身をバッサリ消せます。投げっぱなしでさっさとPC閉じて帰りたいときは &ndash;no-waitオプションを。</p>

<pre><code>$ az empty-rg
</code></pre>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest#create-an-alias-command-with-arguments">位置引数</a>や<a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest#process-arguments-using-jinja2-templates">Jinja2テンプレート</a>を使ったエイリアスも作れるので、込み入ったブツを、という人は挑戦してみてください。</p>

<h2 id="vs-code-プラグイン-azure-cli-tools">VS Code プラグイン (Azure CLI Tools )</h2>

<p>Azure CLIのVS Code向けプラグインがあります。コードアシストと編集画面からの実行が2大機能。紹介ページのGifアニメを見るのが分かりやすいです。</p>

<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli">Azure CLI Tools</a></p>

<p>プラグインを入れて、拡張子.azcliでファイルを作ればプラグインが効きます。長いコマンドを補完支援付きでコーディングしたい、スクリプトを各行実行して確認しながら作りたい、なんて場合におすすめです。</p>

<h2 id="注意点">注意点</h2>

<ul>
<li>エイリアスには補完が効かない

<ul>
<li>bashでのCLI実行、VS Code Azure CLI Toolsともに、現時点(<sup>2018</sup>&frasl;<sub>4</sub>)でエイリアスには補完が効きません</li>
</ul></li>
<li>ソースコード管理に不要なファイルを含めない

<ul>
<li>$AZURE_CONFIG_DIR/ 下には、aliasやconfigの他に、認証トークンやプロファイルといったシークレット情報が置かれます。なのでGitなどでソースコード管理する場合は、aliasとconfig以外は除外したほうがいいでしょう</li>
</ul></li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Apr 2018, 18:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_terraform_customimage_desc/" class="post-title">TerraformでAzure VM/VMSSの最新のカスタムイメージを指定する方法</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="カスタムイメージではlatest指定できない">カスタムイメージではlatest指定できない</h2>

<p>Azure Marketplaceで提供されているVM/VMSSのイメージは、latest指定により最新のイメージを取得できます。いっぽうでカスタムイメージの場合、同様の属性を管理していないので、できません。</p>

<p>ではVM/VMSSを作成するとき、どうやって最新のカスタムイメージ名を指定すればいいでしょうか。</p>

<ol>
<li>最新のイメージ名を確認のうえ、手で指定する</li>
<li>自動化パイプラインで、イメージ作成とVM/VMSS作成ステップでイメージ名を共有する</li>
</ol>

<p>2のケースは、JenkinsでPackerとTerraformを同じジョブで流すケースがわかりやすい。変数BUILD_NUMBERを共有すればいいですね。でもイメージに変更がなく、Terraformだけ流したい時、パイプラインを頭から流してイメージ作成をやり直すのは、無駄なわけです。</p>

<h2 id="terraformではイメージ名取得に正規表現とソートが可能">Terraformではイメージ名取得に正規表現とソートが可能</h2>

<p>Terraformでは見出しの通り、捗る表現ができます。</p>

<p>イメージを取得するとき、name_regexでイメージ名を引っ張り、sort_descendingを指定すればOK。以下の例は、イメージ名をubuntu1604-xxxxというルールで作ると決めた場合の例です。イメージを作るたびに末尾をインクリメントしてください。ソートはイメージ名全体の<a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/azurerm/data_source_image.go#L164">文字列比較</a>なので、末尾の番号の決めた桁は埋めること。</p>

<p>ということで降順で最上位、つまり最新のイメージ名を取得できます。</p>

<pre><code>data &quot;azurerm_image&quot; &quot;poc&quot; {
  name_regex          = &quot;ubuntu1604-[0-9]*&quot;
  sort_descending     = true
  resource_group_name = &quot;${var.managed_image_resource_group_name}&quot;
}
</code></pre>

<p>あとはVM/VMSSリソース定義内で、取得したイメージのidを渡します。</p>

<pre><code>  storage_profile_image_reference {
    id = &quot;${data.azurerm_image.poc.id}&quot;
  }
</code></pre>

<p>便利である。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">30 Mar 2018, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_msi_terraform/" class="post-title">Azure MarketplaceからMSI対応でセキュアなTerraform環境を整える</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="terraformのプロビジョニングがmarketplaceから可能に">TerraformのプロビジョニングがMarketplaceから可能に</h2>

<p>Terraform使ってますか。Azureのリソースプロビジョニングの基本はAzure Resource Manager Template Deployである、がわたしの持論ですが、Terraformを使う/併用する方がいいな、というケースは結構あります。使い分けは<a href="https://www.slideshare.net/ToruMakabe/azure-infrastructure-as-code">この資料</a>も参考に。</p>

<p>さて、先日Azure Marketplaceから<a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps/azure-oss.terraform">Terraform入りの仮想マシン</a>をプロビジョニングできるようになりました。Ubuntuに以下のアプリが導入、構成されます。</p>

<ul>
<li>Terraform (latest)</li>
<li>Azure CLI 2.0</li>
<li>Managed Service Identity (MSI) VM Extension</li>
<li>Unzip</li>
<li>JQ</li>
<li>apt-transport-https</li>
</ul>

<p>いろいろセットアップしてくれるのでしみじみ便利なのですが、ポイントはManaged Service Identity (MSI)です。</p>

<h2 id="シークレットをコードにベタ書きする問題">シークレットをコードにベタ書きする問題</h2>

<p>MSIの何がうれしいいのでしょう。分かりやすい例を挙げると「GitHubにシークレットを書いたコードをpushする、お漏らし事案」を避ける仕組みです。もちそんそれだけではありませんが。</p>

<p><a href="https://docs.microsoft.com/ja-jp/azure/active-directory/managed-service-identity/overview">Azure リソースの管理対象サービス ID (MSI)</a></p>

<p>詳細の説明は公式ドキュメントに譲りますが、ざっくり説明すると</p>

<p><strong>アプリに認証・認可用のシークレットを書かなくても、アプリの動く仮想マシン上にあるローカルエンドポイントにアクセスすると、Azureのサービスを使うためのトークンが得られるよ</strong></p>

<p>です。</p>

<p>GitHub上に疑わしいシークレットがないかスキャンする<a href="https://azure.microsoft.com/ja-jp/blog/managing-azure-secrets-on-github-repositories/">取り組み</a>もはじまっているのですが、できればお世話になりなくない。MSIを活用しましょう。</p>

<h2 id="terraformはmsiに対応している">TerraformはMSIに対応している</h2>

<p>TerraformでAzureのリソースをプロビジョニングするには、もちろん認証・認可が必要です。従来はサービスプリンシパルを作成し、そのIDやシークレットをTerraformの実行環境に配布していました。でも、できれば配布したくないですよね。実行環境を特定の仮想マシンに限定し、MSIを使えば、解決できます。</p>

<p>ところでMSIを使うには、ローカルエンドポイントにトークンを取りに行くよう、アプリを作らなければいけません。</p>

<p><a href="https://www.terraform.io/docs/providers/azurerm/authenticating_via_msi.html">Authenticating to Azure Resource Manager using Managed Service Identity</a></p>

<p>Terraformは対応済みです。環境変数 ARM_USE_MSI をtrueにしてTerraformを実行すればOK。</p>

<h2 id="試してみよう">試してみよう</h2>

<p>実は、すでに使い方を解説した公式ドキュメントがあります。</p>

<p><a href="https://docs.microsoft.com/ja-jp/azure/terraform/terraform-vm-msi">Azure Marketplace イメージを使用して管理対象サービス ID を使用する Terraform Linux 仮想マシンを作成する</a></p>

<p>手順は十分なのですが、理解を深めるための補足情報が、もうちょっと欲しいところです。なので補ってみましょう。</p>

<h3 id="marketplaceからterraform入り仮想マシンを作る">MarketplaceからTerraform入り仮想マシンを作る</h3>

<p>まず、Marketplaceからのデプロイでどんな仮想マシンが作られたのか、気になります。デプロイに利用されたテンプレートをのぞいてみましょう。注目は以下3つのリソースです。抜き出します。</p>

<ul>
<li>MSI VM拡張の導入</li>
<li>VMに対してリソースグループスコープでContributorロールを割り当て</li>
<li>スクリプト実行 VM拡張でTerraform関連のプロビジョニング</li>
</ul>

<pre><code>[snip]
        {
            &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
            &quot;name&quot;: &quot;[concat(parameters('vmName'),'/MSILinuxExtension')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-12-01&quot;,
            &quot;location&quot;: &quot;[parameters('location')]&quot;,
            &quot;properties&quot;: {
                &quot;publisher&quot;: &quot;Microsoft.ManagedIdentity&quot;,
                &quot;type&quot;: &quot;ManagedIdentityExtensionForLinux&quot;,
                &quot;typeHandlerVersion&quot;: &quot;1.0&quot;,
                &quot;autoUpgradeMinorVersion&quot;: true,
                &quot;settings&quot;: {
                    &quot;port&quot;: 50342
                },
                &quot;protectedSettings&quot;: {}
            },
            &quot;dependsOn&quot;: [
                &quot;[concat('Microsoft.Compute/virtualMachines/', parameters('vmName'))]&quot;
            ]
        },
        {
            &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
            &quot;name&quot;: &quot;[variables('resourceGuid')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-09-01&quot;,
            &quot;properties&quot;: {
                &quot;roleDefinitionId&quot;: &quot;[variables('contributor')]&quot;,
                &quot;principalId&quot;: &quot;[reference(concat(resourceId('Microsoft.Compute/virtualMachines/', parameters('vmName')),'/providers/Microsoft.ManagedIdentity/Identities/default'),'2015-08-31-PREVIEW').principalId]&quot;,
                &quot;scope&quot;: &quot;[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', resourceGroup().name)]&quot;
            },
            &quot;dependsOn&quot;: [
                &quot;[resourceId('Microsoft.Compute/virtualMachines/extensions/', parameters('vmName'),'MSILinuxExtension')]&quot;
            ]
        },
        {
            &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
            &quot;name&quot;: &quot;[concat(parameters('vmName'),'/customscriptextension')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-03-30&quot;,
            &quot;location&quot;: &quot;[parameters('location')]&quot;,
            &quot;properties&quot;: {
                &quot;publisher&quot;: &quot;Microsoft.Azure.Extensions&quot;,
                &quot;type&quot;: &quot;CustomScript&quot;,
                &quot;typeHandlerVersion&quot;: &quot;2.0&quot;,
                &quot;autoUpgradeMinorVersion&quot;: true,
                &quot;settings&quot;: {
                    &quot;fileUris&quot;: [
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/infra.sh', parameters('artifactsLocationSasToken'))]&quot;,
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/install.sh', parameters('artifactsLocationSasToken'))]&quot;,
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/azureProviderAndCreds.tf', parameters('artifactsLocationSasToken'))]&quot;
                    ]
                },
                &quot;protectedSettings&quot;: {
                    &quot;commandToExecute&quot;: &quot;[concat('bash infra.sh &amp;&amp; bash install.sh ', variables('installParm1'), variables('installParm2'), variables('installParm3'), variables('installParm4'), ' -k ', listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('stateStorageAccountName')), '2017-10-01').keys[0].value, ' -l ', reference(concat(resourceId('Microsoft.Compute/virtualMachines/', parameters('vmName')),'/providers/Microsoft.ManagedIdentity/Identities/default'),'2015-08-31-PREVIEW').principalId)]&quot;
                }
            },
            &quot;dependsOn&quot;: [
                &quot;[resourceId('Microsoft.Authorization/roleAssignments', variables('resourceGuid'))]&quot;
            ]
        }
[snip]
</code></pre>

<h3 id="vmにログインし-環境を確認">VMにログインし、環境を確認</h3>

<p>では出来上がったVMにsshし、いろいろのぞいてみましょう。</p>

<pre><code>$ ssh your-vm-public-ip
</code></pre>

<p>Terraformのバージョンは、現時点で最新の0.11.5が入っています。</p>

<pre><code>$ terraform -v
Terraform v0.11.5
</code></pre>

<p>環境変数ARM_USE_MSIはtrueに設定されています。</p>

<pre><code>$ echo $ARM_USE_MSI
true
</code></pre>

<p>MSIも有効化されています(SystemAssigned)。</p>

<pre><code>$ az vm identity show -g tf-msi-poc-ejp-rg -n tfmsipocvm01
{
  &quot;additionalProperties&quot;: {},
  &quot;identityIds&quot;: null,
  &quot;principalId&quot;: &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot;,
  &quot;tenantId&quot;: &quot;tttt-tttt-tttt-tttt&quot;,
  &quot;type&quot;: &quot;SystemAssigned&quot;
}
</code></pre>

<p>さて、このVMはMSIが使えるようになったわけですが、操作できるリソースのスコープは、このVMが属するリソースグループに限定されてます。新たなリソースグループを作成したい場合は、ロールを付与し、スコープを広げます。~/にtfEnv.shというスクリプトが用意されています。用意されたスクリプトを実行すると、サブスクリプションスコープのContributorがVMに割り当てられます。必要に応じて変更しましょう。</p>

<pre><code>$ ls
tfEnv.sh  tfTemplate

$ cat tfEnv.sh
az login
az role assignment create  --assignee &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot; --role 'b24988ac-6180-42a0-ab88-20f7382dd24c'  --scope /subscriptions/&quot;cccc-cccc-cccc-cccc&quot;

$ . ~/tfEnv.sh
To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code HOGEHOGE to authenticate.
[snip]
{
  &quot;additionalProperties&quot;: {},
  &quot;canDelegate&quot;: null,
  &quot;id&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc/providers/Microsoft.Authorization/roleAssignments/ffff-ffff-ffff-ffff&quot;,
  &quot;name&quot;: &quot;ffff-ffff-ffff-ffff&quot;,
  &quot;principalId&quot;: &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot;,
  &quot;roleDefinitionId&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c&quot;,
  &quot;scope&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc&quot;,
  &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;
}
</code></pre>

<p>ちなみに、role id &ldquo;b24988ac-6180-42a0-ab88-20f7382dd24c&rdquo;はContributorを指します。</p>

<p>tfTemplateというディレクトリも用意されているようです。2つのファイルがあります。</p>

<pre><code>$ ls tfTemplate/
azureProviderAndCreds.tf  remoteState.tf
</code></pre>

<p>azureProviderAndCreds.tfは、tfファイルのテンプレートです。コメントアウトと説明のとおり、MSIを使う場合には、このテンプレートは必要ありません。subscription_idとtenant_idは、VMのプロビジョニング時に環境変数にセットされています。そしてclient_idとclient_secretは、MSIを通じて取得されます。明示的に変えたい時のみ指定しましょう。</p>

<pre><code>$ cat tfTemplate/azureProviderAndCreds.tf
#
#
# Provider and credential snippet to add to configurations
# Assumes that there's a terraform.tfvars file with the var values
#
# Uncomment the creds variables if using service principal auth
# Leave them commented to use MSI auth
#
#variable subscription_id {}
#variable tenant_id {}
#variable client_id {}
#variable client_secret {}

provider &quot;azurerm&quot; {
#    subscription_id = &quot;${var.subscription_id}&quot;
#    tenant_id = &quot;${var.tenant_id}&quot;
#    client_id = &quot;${var.client_id}&quot;
#    client_secret = &quot;${var.client_secret}&quot;
}
</code></pre>

<p>remoteState.tfは、TerraformのstateをAzureのBlob上に置く場合に使います。Blobの<a href="https://azure.microsoft.com/en-us/blog/soft-delete-for-azure-storage-blobs-now-in-public-preview/">soft delete</a>が使えるようになったこともあり、事件や事故を考慮すると、できればstateはローカルではなくBlobで管理したいところです。</p>

<pre><code>$ cat tfTemplate/remoteState.tf
terraform {
 backend &quot;azurerm&quot; {
  storage_account_name = &quot;storestaterandomid&quot;
  container_name       = &quot;terraform-state&quot;
  key                  = &quot;prod.terraform.tfstate&quot;
  access_key           = &quot;KYkCz88z+7yoyoyoiyoyoyoiyoyoyoiyoiTDZRbrwAWIPWD+rU6g==&quot;
  }
}
</code></pre>

<p>soft delete設定は、別途 <a href="https://docs.microsoft.com/en-us/cli/azure/storage/blob/service-properties/delete-policy?view=azure-cli-latest#az-storage-blob-service-properties-delete-policy-update">az storage blob service-properties delete-policy update</a> コマンドで行ってください。</p>

<h3 id="プロビジョニングしてみる">プロビジョニングしてみる</h3>

<p>ではTerraformを動かしてみましょう。サブディレクトリsampleを作り、そこで作業します。</p>

<pre><code>$ mkdir sample
$ cd sample/
</code></pre>

<p>stateはBlobで管理しましょう。先ほどのremoteState.tfを実行ディレクトリにコピーします。アクセスキーが入っていますので、このディレクトリをコード管理システム配下に置くのであれば、.gitignoreなどで除外をお忘れなく。</p>

<pre><code>$ cp ../tfTemplate/remoteState.tf ./
</code></pre>

<p>ここのキーが残ってしまうのが現時点での課題。ストレージのキー問題は<a href="https://feedback.azure.com/forums/217298-storage/suggestions/14831712-allow-user-based-access-to-blob-containers-for-su">対応がはじまったので</a>、いずれ解決するはずです。</p>

<p>ではTerraformで作るリソースを書きます。さくっとACI上にnginxコンテナーを作りましょう。</p>

<pre><code>$ vim main.tf
resource &quot;azurerm_resource_group&quot; &quot;tf-msi-poc&quot; {
    name     = &quot;tf-msi-poc-aci-wus-rg&quot;
    location = &quot;West US&quot;
}

resource &quot;random_integer&quot; &quot;random_int&quot; {
    min = 100
    max = 999
}

resource &quot;azurerm_container_group&quot; &quot;aci-example&quot; {
    name                = &quot;aci-cg-${random_integer.random_int.result}&quot;
    location            = &quot;${azurerm_resource_group.tf-msi-poc.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.tf-msi-poc.name}&quot;
    ip_address_type     = &quot;public&quot;
    dns_name_label      = &quot;tomakabe-aci-cg-${random_integer.random_int.result}&quot;
    os_type             = &quot;linux&quot;

    container {
        name    = &quot;nginx&quot;
        image   = &quot;nginx&quot;
        cpu     = &quot;0.5&quot;
        memory  = &quot;1.0&quot;
        port    = &quot;80&quot;
    }
}
</code></pre>

<p>init、plan、アプラーイ。アプライ王子。</p>

<pre><code>$ terraform init
$ terraform plan
$ terraform apply -auto-approve
[snip]
Apply complete! Resources: 3 added, 0 changed, 0 destroyed.
</code></pre>

<p>できたか確認。</p>

<pre><code>$ az container show -g tf-msi-poc-aci-wus-rg -n aci-cg-736 -o table
Name        ResourceGroup          ProvisioningState    Image    IP:ports         CPU/Memory       OsType    Location
----------  ---------------------  -------------------  -------  ---------------  ---------------  --------  ----------
aci-cg-736  tf-msi-poc-aci-wus-rg  Succeeded            nginx    13.91.90.117:80  0.5 core/1.0 gb  Linux     westus
$ curl 13.91.90.117
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
[snip]
</code></pre>

<h2 id="おまけ">おまけ</h2>

<p>サービスプリンシパルは、アプリに対して権限を付与するために必要な仕組みなのですが、使わなくなった際に消し忘れることが多いです。意識して消さないと、散らかり放題。</p>

<p>MSIの場合、対象のVMを消すとそのプリンシパルも消えます。爽快感ほとばしる。</p>

<pre><code>$ az ad sp show --id aaaa-aaaa-aaaa-aaaa-aaaa
Resource 'aaaa-aaaa-aaaa-aaaa-aaaa' does not exist or one of its queried reference-property objects are not present.
</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">26 Mar 2018, 00:08</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/az_vmss_terraform/" class="post-title">AzureのAvailability Zonesへ分散するVMSSをTerraformで作る</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="動機">動機</h2>

<p>Terraform Azure Provider 1.3.0で、VMSSを作る際にAvailability Zonesを指定できるように<a href="https://github.com/terraform-providers/terraform-provider-azurerm/pull/811">なりました</a>。Availability Zonesはインフラの根っこの仕組みなので、現在(<sup>2018</sup>&frasl;<sub>3</sub>)限定されたリージョンで長めのプレビュー期間がとられています。ですが、GAやグローバル展開を見据え、素振りしておきましょう。</p>

<h2 id="前提条件">前提条件</h2>

<ul>
<li>Availability Zones対応リージョンを選びます。現在は<a href="https://docs.microsoft.com/en-us/azure/availability-zones/az-overview#regions-that-support-availability-zones">5リージョン</a>です。この記事ではEast US 2とします。</li>
<li>Availability Zonesのプレビューに<a href="https://docs.microsoft.com/ja-jp/azure/availability-zones/az-overview">サインアップ</a>済みとします。</li>
<li>bashでsshの公開鍵が~/.ssh/id_rsa.pubにあると想定します。</li>
<li>動作確認した環境は以下です。

<ul>
<li>Terraform 0.11.2</li>
<li>Terraform Azure Provider 1.3.0</li>
<li>WSL (ubuntu 16.04)</li>
<li>macos (High Sierra 10.13.3)</li>
</ul></li>
</ul>

<h2 id="コード">コード</h2>

<p>以下のファイルを同じディレクトリに作成します。</p>

<h3 id="terraform-メインコード">Terraform メインコード</h3>

<p>VMSSと周辺リソースを作ります。</p>

<ul>
<li>最終行近くの &ldquo;zones = [1, 2, 3]&rdquo; がポイントです。これだけで、インスタンスを散らす先のゾーンを指定できます。</li>
<li>クロスゾーン負荷分散、冗長化するため、Load BalancerとパブリックIPのSKUをStandardにします。</li>
</ul>

<p>[main.tf]</p>

<pre><code>resource &quot;azurerm_resource_group&quot; &quot;poc&quot; {
  name     = &quot;${var.resource_group_name}&quot;
  location = &quot;East US 2&quot;
}

resource &quot;azurerm_virtual_network&quot; &quot;poc&quot; {
  name                = &quot;vnet01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;
  address_space       = [&quot;10.0.0.0/16&quot;]
}

resource &quot;azurerm_subnet&quot; &quot;poc&quot; {
  name                      = &quot;subnet01&quot;
  resource_group_name       = &quot;${azurerm_resource_group.poc.name}&quot;
  virtual_network_name      = &quot;${azurerm_virtual_network.poc.name}&quot;
  address_prefix            = &quot;10.0.2.0/24&quot;
  network_security_group_id = &quot;${azurerm_network_security_group.poc.id}&quot;
}

resource &quot;azurerm_network_security_group&quot; &quot;poc&quot; {
  name                = &quot;nsg01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;

  security_rule = [
    {
      name                       = &quot;allow_http&quot;
      priority                   = 100
      direction                  = &quot;Inbound&quot;
      access                     = &quot;Allow&quot;
      protocol                   = &quot;Tcp&quot;
      source_port_range          = &quot;*&quot;
      destination_port_range     = &quot;80&quot;
      source_address_prefix      = &quot;*&quot;
      destination_address_prefix = &quot;*&quot;
    },
    {
      name                       = &quot;allow_ssh&quot;
      priority                   = 101
      direction                  = &quot;Inbound&quot;
      access                     = &quot;Allow&quot;
      protocol                   = &quot;Tcp&quot;
      source_port_range          = &quot;*&quot;
      destination_port_range     = &quot;22&quot;
      source_address_prefix      = &quot;*&quot;
      destination_address_prefix = &quot;*&quot;
    },
  ]
}

resource &quot;azurerm_public_ip&quot; &quot;poc&quot; {
  name                         = &quot;pip01&quot;
  resource_group_name          = &quot;${azurerm_resource_group.poc.name}&quot;
  location                     = &quot;${azurerm_resource_group.poc.location}&quot;
  public_ip_address_allocation = &quot;static&quot;
  domain_name_label            = &quot;${var.scaleset_name}&quot;

  sku = &quot;Standard&quot;
}

resource &quot;azurerm_lb&quot; &quot;poc&quot; {
  name                = &quot;lb01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;

  frontend_ip_configuration {
    name                 = &quot;fipConf01&quot;
    public_ip_address_id = &quot;${azurerm_public_ip.poc.id}&quot;
  }

  sku = &quot;Standard&quot;
}

resource &quot;azurerm_lb_backend_address_pool&quot; &quot;poc&quot; {
  name                = &quot;bePool01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id     = &quot;${azurerm_lb.poc.id}&quot;
}

resource &quot;azurerm_lb_rule&quot; &quot;poc&quot; {
  name                           = &quot;lbRule&quot;
  resource_group_name            = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id                = &quot;${azurerm_lb.poc.id}&quot;
  protocol                       = &quot;Tcp&quot;
  frontend_port                  = 80
  backend_port                   = 80
  frontend_ip_configuration_name = &quot;fipConf01&quot;
  backend_address_pool_id        = &quot;${azurerm_lb_backend_address_pool.poc.id}&quot;
  probe_id                       = &quot;${azurerm_lb_probe.poc.id}&quot;
}

resource &quot;azurerm_lb_probe&quot; &quot;poc&quot; {
  name                = &quot;http-probe&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id     = &quot;${azurerm_lb.poc.id}&quot;
  port                = 80
}

resource &quot;azurerm_lb_nat_pool&quot; &quot;poc&quot; {
  count                          = 3
  name                           = &quot;ssh&quot;
  resource_group_name            = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id                = &quot;${azurerm_lb.poc.id}&quot;
  protocol                       = &quot;Tcp&quot;
  frontend_port_start            = 50000
  frontend_port_end              = 50119
  backend_port                   = 22
  frontend_ip_configuration_name = &quot;fipConf01&quot;
}

data &quot;template_cloudinit_config&quot; &quot;poc&quot; {
  gzip          = true
  base64_encode = true

  part {
    content_type = &quot;text/cloud-config&quot;
    content      = &quot;${file(&quot;${path.module}/cloud-config.yaml&quot;)}&quot;
  }
}

resource &quot;azurerm_virtual_machine_scale_set&quot; &quot;poc&quot; {
  name                = &quot;${var.scaleset_name}&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;
  upgrade_policy_mode = &quot;Manual&quot;

  sku {
    name     = &quot;Standard_B1s&quot;
    tier     = &quot;Standard&quot;
    capacity = 3
  }

  storage_profile_image_reference {
    publisher = &quot;Canonical&quot;
    offer     = &quot;UbuntuServer&quot;
    sku       = &quot;16.04-LTS&quot;
    version   = &quot;latest&quot;
  }

  storage_profile_os_disk {
    name              = &quot;&quot;
    caching           = &quot;ReadWrite&quot;
    create_option     = &quot;FromImage&quot;
    managed_disk_type = &quot;Standard_LRS&quot;
  }

  os_profile {
    computer_name_prefix = &quot;pocvmss&quot;
    admin_username       = &quot;${var.admin_username}&quot;
    admin_password       = &quot;&quot;
    custom_data          = &quot;${data.template_cloudinit_config.poc.rendered}&quot;
  }

  os_profile_linux_config {
    disable_password_authentication = true

    ssh_keys {
      path     = &quot;/home/${var.admin_username}/.ssh/authorized_keys&quot;
      key_data = &quot;${file(&quot;~/.ssh/id_rsa.pub&quot;)}&quot;
    }
  }

  network_profile {
    name    = &quot;terraformnetworkprofile&quot;
    primary = true

    ip_configuration {
      name                                   = &quot;PoCIPConfiguration&quot;
      subnet_id                              = &quot;${azurerm_subnet.poc.id}&quot;
      load_balancer_backend_address_pool_ids = [&quot;${azurerm_lb_backend_address_pool.poc.id}&quot;]
      load_balancer_inbound_nat_rules_ids    = [&quot;${element(azurerm_lb_nat_pool.poc.*.id, count.index)}&quot;]
    }
  }

  zones = [1, 2, 3]
}
</code></pre>

<h3 id="cloud-init-configファイル">cloud-init configファイル</h3>

<p>各インスタンスがどのゾーンで動いているか確認したいので、インスタンス作成時にcloud-initでWebサーバーを仕込みます。メタデータからインスタンス名と実行ゾーンを引っ張り、nginxのドキュメントルートに書きます。</p>

<p>[cloud-config.yaml]</p>

<pre><code>#cloud-config
package_upgrade: true
packages:
  - nginx
runcmd:
  - 'echo &quot;[Instance Name]: `curl -H Metadata:true &quot;http://169.254.169.254/metadata/instance/compute/name?api-version=2017-12-01&amp;format=text&quot;`    [Zone]: `curl -H Metadata:true &quot;http://169.254.169.254/metadata/instance/compute/zone?api-version=2017-12-01&amp;format=text&quot;`&quot; &gt; /var/www/html/index.nginx-debian.html'
</code></pre>

<p>インスタンス作成時、パッケージの導入やアップデートに時間をかけたくない場合は、Packerなどで前もってカスタムイメージを作っておくのも手です。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/linux/build-image-with-packer">Packer を使用して Azure に Linux 仮想マシンのイメージを作成する方法</a></li>
<li><a href="https://docs.microsoft.com/ja-jp/azure/terraform/terraform-create-vm-scaleset-network-disks-using-packer-hcl">Terraform を使用して Packer カスタム イメージから Azure 仮想マシン スケール セットを作成する</a></li>
</ul>

<h3 id="terraform-変数ファイル">Terraform 変数ファイル</h3>

<p>変数は別ファイルへ。</p>

<p>[variables.tf]</p>

<pre><code>variable &quot;resource_group_name&quot; {
  default = &quot;your-rg&quot;
}

variable &quot;scaleset_name&quot; {
  default = &quot;yourvmss01&quot;
}

variable &quot;admin_username&quot; {
  default = &quot;yourname&quot;
}
</code></pre>

<h2 id="実行">実行</h2>

<p>では実行。</p>

<pre><code>$ terraform init
$ terraform plan
$ terraform apply
</code></pre>

<p>5分くらいで完了しました。このサンプルでは、この後のcloud-initのパッケージ処理に時間がかかります。待てない場合は前述の通り、カスタムイメージを使いましょう。</p>

<p>インスタンスへのsshを通すよう、Load BalancerにNATを設定していますので、cloud-initの進捗は確認できます。</p>

<pre><code>$ ssh -p 50000 yourname@yourvmss01.eastus2.cloudapp.azure.com
$ tail -f /var/log/cloud-init-output.log
Cloud-init v. 17.1 finished at Sun, 25 Mar 2018 10:41:40 +0000. Datasource DataSourceAzure [seed=/dev/sr0].  Up 611.51 seconds
</code></pre>

<p>ではWebサーバーにアクセスしてみましょう。</p>

<pre><code>$ while true; do curl yourvmss01.eastus2.cloudapp.azure.com; sleep 1; done;
[Instance Name]: yourvmss01_2    [Zone]: 3
[Instance Name]: yourvmss01_0    [Zone]: 1
[Instance Name]: yourvmss01_2    [Zone]: 3
[Instance Name]: yourvmss01_1    [Zone]: 2
</code></pre>

<p>VMSSのインスタンスがゾーンに分散されたことが分かります。</p>

<p>では、このままスケールアウトしてみましょう。main.tfのazurerm_virtual_machine_scale_set.poc.sku.capacityを3から4にし、再度applyします。</p>

<pre><code>[Instance Name]: yourvmss01_1    [Zone]: 2
[Instance Name]: yourvmss01_3    [Zone]: 1
[Instance Name]: yourvmss01_3    [Zone]: 1
[Instance Name]: yourvmss01_1    [Zone]: 2
[Instance Name]: yourvmss01_3    [Zone]: 1
</code></pre>

<p>ダウンタイムなしに、yourvmss01_3が追加されました。すこぶる簡単。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">08 Jan 2018, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/terraform_azure_sample_201801/" class="post-title">TerraformでAzure サンプル 2018/1版</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="サンプルのアップデート">サンプルのアップデート</h2>

<p>年末にリポジトリの大掃除をしていて、2年前に書いたTerraform &amp; Azureの<a href="http://torumakabe.github.io/post/azure_tf_fundamental_rules/">記事</a>に目が止まりました。原則はいいとして、<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample">サンプル</a>は2年物で腐りかけです。ということでアップデートします。</p>

<h2 id="インパクトの大きな変更点">インパクトの大きな変更点</h2>

<p>Terraformの、ここ2年の重要なアップデートは以下でしょうか。Azure視点で。</p>

<ol>
<li>BackendにAzure Blobを使えるようになった</li>
<li>Workspaceで同一コード・複数環境管理ができるようになった</li>
<li>対応リソースが増えた</li>
<li><a href="https://registry.terraform.io/">Terraform Module Registry</a>が公開された</li>
</ol>

<h2 id="更新版サンプルの方針">更新版サンプルの方針</h2>

<p>重要アップデートをふまえ、以下の方針で新サンプルを作りました。</p>

<h3 id="チーム-複数端末での運用">チーム、複数端末での運用</h3>

<p>BackendにAzure Blobがサポートされたので、チーム、複数端末でstateの共有がしやすくなりました。ひとつのプロジェクトや環境を、チームメンバーがどこからでも、だけでなく、複数プロジェクトでのstate共有もできます。</p>

<h3 id="workspaceの導入">Workspaceの導入</h3>

<p>従来は /dev /stage /prodなど、環境別にコードを分けて管理していました。ゆえに環境間のコード同期が課題でしたが、TerraformのWorkspace機能で解決しやすくなりました。リソース定義で ${terraform.workspace} 変数を参照するように書けば、ひとつのコードで複数環境を扱えます。</p>

<p>要件によっては、従来通り環境別にコードを分けた方がいいこともあるでしょう。環境間の差分が大きい、開発とデプロイのタイミングやライフサイクルが異なるなど、Workspaceが使いづらいケースもあるでしょう。その場合は無理せず従来のやり方で。今回のサンプルは「Workspaceを使ったら何ができるか？」を考えるネタにしてください。</p>

<h3 id="module-terraform-module-registryの活用">Module、Terraform Module Registryの活用</h3>

<p>TerraformのModuleはとても強力な機能なのですが、あーでもないこーでもないと、こだわり過ぎるとキリがありません。「うまいやり方」を見てから使いたいのが人情です。そこでTerraform Module Registryを活かします。お墨付きのVerifiedモジュールが公開されていますので、そのまま使うもよし、ライセンスを確認の上フォークするのもよし、です。</p>

<h3 id="リソースグループは環境ごとに準備し-管理をterraformから分離">リソースグループは環境ごとに準備し、管理をTerraformから分離</h3>

<p>AzureのリソースをプロビジョニングするTerraformコードの多くは、Azureのリソースグループを管理下に入れている印象です。すなわちdestroyするとリソースグループごとバッサリ消える。わかりやすいけど破壊的。</p>

<p>TerraformはApp ServiceやACIなどPaaS、アプリ寄りのリソースも作成できるようになってきたので、アプリ開発者にTerraformを開放したいケースが増えてきています。dev環境をアプリ開発者とインフラ技術者がコラボして育て、そのコードをstageやprodにデプロイする、など。</p>

<p>ところで。TerraformのWorkspaceは、こんな感じで簡単に切り替えられます。</p>

<pre><code>terraform workspace select prod
</code></pre>

<p>みなまで言わなくても分かりますね。悲劇はプラットフォーム側で回避しましょう。今回のサンプルではリソースグループをTerraform管理下に置かず、別途作成します。Terraformからはdata resourcesとしてRead Onlyで参照する実装です。環境別のリソースグループを作成し、dev環境のみアプリ開発者へ権限を付与します。</p>

<h2 id="サンプル解説">サンプル解説</h2>

<p>サンプルは<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample_201801">GitHub</a>に置きました。合わせてご確認ください。</p>

<p>このコードをapplyすると、以下のリソースが出来上がります。</p>

<ul>
<li>NGINX on Ubuntu Webサーバー VMスケールセット</li>
<li>VMスケールセット向けロードバランサー</li>
<li>踏み台サーバー</li>
<li>上記を配置するネットワーク (仮想ネットワーク、サブネット、NSG)</li>
</ul>

<h3 id="リポジトリ構造">リポジトリ構造</h3>

<p>サンプルのリポジトリ構造です。</p>

<pre><code>├── modules
│   ├── computegroup
│   │   ├── main.tf
│   │   ├── os
│   │   │   ├── outputs.tf
│   │   │   └── variables.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   ├── loadbalancer
│   │   ├── main.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   └── network
│       ├── main.tf
│       ├── outputs.tf
│       └── variables.tf
└── projects
    ├── project_a
    │   ├── backend.tf
    │   ├── main.tf
    │   ├── outputs.tf
    │   └── variables.tf
    └── shared
        ├── backend.tf
        ├── main.tf
        ├── outputs.tf
        └── variables.tf
</code></pre>

<p>/modulesには<a href="https://registry.terraform.io/browse?provider=azurerm">Terraform Module Registry</a>でVerifiedされているモジュールをフォークしたコードを入れました。フォークした理由は、リソースグループをdata resource化して参照のみにしたかったためです。</p>

<p>そして、/projectsに2つのプロジェクトを作りました。プロジェクトでリソースとTerraformの実行単位、stateを分割します。sharedで土台となる仮想ネットワークと踏み台サーバー関連リソース、project_aでVMスケールセットとロードバランサーを管理します。</p>

<p>このボリュームだとプロジェクトを分割する必然性は低いのですが、以下のケースにも対応できるように分けました。</p>

<ul>
<li>アプリ開発者がproject_a下でアプリ関連リソースに集中したい</li>
<li>性能観点で分割したい (Terraformはリソース量につれて重くなりがち)</li>
<li>有事を考慮し影響範囲を分割したい</li>
</ul>

<p>プロジェクト間では、stateをremote_stateを使って共有します。サンプルではsharedで作成した仮想ネットワークのサブネットIDを<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample_201801/blob/master/projects/shared/outputs.tf#L1">output</a>し、project_aで参照できるよう<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample_201801/blob/master/projects/project_a/backend.tf.sample#L10">定義</a>しています。</p>

<h2 id="使い方">使い方</h2>

<h3 id="前提">前提</h3>

<ul>
<li>Linux、WSL、macOSなどbash環境の実行例です</li>
<li>SSHの公開鍵をTerraform実行環境の ~/.ssh/id_rsa.pub として準備してください</li>
</ul>

<h3 id="管理者向けのサービスプリンシパルを用意する">管理者向けのサービスプリンシパルを用意する</h3>

<p>インフラのプロビジョニングの主体者、管理者向けのサービスプリンシパルを用意します。リソースグループを作成できる権限が必要です。</p>

<p>もしなければ作成します。組み込みロールでは、サブスクリプションに対するContributorが妥当でしょう。<a href="https://www.terraform.io/docs/providers/azurerm/authenticating_via_service_principal.html">Terraformのドキュメント</a>も参考に。</p>

<pre><code>az ad sp create-for-rbac --role=&quot;Contributor&quot; --scopes=&quot;/subscriptions/SUBSCRIPTION_ID&quot;
</code></pre>

<p>出力されるappId、password、tenantを控えます。既存のサービスプリンシパルを使うのであれば、同情報を確認してください。</p>

<p>なお参考までに。Azure Cloud ShellなどAzure CLIが導入されている環境では、特に認証情報の指定なしでterraform planやapply時にAzureのリソースにアクセスできます。TerraformがCLIの認証トークンを<a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/azurerm/helpers/authentication/config.go">使う</a>からです。</p>

<p>そしてBackendをAzure Blobとする場合、Blobにアクセスするためのキーが別途必要です。ですが、残念ながらBackendロジックでキーを得る際に、このトークンが<a href="https://github.com/hashicorp/terraform/blob/master/backend/remote-state/azure/backend.go">使われません</a>。キーを明示することもできますが、Blobのアクセスキーは漏洩時のリカバリーが大変です。できれば直に扱いたくありません。</p>

<p>サービスプリンシパル認証であれば、Azureリソースへのプロビジョニング、Backendアクセスどちらも<a href="https://www.terraform.io/docs/backends/types/azurerm.html">対応できます</a>。これがこのサンプルでサービスプリンシパル認証を選んだ理由です。</p>

<h3 id="管理者の環境変数を設定する">管理者の環境変数を設定する</h3>

<p>Terraformが認証関連で必要な情報を環境変数で設定します。先ほど控えた情報を使います。</p>

<pre><code>export ARM_SUBSCRIPTION_ID=&quot;&lt;your subscription id&gt;&quot;
export ARM_CLIENT_ID=&quot;&lt;your servicce principal appid&gt;&quot;
export ARM_CLIENT_SECRET=&quot;&lt;your service principal password&gt;&quot;
export ARM_TENANT_ID=&quot;&lt;your service principal tenant&gt;&quot;
</code></pre>

<h3 id="workspaceを作る">Workspaceを作る</h3>

<p>開発(dev)/ステージング(stage)/本番(prod)、3つのWorkspaceを作る例です。</p>

<pre><code>terraform workspace new dev
terraform workspace new stage
terraform workspace new prod
</code></pre>

<h3 id="リソースグループを作る">リソースグループを作る</h3>

<p>まずWorkspace別にリソースグループを作ります。</p>

<pre><code>az group create -n tf-sample-dev-rg -l japaneast
az group create -n tf-sample-stage-rg -l japaneast
az group create -n tf-sample-prod-rg -l japaneast
</code></pre>

<p>リソースグループ名にはルールがあります。Workspace別にリソースグループを分離するため、Terraformのコードで ${terraform.workspace} 変数を使っているためです。この変数は実行時に評価されます。</p>

<pre><code>data &quot;azurerm_resource_group&quot; &quot;resource_group&quot; {
  name = &quot;${var.resource_group_name}-${terraform.workspace}-rg&quot;
}
</code></pre>

<p>${var.resource_group_name} は接頭辞です。サンプルではvariables.tfで&rdquo;tf-sample&rdquo;と指定しています。</p>

<p>次にBackend、state共有向けリソースグループを作ります。</p>

<pre><code>az group create -n tf-sample-state-rg -l japaneast
</code></pre>

<p>このリソースグループは、各projectのbackend.tfで指定しています。</p>

<pre><code>terraform {
  backend &quot;azurerm&quot; {
    resource_group_name  = &quot;tf-sample-state-rg&quot;
    storage_account_name = &quot;&lt;your storage account name&gt;&quot;
    container_name       = &quot;tfstate-project-a&quot;
    key                  = &quot;terraform.tfstate&quot;
  }
}
</code></pre>

<p>最後にアプリ開発者がリソースグループtf-sample-dev-rg、tf-sample-state-rgへアクセスできるよう、アプリ開発者向けサービスプリンシパルを作成します。</p>

<pre><code>az ad sp create-for-rbac --role=&quot;Contributor&quot; --scopes &quot;/subscriptions/&lt;your subscription id&gt;/resourceGroups/tf-sample-dev-rg&quot; &quot;/subscriptions/&lt;your subscription id&gt;/resourceGroups/tf-sample-state-rg&quot;
</code></pre>

<p>出力されるappId、password、tenantは、アプリ開発者向けに控えておきます。</p>

<h3 id="backendを準備する">Backendを準備する</h3>

<p>project別にストレージアカウントとコンテナーを作ります。tf-sample-state-rgに</p>

<ul>
<li>ストレージアカウント (名前は任意)</li>
<li>コンテナー *2 (tfstate-project-a, tfstate-shared)</li>
</ul>

<p>を作ってください。GUIでもCLIでも、お好きなやり方で。</p>

<p>その後、project_a/backend.tf.sample、shared/backend.tf.sampleをそれぞれbackend.tfにリネームし、先ほど作ったストレージアカウント名を指定します。以下はproject_a/backend.tf.sampleの例。</p>

<pre><code>terraform {
  backend &quot;azurerm&quot; {
    resource_group_name  = &quot;tf-sample-state-rg&quot;
    storage_account_name = &quot;&lt;your storage account name&gt;&quot;
    container_name       = &quot;tfstate-project-a&quot;
    key                  = &quot;terraform.tfstate&quot;
  }
}

data &quot;terraform_remote_state&quot; &quot;shared&quot; {
  backend = &quot;azurerm&quot;

  config {
    resource_group_name  = &quot;tf-sample-state-rg&quot;
    storage_account_name = &quot;&lt;your storage account name&gt;&quot;
    container_name       = &quot;tfstate-shared&quot;
    key                  = &quot;terraform.tfstateenv:${terraform.workspace}&quot;
  }
}
</code></pre>

<p>これで準備完了です。</p>

<h3 id="実行">実行</h3>

<p>Workspaceをdevに切り替えます。</p>

<pre><code>terraform workspace select dev
</code></pre>

<p>まずは土台となるリソースを作成するsharedから。</p>

<pre><code>cd shared
terraform init
terraform plan
terraform apply
</code></pre>

<p>土台となるリソースが作成されたら、次はproject_aを。</p>

<pre><code>cd ../project_a
terraform init
terraform plan
terraform apply
</code></pre>

<p>ここでは割愛しますが、dev向けサービスプリンシパルで認証しても、dev Workspaceではplan、apply可能です。</p>

<p>dev Workspaceでコードが育ったら、stage/prod Workspaceに切り替えて実行します。</p>

<pre><code>terraform workspace select stage
[以下devと同様の操作]
</code></pre>

<p>当然、dev向けサービスプリンシパルで認証している場合は、stage/prodでのplan、apply、もちろんdestroyも失敗します。stage/prod リソースグループにアクセスする権限がないからです。</p>

<h2 id="参考情報">参考情報</h2>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/azure/terraform/">Terraform on Azure のドキュメント</a></li>
<li><a href="https://github.com/terraform-providers/terraform-provider-azurerm/tree/master/examples">サンプル集 on GitHub</a></li>
</ul>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 2</span>
    
      <a href="/tags/terraform/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
