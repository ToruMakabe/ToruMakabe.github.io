<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terraform &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.39" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Terraform &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Terraform &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">27 Apr 2018, 17:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/terraform_azure_secret/" class="post-title">TerraformでAzureのシークレットを受け渡す(ACI/AKS編)</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="動機">動機</h2>

<p>システム開発、運用の現場では、しばしばシークレットの受け渡しをします。代表例はデータベースの接続文字列です。データベース作成時に生成した接続文字列をアプリ側で設定するのですが、ひとりでコピペするにせよ、チームメンバー間で受け渡すにせよ、めんどくさく、危険が危ないわけです。</p>

<ul>
<li>いちいちポータルやCLIで接続文字列を出力、コピーして、アプリの設定ファイルや環境変数にペーストしなければいけない

<ul>
<li>めんどくさいし手が滑る</li>
</ul></li>
<li>データベース管理者がアプリ開発者に接続文字列を何らかの手段で渡さないといけない

<ul>
<li>メールとかチャットとかファイルサーバーとか勘弁</li>
</ul></li>
<li>もしくはアプリ開発者にデータベースの接続文字列が読める権限を与えなければいけない

<ul>
<li>本番でも、それやる？</li>
</ul></li>
<li>kubernetes(k8s)のSecretをいちいちkubectlを使って作りたくない

<ul>
<li>Base64符号化とか、うっかり忘れる</li>
</ul></li>
</ul>

<p>つらいですね。シークレットなんて意識したくないのが人情。そこで、Terraformを使った解決法を。</p>

<h2 id="シナリオ">シナリオ</h2>

<p>Azureでコンテナーを使うシナリオを例に紹介します。ACI(Azure Container Instances)とAKS(Azure Container Service - k8s)の2パターンです。</p>

<ul>
<li>Nodeとデータストアを組み合わせた、<a href="https://github.com/ToruMakabe/ImpressAzureBookNode">Todoアプリケーション</a></li>
<li>コンテナーイメージは<a href="https://hub.docker.com/r/torumakabe/nodetodo/">Docker Hub</a>にある</li>
<li>コンテナーでデータストアを運用したくないので、データストアはマネージドサービスを使う</li>
<li>データストアはCosmos DB(MongoDB API)</li>
<li>Cosmos DBへのアクセスに必要な属性をTerraformで参照し、接続文字列(MONGO_URL)を作る

<ul>
<li>接続文字列の渡し方はACI/AKSで異なる</li>
<li>ACI

<ul>
<li>コンテナー作成時に環境変数として接続文字列を渡す</li>
</ul></li>
<li>AKS

<ul>
<li>k8sのSecretとして接続文字列をストアする</li>
<li>コンテナー作成時にSecretを参照し、環境変数として渡す</li>
</ul></li>
</ul></li>
</ul>

<h2 id="検証環境">検証環境</h2>

<ul>
<li>Azure Cloud Shell

<ul>
<li>Terraform v0.11.7</li>
<li>Terraformの認証はCloud Shell組み込み</li>
</ul></li>
<li>Terraform Azure Provider v1.4</li>
<li>Terraform kubernetes Provider v1.1</li>
<li>AKS kubernetes 1.9.6</li>
</ul>

<h2 id="aciの場合">ACIの場合</h2>

<p>ざっと以下の流れです。</p>

<ol>
<li>リソースグループ作成</li>
<li>Cosmos DBアカウント作成</li>
<li>ACIコンテナーグループ作成 (Cosmos DB属性から接続文字列を生成)</li>
</ol>

<p>var.で参照している変数は、別ファイルに書いています。</p>

<p>[main.tf]</p>

<pre><code>resource &quot;azurerm_resource_group&quot; &quot;rg&quot; {
  name     = &quot;${var.resource_group_name}&quot;
  location = &quot;${var.resource_group_location}&quot;
}

resource &quot;random_integer&quot; &quot;ri&quot; {
  min = 10000
  max = 99999
}

resource &quot;azurerm_cosmosdb_account&quot; &quot;db&quot; {
  name                = &quot;your-cosmos-db-${random_integer.ri.result}&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  offer_type          = &quot;Standard&quot;
  kind                = &quot;MongoDB&quot;

  enable_automatic_failover = true

  consistency_policy {
    consistency_level       = &quot;BoundedStaleness&quot;
    max_interval_in_seconds = 10
    max_staleness_prefix    = 200
  }

  geo_location {
    location          = &quot;${azurerm_resource_group.rg.location}&quot;
    failover_priority = 0
  }

  geo_location {
    location          = &quot;${var.failover_location}&quot;
    failover_priority = 1
  }
}

resource &quot;azurerm_container_group&quot; &quot;aci-todo&quot; {
  name                = &quot;aci-todo&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  ip_address_type     = &quot;public&quot;
  dns_name_label      = &quot;yourtodo&quot;
  os_type             = &quot;linux&quot;

  container {
    name   = &quot;todo&quot;
    image  = &quot;torumakabe/nodetodo&quot;
    cpu    = &quot;1&quot;
    memory = &quot;1.5&quot;
    port   = &quot;8080&quot;

    environment_variables {
      &quot;MONGO_URL&quot; = &quot;mongodb://${azurerm_cosmosdb_account.db.name}:${azurerm_cosmosdb_account.db.primary_master_key}@${azurerm_cosmosdb_account.db.name}.documents.azure.com:10255/?ssl=true&quot;
    }
  }
}
</code></pre>

<p>containerのenvironment_variablesブロックでCosmos DBの属性を参照し、接続文字列を生成しています。簡単ですね。これで接続文字列コピペ作業から解放されます。</p>

<h2 id="aks">AKS</h2>

<p>AKSの場合、流れは以下の通りです。</p>

<ol>
<li>リソースグループ作成</li>
<li>Cosmos DBアカウント作成</li>
<li>AKSクラスター作成</li>
<li>k8s Secretを作成 (Cosmos DB属性から接続文字列生成)</li>
<li>k8s Secretをコンテナーの環境変数として参照し、アプリをデプロイ</li>
</ol>

<p>[main.tf]</p>

<pre><code>resource &quot;azurerm_resource_group&quot; &quot;rg&quot; {
  name     = &quot;${var.resource_group_name}&quot;
  location = &quot;${var.resource_group_location}&quot;
}

resource &quot;random_integer&quot; &quot;ri&quot; {
  min = 10000
  max = 99999
}

resource &quot;azurerm_cosmosdb_account&quot; &quot;db&quot; {
  name                = &quot;your-cosmos-db-${random_integer.ri.result}&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  offer_type          = &quot;Standard&quot;
  kind                = &quot;MongoDB&quot;

  enable_automatic_failover = true

  consistency_policy {
    consistency_level       = &quot;BoundedStaleness&quot;
    max_interval_in_seconds = 10
    max_staleness_prefix    = 200
  }

  geo_location {
    location          = &quot;${azurerm_resource_group.rg.location}&quot;
    failover_priority = 0
  }

  geo_location {
    location          = &quot;${var.failover_location}&quot;
    failover_priority = 1
  }
}

resource &quot;azurerm_kubernetes_cluster&quot; &quot;aks&quot; {
  name                = &quot;yourakstf&quot;
  location            = &quot;${azurerm_resource_group.rg.location}&quot;
  resource_group_name = &quot;${azurerm_resource_group.rg.name}&quot;
  dns_prefix          = &quot;yourakstf&quot;
  kubernetes_version  = &quot;1.9.6&quot;

  linux_profile {
    admin_username = &quot;${var.admin_username}&quot;

    ssh_key {
      key_data = &quot;${var.key_data}&quot;
    }
  }

  agent_pool_profile {
    name            = &quot;default&quot;
    count           = 3
    vm_size         = &quot;Standard_B2ms&quot;
    os_type         = &quot;Linux&quot;
    os_disk_size_gb = 30
  }

  service_principal {
    client_id     = &quot;${var.client_id}&quot;
    client_secret = &quot;${var.client_secret}&quot;
  }
}

provider &quot;kubernetes&quot; {
  host = &quot;${azurerm_kubernetes_cluster.aks.kube_config.0.host}&quot;

  client_certificate     = &quot;${base64decode(azurerm_kubernetes_cluster.aks.kube_config.0.client_certificate)}&quot;
  client_key             = &quot;${base64decode(azurerm_kubernetes_cluster.aks.kube_config.0.client_key)}&quot;
  cluster_ca_certificate = &quot;${base64decode(azurerm_kubernetes_cluster.aks.kube_config.0.cluster_ca_certificate)}&quot;
}

resource &quot;kubernetes_secret&quot; &quot;cosmosdb_secret&quot; {
  metadata {
    name = &quot;cosmosdb-secret&quot;
  }

  data {
    MONGO_URL = &quot;mongodb://${azurerm_cosmosdb_account.db.name}:${azurerm_cosmosdb_account.db.primary_master_key}@${azurerm_cosmosdb_account.db.name}.documents.azure.com:10255/?ssl=true&quot;
  }
}
</code></pre>

<p>Cosmos DB、AKSクラスターを作ったのち、kubernetesプロバイダーを使ってSecretを登録しています。複数のプロバイダーを組み合わせられる、Terraformの特長が活きています。</p>

<p>そしてアプリのデプロイ時に、登録したSecretを指定します。ここからはkubernetesワールドなので、kubectlなどを使います。マニフェストは以下のように。</p>

<p>[todo.yaml]</p>

<pre><code>apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: todoapp
spec:
  selector:
    matchLabels:
      app: todoapp
  replicas: 2
  template:
    metadata:
      labels:
        app: todoapp
    spec:
      containers:
        - name: todoapp
          image: torumakabe/nodetodo
          ports:
            - containerPort: 8080
          env:
            - name: MONGO_URL
              valueFrom:
                secretKeyRef:
                  name: cosmosdb-secret
                  key: MONGO_URL
---
apiVersion: v1
kind: Service
metadata:
  name: todoapp
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: todoapp
</code></pre>

<p>シークレットの中身を見ることなく、コピペもせず、もちろんメールやチャットやファイルも使わず、アプリからCosmos DBへ接続できました。</p>

<p>シークレットに限らず、Terraformの属性参照、変数表現は強力ですので、ぜひ活用してみてください。数多くの<a href="https://www.terraform.io/docs/providers/azurerm/">Azureリソース</a>が対応しています。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">09 Apr 2018, 15:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/myazurecli201804/" class="post-title">俺のAzure CLI 2018春版</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="春の環境リフレッシュ祭り">春の環境リフレッシュ祭り</h2>

<p>最近KubernetesのCLI、kubectlを使う機会が多いのですが、なかなかイケてるんですよ。かゆい所に手が届く感じ。そこで、いい機会なのでAzure CLIまわりも最新の機能やツールで整えようか、というのが今回の動機。気づかないうちに、界隈が充実していた。</p>

<h2 id="俺のおすすめ-3選">俺のおすすめ 3選</h2>

<ul>
<li>デフォルト設定

<ul>
<li>リソースグループやロケーション、出力形式などのデフォルト設定ができる</li>
</ul></li>
<li>エイリアス

<ul>
<li>サブコマンドにエイリアスを付けられる</li>
<li>引数付きの込み入った表現もできる</li>
</ul></li>
<li>VS Code プラグイン

<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli">Azure CLI Toolsプラグイン</a> でazコマンドの編集をコードアシストしてくれる</li>
<li>編集画面上でコマンド選択して実行できる</li>
</ul></li>
</ul>

<h2 id="デフォルト設定">デフォルト設定</h2>

<p>$AZURE_CONFIG_DIR/configファイルで構成設定ができます。$AZURE_CONFIG_DIR の既定値は、Linux/macOS の場合$HOME/.azure、Windowsは%USERPROFILE%.azure。</p>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-configuration?view=azure-cli-latest">Azure CLI 2.0 の構成</a></p>

<p>まず変えたいところは、コマンドの出力形式。デフォルトはJSON。わたしのお気持ちは、普段はTable形式、掘りたい時だけJSON。なのでデフォルトをtableに変えます。</p>

<pre><code>[core]
output = table
</code></pre>

<p>そしてデフォルトのリソースグループを設定します。以前は「デフォルト設定すると、気づかないところで事故るから、やらない」という主義だったのですが、Kubernetesのdefault namespaceの扱いを見て「ああ、これもありかなぁ」と改宗したところ。</p>

<pre><code>[defaults]
group = default-ejp-rg
</code></pre>

<p>他にもロケーションやストレージアカウントなどを設定できます。ロケーションはリソースグループの属性を継承させたい、もしくは明示したい場合が多いので、設定していません。</p>

<p>ということで、急ぎUbuntuの仮想マシンが欲しいぜという場合、az vm createコマンドの必須パラメーター、-gと-lを省略できるようになったので、さくっと以下のコマンドでできるようになりました。</p>

<p>デフォルト指定したリソースグループを、任意のロケーションに作ってある前提です。</p>

<pre><code>az vm create -n yoursmplvm01 --image UbuntuLTS
</code></pre>

<h2 id="エイリアス">エイリアス</h2>

<p>$AZURE_CONFIG_DIR/aliasにエイリアスを書けます。</p>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest">Azure CLI 2.0 のエイリアス拡張機能</a></p>

<p>前提はAzure CLI v2.0.28以降です。以下のコマンドでエイリアス拡張を導入できます。現時点ではプレビュー扱いなのでご注意を。</p>

<pre><code>az extension add --name alias
</code></pre>

<p>ひとまずわたしは以下3カテゴリのエイリアスを登録しました。</p>

<h3 id="頻繁に打つからできる限り短くしたい系">頻繁に打つからできる限り短くしたい系</h3>

<pre><code>[ls]
command = list

[nw]
command = network

[pip]
command = public-ip

[fa]
command = functionapp
</code></pre>

<p>例えばデフォルトリソースグループでパブリックIP公開してるか確認したいな、と思った時は、az network public-ip listじゃなくて、こう打てます。</p>

<pre><code>$ az nw pip ls
Name                  ResourceGroup    Location    Zones    AddressVersion    AllocationMethod      IdleTimeoutInMinutes
ProvisioningState
--------------------  ---------------  ----------  -------  ----------------  ------------------  ----------------------
-------------------
yoursmplvm01PublicIP  default-ejp-rg   japaneast            IPv4              Dynamic                                  4
Succeeded
</code></pre>

<h3 id="クエリー打つのがめんどくさい系">クエリー打つのがめんどくさい系</h3>

<p>VMに紐づいてるパブリックIPを確認したいときは、こんなエイリアス。</p>

<pre><code>[get-vm-pip]
command = vm list-ip-addresses --query [0].virtualMachine.network.publicIpAddresses[0].ipAddress
</code></pre>

<p>実行すると。</p>

<pre><code>$ az get-vm-pip -n yoursmplvm01
Result
-------------
52.185.133.68
</code></pre>

<h3 id="引数を確認するのがめんどくさい系">引数を確認するのがめんどくさい系</h3>

<p>リソースグループを消したくないけど、中身だけ消したいってケース、よくありますよね。そんなエイリアスも作りました。&ndash;template-uriで指定しているGistには、空っぽのAzure Resource Manager デプロイメントテンプレートが置いてあります。このuriをいちいち確認するのがめんどくさいので、エイリアスに。</p>

<pre><code>[empty-rg]
command = group deployment create --mode Complete --template-uri https://gist.githubusercontent.com/ToruMakabe/28ad5177a6de525866027961aa33b1e7/raw/9b455bfc9608c637e1980d9286b7f77e76a5c74b/azuredeploy_empty.json
</code></pre>

<p>以下のコマンドを打つだけで、リソースグループの中身をバッサリ消せます。投げっぱなしでさっさとPC閉じて帰りたいときは &ndash;no-waitオプションを。</p>

<pre><code>$ az empty-rg
</code></pre>

<p><a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest#create-an-alias-command-with-arguments">位置引数</a>や<a href="https://docs.microsoft.com/ja-jp/cli/azure/azure-cli-extension-alias?view=azure-cli-latest#process-arguments-using-jinja2-templates">Jinja2テンプレート</a>を使ったエイリアスも作れるので、込み入ったブツを、という人は挑戦してみてください。</p>

<h2 id="vs-code-プラグイン-azure-cli-tools">VS Code プラグイン (Azure CLI Tools )</h2>

<p>Azure CLIのVS Code向けプラグインがあります。コードアシストと編集画面からの実行が2大機能。紹介ページのGifアニメを見るのが分かりやすいです。</p>

<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.azurecli">Azure CLI Tools</a></p>

<p>プラグインを入れて、拡張子.azcliでファイルを作ればプラグインが効きます。長いコマンドを補完支援付きでコーディングしたい、スクリプトを各行実行して確認しながら作りたい、なんて場合におすすめです。</p>

<h2 id="注意点">注意点</h2>

<ul>
<li>エイリアスには補完が効かない

<ul>
<li>bashでのCLI実行、VS Code Azure CLI Toolsともに、現時点(<sup>2018</sup>&frasl;<sub>4</sub>)でエイリアスには補完が効きません</li>
</ul></li>
<li>ソースコード管理に不要なファイルを含めない

<ul>
<li>$AZURE_CONFIG_DIR/ 下には、aliasやconfigの他に、認証トークンやプロファイルといったシークレット情報が置かれます。なのでGitなどでソースコード管理する場合は、aliasとconfig以外は除外したほうがいいでしょう</li>
</ul></li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">06 Apr 2018, 18:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_terraform_customimage_desc/" class="post-title">TerraformでAzure VM/VMSSの最新のカスタムイメージを指定する方法</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="カスタムイメージではlatest指定できない">カスタムイメージではlatest指定できない</h2>

<p>Azure Marketplaceで提供されているVM/VMSSのイメージは、latest指定により最新のイメージを取得できます。いっぽうでカスタムイメージの場合、同様の属性を管理していないので、できません。</p>

<p>ではVM/VMSSを作成するとき、どうやって最新のカスタムイメージ名を指定すればいいでしょうか。</p>

<ol>
<li>最新のイメージ名を確認のうえ、手で指定する</li>
<li>自動化パイプラインで、イメージ作成とVM/VMSS作成ステップでイメージ名を共有する</li>
</ol>

<p>2のケースは、JenkinsでPackerとTerraformを同じジョブで流すケースがわかりやすい。変数BUILD_NUMBERを共有すればいいですね。でもイメージに変更がなく、Terraformだけ流したい時、パイプラインを頭から流してイメージ作成をやり直すのは、無駄なわけです。</p>

<h2 id="terraformではイメージ名取得に正規表現とソートが可能">Terraformではイメージ名取得に正規表現とソートが可能</h2>

<p>Terraformでは見出しの通り、捗る表現ができます。</p>

<p>イメージを取得するとき、name_regexでイメージ名を引っ張り、sort_descendingを指定すればOK。以下の例は、イメージ名をubuntu1604-xxxxというルールで作ると決めた場合の例です。イメージを作るたびに末尾をインクリメントしてください。ソートはイメージ名全体の<a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/azurerm/data_source_image.go#L164">文字列比較</a>なので、末尾の番号の決めた桁は埋めること。</p>

<p>ということで降順で最上位、つまり最新のイメージ名を取得できます。</p>

<pre><code>data &quot;azurerm_image&quot; &quot;poc&quot; {
  name_regex          = &quot;ubuntu1604-[0-9]*&quot;
  sort_descending     = true
  resource_group_name = &quot;${var.managed_image_resource_group_name}&quot;
}
</code></pre>

<p>あとはVM/VMSSリソース定義内で、取得したイメージのidを渡します。</p>

<pre><code>  storage_profile_image_reference {
    id = &quot;${data.azurerm_image.poc.id}&quot;
  }
</code></pre>

<p>便利である。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">30 Mar 2018, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_msi_terraform/" class="post-title">Azure MarketplaceからMSI対応でセキュアなTerraform環境を整える</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="terraformのプロビジョニングがmarketplaceから可能に">TerraformのプロビジョニングがMarketplaceから可能に</h2>

<p>Terraform使ってますか。Azureのリソースプロビジョニングの基本はAzure Resource Manager Template Deployである、がわたしの持論ですが、Terraformを使う/併用する方がいいな、というケースは結構あります。使い分けは<a href="https://www.slideshare.net/ToruMakabe/azure-infrastructure-as-code">この資料</a>も参考に。</p>

<p>さて、先日Azure Marketplaceから<a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps/azure-oss.terraform">Terraform入りの仮想マシン</a>をプロビジョニングできるようになりました。Ubuntuに以下のアプリが導入、構成されます。</p>

<ul>
<li>Terraform (latest)</li>
<li>Azure CLI 2.0</li>
<li>Managed Service Identity (MSI) VM Extension</li>
<li>Unzip</li>
<li>JQ</li>
<li>apt-transport-https</li>
</ul>

<p>いろいろセットアップしてくれるのでしみじみ便利なのですが、ポイントはManaged Service Identity (MSI)です。</p>

<h2 id="シークレットをコードにベタ書きする問題">シークレットをコードにベタ書きする問題</h2>

<p>MSIの何がうれしいいのでしょう。分かりやすい例を挙げると「GitHubにシークレットを書いたコードをpushする、お漏らし事案」を避ける仕組みです。もちそんそれだけではありませんが。</p>

<p><a href="https://docs.microsoft.com/ja-jp/azure/active-directory/managed-service-identity/overview">Azure リソースの管理対象サービス ID (MSI)</a></p>

<p>詳細の説明は公式ドキュメントに譲りますが、ざっくり説明すると</p>

<p><strong>アプリに認証・認可用のシークレットを書かなくても、アプリの動く仮想マシン上にあるローカルエンドポイントにアクセスすると、Azureのサービスを使うためのトークンが得られるよ</strong></p>

<p>です。</p>

<p>GitHub上に疑わしいシークレットがないかスキャンする<a href="https://azure.microsoft.com/ja-jp/blog/managing-azure-secrets-on-github-repositories/">取り組み</a>もはじまっているのですが、できればお世話になりなくない。MSIを活用しましょう。</p>

<h2 id="terraformはmsiに対応している">TerraformはMSIに対応している</h2>

<p>TerraformでAzureのリソースをプロビジョニングするには、もちろん認証・認可が必要です。従来はサービスプリンシパルを作成し、そのIDやシークレットをTerraformの実行環境に配布していました。でも、できれば配布したくないですよね。実行環境を特定の仮想マシンに限定し、MSIを使えば、解決できます。</p>

<p>ところでMSIを使うには、ローカルエンドポイントにトークンを取りに行くよう、アプリを作らなければいけません。</p>

<p><a href="https://www.terraform.io/docs/providers/azurerm/authenticating_via_msi.html">Authenticating to Azure Resource Manager using Managed Service Identity</a></p>

<p>Terraformは対応済みです。環境変数 ARM_USE_MSI をtrueにしてTerraformを実行すればOK。</p>

<h2 id="試してみよう">試してみよう</h2>

<p>実は、すでに使い方を解説した公式ドキュメントがあります。</p>

<p><a href="https://docs.microsoft.com/ja-jp/azure/terraform/terraform-vm-msi">Azure Marketplace イメージを使用して管理対象サービス ID を使用する Terraform Linux 仮想マシンを作成する</a></p>

<p>手順は十分なのですが、理解を深めるための補足情報が、もうちょっと欲しいところです。なので補ってみましょう。</p>

<h3 id="marketplaceからterraform入り仮想マシンを作る">MarketplaceからTerraform入り仮想マシンを作る</h3>

<p>まず、Marketplaceからのデプロイでどんな仮想マシンが作られたのか、気になります。デプロイに利用されたテンプレートをのぞいてみましょう。注目は以下3つのリソースです。抜き出します。</p>

<ul>
<li>MSI VM拡張の導入</li>
<li>VMに対してリソースグループスコープでContributorロールを割り当て</li>
<li>スクリプト実行 VM拡張でTerraform関連のプロビジョニング</li>
</ul>

<pre><code>[snip]
        {
            &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
            &quot;name&quot;: &quot;[concat(parameters('vmName'),'/MSILinuxExtension')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-12-01&quot;,
            &quot;location&quot;: &quot;[parameters('location')]&quot;,
            &quot;properties&quot;: {
                &quot;publisher&quot;: &quot;Microsoft.ManagedIdentity&quot;,
                &quot;type&quot;: &quot;ManagedIdentityExtensionForLinux&quot;,
                &quot;typeHandlerVersion&quot;: &quot;1.0&quot;,
                &quot;autoUpgradeMinorVersion&quot;: true,
                &quot;settings&quot;: {
                    &quot;port&quot;: 50342
                },
                &quot;protectedSettings&quot;: {}
            },
            &quot;dependsOn&quot;: [
                &quot;[concat('Microsoft.Compute/virtualMachines/', parameters('vmName'))]&quot;
            ]
        },
        {
            &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
            &quot;name&quot;: &quot;[variables('resourceGuid')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-09-01&quot;,
            &quot;properties&quot;: {
                &quot;roleDefinitionId&quot;: &quot;[variables('contributor')]&quot;,
                &quot;principalId&quot;: &quot;[reference(concat(resourceId('Microsoft.Compute/virtualMachines/', parameters('vmName')),'/providers/Microsoft.ManagedIdentity/Identities/default'),'2015-08-31-PREVIEW').principalId]&quot;,
                &quot;scope&quot;: &quot;[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', resourceGroup().name)]&quot;
            },
            &quot;dependsOn&quot;: [
                &quot;[resourceId('Microsoft.Compute/virtualMachines/extensions/', parameters('vmName'),'MSILinuxExtension')]&quot;
            ]
        },
        {
            &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
            &quot;name&quot;: &quot;[concat(parameters('vmName'),'/customscriptextension')]&quot;,
            &quot;apiVersion&quot;: &quot;2017-03-30&quot;,
            &quot;location&quot;: &quot;[parameters('location')]&quot;,
            &quot;properties&quot;: {
                &quot;publisher&quot;: &quot;Microsoft.Azure.Extensions&quot;,
                &quot;type&quot;: &quot;CustomScript&quot;,
                &quot;typeHandlerVersion&quot;: &quot;2.0&quot;,
                &quot;autoUpgradeMinorVersion&quot;: true,
                &quot;settings&quot;: {
                    &quot;fileUris&quot;: [
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/infra.sh', parameters('artifactsLocationSasToken'))]&quot;,
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/install.sh', parameters('artifactsLocationSasToken'))]&quot;,
                        &quot;[concat(parameters('artifactsLocation'), '/scripts/azureProviderAndCreds.tf', parameters('artifactsLocationSasToken'))]&quot;
                    ]
                },
                &quot;protectedSettings&quot;: {
                    &quot;commandToExecute&quot;: &quot;[concat('bash infra.sh &amp;&amp; bash install.sh ', variables('installParm1'), variables('installParm2'), variables('installParm3'), variables('installParm4'), ' -k ', listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('stateStorageAccountName')), '2017-10-01').keys[0].value, ' -l ', reference(concat(resourceId('Microsoft.Compute/virtualMachines/', parameters('vmName')),'/providers/Microsoft.ManagedIdentity/Identities/default'),'2015-08-31-PREVIEW').principalId)]&quot;
                }
            },
            &quot;dependsOn&quot;: [
                &quot;[resourceId('Microsoft.Authorization/roleAssignments', variables('resourceGuid'))]&quot;
            ]
        }
[snip]
</code></pre>

<h3 id="vmにログインし-環境を確認">VMにログインし、環境を確認</h3>

<p>では出来上がったVMにsshし、いろいろのぞいてみましょう。</p>

<pre><code>$ ssh your-vm-public-ip
</code></pre>

<p>Terraformのバージョンは、現時点で最新の0.11.5が入っています。</p>

<pre><code>$ terraform -v
Terraform v0.11.5
</code></pre>

<p>環境変数ARM_USE_MSIはtrueに設定されています。</p>

<pre><code>$ echo $ARM_USE_MSI
true
</code></pre>

<p>MSIも有効化されています(SystemAssigned)。</p>

<pre><code>$ az vm identity show -g tf-msi-poc-ejp-rg -n tfmsipocvm01
{
  &quot;additionalProperties&quot;: {},
  &quot;identityIds&quot;: null,
  &quot;principalId&quot;: &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot;,
  &quot;tenantId&quot;: &quot;tttt-tttt-tttt-tttt&quot;,
  &quot;type&quot;: &quot;SystemAssigned&quot;
}
</code></pre>

<p>さて、このVMはMSIが使えるようになったわけですが、操作できるリソースのスコープは、このVMが属するリソースグループに限定されてます。新たなリソースグループを作成したい場合は、ロールを付与し、スコープを広げます。~/にtfEnv.shというスクリプトが用意されています。用意されたスクリプトを実行すると、サブスクリプションスコープのContributorがVMに割り当てられます。必要に応じて変更しましょう。</p>

<pre><code>$ ls
tfEnv.sh  tfTemplate

$ cat tfEnv.sh
az login
az role assignment create  --assignee &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot; --role 'b24988ac-6180-42a0-ab88-20f7382dd24c'  --scope /subscriptions/&quot;cccc-cccc-cccc-cccc&quot;

$ . ~/tfEnv.sh
To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code HOGEHOGE to authenticate.
[snip]
{
  &quot;additionalProperties&quot;: {},
  &quot;canDelegate&quot;: null,
  &quot;id&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc/providers/Microsoft.Authorization/roleAssignments/ffff-ffff-ffff-ffff&quot;,
  &quot;name&quot;: &quot;ffff-ffff-ffff-ffff&quot;,
  &quot;principalId&quot;: &quot;aaaa-aaaa-aaaa-aaaa-aaaa&quot;,
  &quot;roleDefinitionId&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c&quot;,
  &quot;scope&quot;: &quot;/subscriptions/cccc-cccc-cccc-cccc&quot;,
  &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;
}
</code></pre>

<p>ちなみに、role id &ldquo;b24988ac-6180-42a0-ab88-20f7382dd24c&rdquo;はContributorを指します。</p>

<p>tfTemplateというディレクトリも用意されているようです。2つのファイルがあります。</p>

<pre><code>$ ls tfTemplate/
azureProviderAndCreds.tf  remoteState.tf
</code></pre>

<p>azureProviderAndCreds.tfは、tfファイルのテンプレートです。コメントアウトと説明のとおり、MSIを使う場合には、このテンプレートは必要ありません。subscription_idとtenant_idは、VMのプロビジョニング時に環境変数にセットされています。そしてclient_idとclient_secretは、MSIを通じて取得されます。明示的に変えたい時のみ指定しましょう。</p>

<pre><code>$ cat tfTemplate/azureProviderAndCreds.tf
#
#
# Provider and credential snippet to add to configurations
# Assumes that there's a terraform.tfvars file with the var values
#
# Uncomment the creds variables if using service principal auth
# Leave them commented to use MSI auth
#
#variable subscription_id {}
#variable tenant_id {}
#variable client_id {}
#variable client_secret {}

provider &quot;azurerm&quot; {
#    subscription_id = &quot;${var.subscription_id}&quot;
#    tenant_id = &quot;${var.tenant_id}&quot;
#    client_id = &quot;${var.client_id}&quot;
#    client_secret = &quot;${var.client_secret}&quot;
}
</code></pre>

<p>remoteState.tfは、TerraformのstateをAzureのBlob上に置く場合に使います。Blobの<a href="https://azure.microsoft.com/en-us/blog/soft-delete-for-azure-storage-blobs-now-in-public-preview/">soft delete</a>が使えるようになったこともあり、事件や事故を考慮すると、できればstateはローカルではなくBlobで管理したいところです。</p>

<pre><code>$ cat tfTemplate/remoteState.tf
terraform {
 backend &quot;azurerm&quot; {
  storage_account_name = &quot;storestaterandomid&quot;
  container_name       = &quot;terraform-state&quot;
  key                  = &quot;prod.terraform.tfstate&quot;
  access_key           = &quot;KYkCz88z+7yoyoyoiyoyoyoiyoyoyoiyoiTDZRbrwAWIPWD+rU6g==&quot;
  }
}
</code></pre>

<p>soft delete設定は、別途 <a href="https://docs.microsoft.com/en-us/cli/azure/storage/blob/service-properties/delete-policy?view=azure-cli-latest#az-storage-blob-service-properties-delete-policy-update">az storage blob service-properties delete-policy update</a> コマンドで行ってください。</p>

<h3 id="プロビジョニングしてみる">プロビジョニングしてみる</h3>

<p>ではTerraformを動かしてみましょう。サブディレクトリsampleを作り、そこで作業します。</p>

<pre><code>$ mkdir sample
$ cd sample/
</code></pre>

<p>stateはBlobで管理しましょう。先ほどのremoteState.tfを実行ディレクトリにコピーします。アクセスキーが入っていますので、このディレクトリをコード管理システム配下に置くのであれば、.gitignoreなどで除外をお忘れなく。</p>

<pre><code>$ cp ../tfTemplate/remoteState.tf ./
</code></pre>

<p>ここのキーが残ってしまうのが現時点での課題。ストレージのキー問題は<a href="https://feedback.azure.com/forums/217298-storage/suggestions/14831712-allow-user-based-access-to-blob-containers-for-su">対応がはじまったので</a>、いずれ解決するはずです。</p>

<p>ではTerraformで作るリソースを書きます。さくっとACI上にnginxコンテナーを作りましょう。</p>

<pre><code>$ vim main.tf
resource &quot;azurerm_resource_group&quot; &quot;tf-msi-poc&quot; {
    name     = &quot;tf-msi-poc-aci-wus-rg&quot;
    location = &quot;West US&quot;
}

resource &quot;random_integer&quot; &quot;random_int&quot; {
    min = 100
    max = 999
}

resource &quot;azurerm_container_group&quot; &quot;aci-example&quot; {
    name                = &quot;aci-cg-${random_integer.random_int.result}&quot;
    location            = &quot;${azurerm_resource_group.tf-msi-poc.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.tf-msi-poc.name}&quot;
    ip_address_type     = &quot;public&quot;
    dns_name_label      = &quot;tomakabe-aci-cg-${random_integer.random_int.result}&quot;
    os_type             = &quot;linux&quot;

    container {
        name    = &quot;nginx&quot;
        image   = &quot;nginx&quot;
        cpu     = &quot;0.5&quot;
        memory  = &quot;1.0&quot;
        port    = &quot;80&quot;
    }
}
</code></pre>

<p>init、plan、アプラーイ。アプライ王子。</p>

<pre><code>$ terraform init
$ terraform plan
$ terraform apply -auto-approve
[snip]
Apply complete! Resources: 3 added, 0 changed, 0 destroyed.
</code></pre>

<p>できたか確認。</p>

<pre><code>$ az container show -g tf-msi-poc-aci-wus-rg -n aci-cg-736 -o table
Name        ResourceGroup          ProvisioningState    Image    IP:ports         CPU/Memory       OsType    Location
----------  ---------------------  -------------------  -------  ---------------  ---------------  --------  ----------
aci-cg-736  tf-msi-poc-aci-wus-rg  Succeeded            nginx    13.91.90.117:80  0.5 core/1.0 gb  Linux     westus
$ curl 13.91.90.117
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
[snip]
</code></pre>

<h2 id="おまけ">おまけ</h2>

<p>サービスプリンシパルは、アプリに対して権限を付与するために必要な仕組みなのですが、使わなくなった際に消し忘れることが多いです。意識して消さないと、散らかり放題。</p>

<p>MSIの場合、対象のVMを消すとそのプリンシパルも消えます。爽快感ほとばしる。</p>

<pre><code>$ az ad sp show --id aaaa-aaaa-aaaa-aaaa-aaaa
Resource 'aaaa-aaaa-aaaa-aaaa-aaaa' does not exist or one of its queried reference-property objects are not present.
</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">26 Mar 2018, 00:08</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/az_vmss_terraform/" class="post-title">AzureのAvailability Zonesへ分散するVMSSをTerraformで作る</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="動機">動機</h2>

<p>Terraform Azure Provider 1.3.0で、VMSSを作る際にAvailability Zonesを指定できるように<a href="https://github.com/terraform-providers/terraform-provider-azurerm/pull/811">なりました</a>。Availability Zonesはインフラの根っこの仕組みなので、現在(<sup>2018</sup>&frasl;<sub>3</sub>)限定されたリージョンで長めのプレビュー期間がとられています。ですが、GAやグローバル展開を見据え、素振りしておきましょう。</p>

<h2 id="前提条件">前提条件</h2>

<ul>
<li>Availability Zones対応リージョンを選びます。現在は<a href="https://docs.microsoft.com/en-us/azure/availability-zones/az-overview#regions-that-support-availability-zones">5リージョン</a>です。この記事ではEast US 2とします。</li>
<li>Availability Zonesのプレビューに<a href="https://docs.microsoft.com/ja-jp/azure/availability-zones/az-overview">サインアップ</a>済みとします。</li>
<li>bashでsshの公開鍵が~/.ssh/id_rsa.pubにあると想定します。</li>
<li>動作確認した環境は以下です。

<ul>
<li>Terraform 0.11.2</li>
<li>Terraform Azure Provider 1.3.0</li>
<li>WSL (ubuntu 16.04)</li>
<li>macos (High Sierra 10.13.3)</li>
</ul></li>
</ul>

<h2 id="コード">コード</h2>

<p>以下のファイルを同じディレクトリに作成します。</p>

<h3 id="terraform-メインコード">Terraform メインコード</h3>

<p>VMSSと周辺リソースを作ります。</p>

<ul>
<li>最終行近くの &ldquo;zones = [1, 2, 3]&rdquo; がポイントです。これだけで、インスタンスを散らす先のゾーンを指定できます。</li>
<li>クロスゾーン負荷分散、冗長化するため、Load BalancerとパブリックIPのSKUをStandardにします。</li>
</ul>

<p>[main.tf]</p>

<pre><code>resource &quot;azurerm_resource_group&quot; &quot;poc&quot; {
  name     = &quot;${var.resource_group_name}&quot;
  location = &quot;East US 2&quot;
}

resource &quot;azurerm_virtual_network&quot; &quot;poc&quot; {
  name                = &quot;vnet01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;
  address_space       = [&quot;10.0.0.0/16&quot;]
}

resource &quot;azurerm_subnet&quot; &quot;poc&quot; {
  name                      = &quot;subnet01&quot;
  resource_group_name       = &quot;${azurerm_resource_group.poc.name}&quot;
  virtual_network_name      = &quot;${azurerm_virtual_network.poc.name}&quot;
  address_prefix            = &quot;10.0.2.0/24&quot;
  network_security_group_id = &quot;${azurerm_network_security_group.poc.id}&quot;
}

resource &quot;azurerm_network_security_group&quot; &quot;poc&quot; {
  name                = &quot;nsg01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;

  security_rule = [
    {
      name                       = &quot;allow_http&quot;
      priority                   = 100
      direction                  = &quot;Inbound&quot;
      access                     = &quot;Allow&quot;
      protocol                   = &quot;Tcp&quot;
      source_port_range          = &quot;*&quot;
      destination_port_range     = &quot;80&quot;
      source_address_prefix      = &quot;*&quot;
      destination_address_prefix = &quot;*&quot;
    },
    {
      name                       = &quot;allow_ssh&quot;
      priority                   = 101
      direction                  = &quot;Inbound&quot;
      access                     = &quot;Allow&quot;
      protocol                   = &quot;Tcp&quot;
      source_port_range          = &quot;*&quot;
      destination_port_range     = &quot;22&quot;
      source_address_prefix      = &quot;*&quot;
      destination_address_prefix = &quot;*&quot;
    },
  ]
}

resource &quot;azurerm_public_ip&quot; &quot;poc&quot; {
  name                         = &quot;pip01&quot;
  resource_group_name          = &quot;${azurerm_resource_group.poc.name}&quot;
  location                     = &quot;${azurerm_resource_group.poc.location}&quot;
  public_ip_address_allocation = &quot;static&quot;
  domain_name_label            = &quot;${var.scaleset_name}&quot;

  sku = &quot;Standard&quot;
}

resource &quot;azurerm_lb&quot; &quot;poc&quot; {
  name                = &quot;lb01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;

  frontend_ip_configuration {
    name                 = &quot;fipConf01&quot;
    public_ip_address_id = &quot;${azurerm_public_ip.poc.id}&quot;
  }

  sku = &quot;Standard&quot;
}

resource &quot;azurerm_lb_backend_address_pool&quot; &quot;poc&quot; {
  name                = &quot;bePool01&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id     = &quot;${azurerm_lb.poc.id}&quot;
}

resource &quot;azurerm_lb_rule&quot; &quot;poc&quot; {
  name                           = &quot;lbRule&quot;
  resource_group_name            = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id                = &quot;${azurerm_lb.poc.id}&quot;
  protocol                       = &quot;Tcp&quot;
  frontend_port                  = 80
  backend_port                   = 80
  frontend_ip_configuration_name = &quot;fipConf01&quot;
  backend_address_pool_id        = &quot;${azurerm_lb_backend_address_pool.poc.id}&quot;
  probe_id                       = &quot;${azurerm_lb_probe.poc.id}&quot;
}

resource &quot;azurerm_lb_probe&quot; &quot;poc&quot; {
  name                = &quot;http-probe&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id     = &quot;${azurerm_lb.poc.id}&quot;
  port                = 80
}

resource &quot;azurerm_lb_nat_pool&quot; &quot;poc&quot; {
  count                          = 3
  name                           = &quot;ssh&quot;
  resource_group_name            = &quot;${azurerm_resource_group.poc.name}&quot;
  loadbalancer_id                = &quot;${azurerm_lb.poc.id}&quot;
  protocol                       = &quot;Tcp&quot;
  frontend_port_start            = 50000
  frontend_port_end              = 50119
  backend_port                   = 22
  frontend_ip_configuration_name = &quot;fipConf01&quot;
}

data &quot;template_cloudinit_config&quot; &quot;poc&quot; {
  gzip          = true
  base64_encode = true

  part {
    content_type = &quot;text/cloud-config&quot;
    content      = &quot;${file(&quot;${path.module}/cloud-config.yaml&quot;)}&quot;
  }
}

resource &quot;azurerm_virtual_machine_scale_set&quot; &quot;poc&quot; {
  name                = &quot;${var.scaleset_name}&quot;
  resource_group_name = &quot;${azurerm_resource_group.poc.name}&quot;
  location            = &quot;${azurerm_resource_group.poc.location}&quot;
  upgrade_policy_mode = &quot;Manual&quot;

  sku {
    name     = &quot;Standard_B1s&quot;
    tier     = &quot;Standard&quot;
    capacity = 3
  }

  storage_profile_image_reference {
    publisher = &quot;Canonical&quot;
    offer     = &quot;UbuntuServer&quot;
    sku       = &quot;16.04-LTS&quot;
    version   = &quot;latest&quot;
  }

  storage_profile_os_disk {
    name              = &quot;&quot;
    caching           = &quot;ReadWrite&quot;
    create_option     = &quot;FromImage&quot;
    managed_disk_type = &quot;Standard_LRS&quot;
  }

  os_profile {
    computer_name_prefix = &quot;pocvmss&quot;
    admin_username       = &quot;${var.admin_username}&quot;
    admin_password       = &quot;&quot;
    custom_data          = &quot;${data.template_cloudinit_config.poc.rendered}&quot;
  }

  os_profile_linux_config {
    disable_password_authentication = true

    ssh_keys {
      path     = &quot;/home/${var.admin_username}/.ssh/authorized_keys&quot;
      key_data = &quot;${file(&quot;~/.ssh/id_rsa.pub&quot;)}&quot;
    }
  }

  network_profile {
    name    = &quot;terraformnetworkprofile&quot;
    primary = true

    ip_configuration {
      name                                   = &quot;PoCIPConfiguration&quot;
      subnet_id                              = &quot;${azurerm_subnet.poc.id}&quot;
      load_balancer_backend_address_pool_ids = [&quot;${azurerm_lb_backend_address_pool.poc.id}&quot;]
      load_balancer_inbound_nat_rules_ids    = [&quot;${element(azurerm_lb_nat_pool.poc.*.id, count.index)}&quot;]
    }
  }

  zones = [1, 2, 3]
}
</code></pre>

<h3 id="cloud-init-configファイル">cloud-init configファイル</h3>

<p>各インスタンスがどのゾーンで動いているか確認したいので、インスタンス作成時にcloud-initでWebサーバーを仕込みます。メタデータからインスタンス名と実行ゾーンを引っ張り、nginxのドキュメントルートに書きます。</p>

<p>[cloud-config.yaml]</p>

<pre><code>#cloud-config
package_upgrade: true
packages:
  - nginx
runcmd:
  - 'echo &quot;[Instance Name]: `curl -H Metadata:true &quot;http://169.254.169.254/metadata/instance/compute/name?api-version=2017-12-01&amp;format=text&quot;`    [Zone]: `curl -H Metadata:true &quot;http://169.254.169.254/metadata/instance/compute/zone?api-version=2017-12-01&amp;format=text&quot;`&quot; &gt; /var/www/html/index.nginx-debian.html'
</code></pre>

<p>インスタンス作成時、パッケージの導入やアップデートに時間をかけたくない場合は、Packerなどで前もってカスタムイメージを作っておくのも手です。</p>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/linux/build-image-with-packer">Packer を使用して Azure に Linux 仮想マシンのイメージを作成する方法</a></li>
<li><a href="https://docs.microsoft.com/ja-jp/azure/terraform/terraform-create-vm-scaleset-network-disks-using-packer-hcl">Terraform を使用して Packer カスタム イメージから Azure 仮想マシン スケール セットを作成する</a></li>
</ul>

<h3 id="terraform-変数ファイル">Terraform 変数ファイル</h3>

<p>変数は別ファイルへ。</p>

<p>[variables.tf]</p>

<pre><code>variable &quot;resource_group_name&quot; {
  default = &quot;your-rg&quot;
}

variable &quot;scaleset_name&quot; {
  default = &quot;yourvmss01&quot;
}

variable &quot;admin_username&quot; {
  default = &quot;yourname&quot;
}
</code></pre>

<h2 id="実行">実行</h2>

<p>では実行。</p>

<pre><code>$ terraform init
$ terraform plan
$ terraform apply
</code></pre>

<p>5分くらいで完了しました。このサンプルでは、この後のcloud-initのパッケージ処理に時間がかかります。待てない場合は前述の通り、カスタムイメージを使いましょう。</p>

<p>インスタンスへのsshを通すよう、Load BalancerにNATを設定していますので、cloud-initの進捗は確認できます。</p>

<pre><code>$ ssh -p 50000 yourname@yourvmss01.eastus2.cloudapp.azure.com
$ tail -f /var/log/cloud-init-output.log
Cloud-init v. 17.1 finished at Sun, 25 Mar 2018 10:41:40 +0000. Datasource DataSourceAzure [seed=/dev/sr0].  Up 611.51 seconds
</code></pre>

<p>ではWebサーバーにアクセスしてみましょう。</p>

<pre><code>$ while true; do curl yourvmss01.eastus2.cloudapp.azure.com; sleep 1; done;
[Instance Name]: yourvmss01_2    [Zone]: 3
[Instance Name]: yourvmss01_0    [Zone]: 1
[Instance Name]: yourvmss01_2    [Zone]: 3
[Instance Name]: yourvmss01_1    [Zone]: 2
</code></pre>

<p>VMSSのインスタンスがゾーンに分散されたことが分かります。</p>

<p>では、このままスケールアウトしてみましょう。main.tfのazurerm_virtual_machine_scale_set.poc.sku.capacityを3から4にし、再度applyします。</p>

<pre><code>[Instance Name]: yourvmss01_1    [Zone]: 2
[Instance Name]: yourvmss01_3    [Zone]: 1
[Instance Name]: yourvmss01_3    [Zone]: 1
[Instance Name]: yourvmss01_1    [Zone]: 2
[Instance Name]: yourvmss01_3    [Zone]: 1
</code></pre>

<p>ダウンタイムなしに、yourvmss01_3が追加されました。すこぶる簡単。</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 3</span>
    
      <a href="/tags/terraform/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
