<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>re-imagine</title>
    <link>http://torumakabe.github.io/index.xml</link>
    <description>Recent content on re-imagine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 05 Sep 2017 12:00:00 +0900</lastBuildDate>
    <atom:link href="http://torumakabe.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Azure Event GridでBlobイベントを拾う</title>
      <link>http://torumakabe.github.io/post/azure_blobevent/</link>
      <pubDate>Tue, 05 Sep 2017 12:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_blobevent/</guid>
      <description>

&lt;h2 id=&#34;event-gridがblobに対応&#34;&gt;Event GridがBlobに対応&lt;/h2&gt;

&lt;p&gt;Event GridがBlobのイベントを拾えるように&lt;a href=&#34;https://azure.microsoft.com/en-us/blog/announcing-azure-blob-storage-events-preview/&#34;&gt;なりました&lt;/a&gt;。まだ申請が必要なプライベートプレビュー段階ですが、使い勝手の良いサービスに育つ予感がします。このたび検証する機会があったので、共有を。&lt;/p&gt;

&lt;p&gt;プレビュー中なので、今後仕様が変わるかもしれないこと、不具合やメンテナンス作業の可能性などは、ご承知おきください。&lt;/p&gt;

&lt;h2 id=&#34;event-gridがblobに対応して何がうれしいか&#34;&gt;Event GridがBlobに対応して何がうれしいか&lt;/h2&gt;

&lt;p&gt;Event Gridは、Azureで発生した様々なイベントを検知してWebhookで通知するサービスです。カスタムトピックも作成できます。&lt;/p&gt;

&lt;p&gt;イベントの発生元をPublisherと呼びますが、このたびPublisherとしてAzureのBlobがサポートされました。Blobの作成、削除イベントを検知し、Event GridがWebhookで通知します。通知先はHandlerと呼びます。Publisherとそこで拾うイベント、Handlerを紐づけるのがSubscriptionです。Subscriptionにはフィルタも定義できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ff3644c9-58ab-4729-8939-66a83ab0605d.png&#34; alt=&#34;コンセプト&#34; title=&#34;Concept&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Event Gridに期待する理由はいくつかあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;フィルタ

&lt;ul&gt;
&lt;li&gt;特定のBlobコンテナーにあるjpegファイルの作成イベントのみで発火させる、なんてことができます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;信頼性

&lt;ul&gt;
&lt;li&gt;リトライ機能があるので、Handlerが一時的に黙ってしまっても対応できます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;スケールと高スループット

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/azure-functions/functions-bindings-storage-blob#blob-storage-triggers-and-bindings&#34;&gt;Azure Functions Blobトリガー&lt;/a&gt;のようにHandler側で定期的にスキャンする必要がありません。これまではファイル数が多いとつらかった&lt;/li&gt;
&lt;li&gt;具体的な数値はプレビュー後に期待しましょう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ファンアウト

&lt;ul&gt;
&lt;li&gt;ひとつのイベントを複数のHandlerに紐づけられます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Azureの外やサードパーティーとの連携

&lt;ul&gt;
&lt;li&gt;Webhookでシンプルにできます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前提条件&#34;&gt;前提条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Publisherに設定できるストレージアカウントはBlobストレージアカウントのみです。汎用ストレージアカウントは対応していません&lt;/li&gt;
&lt;li&gt;現時点ではWest Central USリージョンのみで提供しています&lt;/li&gt;
&lt;li&gt;プライベートプレビューは申請が必要です&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Azure CLIの下記コマンドでプレビューに申請できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;az provider register --namespace  Microsoft.EventGrid
az feature register --name storageEventSubscriptions --namespace Microsoft.EventGrid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のコマンドで確認し、statusが&amp;rdquo;Registered&amp;rdquo;であれば使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;az feature show --name storageEventSubscriptions --namespace Microsoft.EventGrid
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;ストレージアカウントの作成からSubscription作成までの流れを追ってみましょう。&lt;/p&gt;

&lt;p&gt;リソースグループを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az group create -n blobeventpoc-rg -l westcentralus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Blobストレージアカウントを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az storage account create -n blobeventpoc01 -l westcentralus -g blobeventpoc-rg --sku Standard_LRS --kind BlobStorage --access-tier Hot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではいよいよEvent GridのSubscriptionを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az eventgrid resource event-subscription create --endpoint https://requestb.in/y4jgj2x0 -n blobeventpocsub-jpg --prov
ider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types Microsoft.Storage.BlobCreated
-g blobeventpoc-rg --resource-name blobeventpoc01 --subject-ends-with jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下はパラメーターの補足です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;endpoint

&lt;ul&gt;
&lt;li&gt;Handlerのエンドポイントを指定します。ここではテストのために&lt;a href=&#34;https://requestb.in/&#34;&gt;RequestBin&lt;/a&gt;に作ったエンドポイントを指定します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&amp;ndash;included-event-types

&lt;ul&gt;
&lt;li&gt;イベントの種類をフィルタします。Blobの削除イベントは不要で、作成のみ拾いたいため、Microsoft.Storage.BlobCreatedを指定します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&amp;ndash;subject-ends-with

&lt;ul&gt;
&lt;li&gt;対象ファイルをフィルタします。Blob名の末尾文字列がjpgであるBlobのみイベントの対象にしました&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では作成したストレージアカウントにBlobコンテナーを作成し、jpgファイルを置いてみましょう。テストには&lt;a href=&#34;https://azure.microsoft.com/ja-jp/features/storage-explorer/&#34;&gt;Azure Storage Explorer&lt;/a&gt;が便利です。&lt;/p&gt;

&lt;p&gt;RequestBinにWebhookが飛び、中身を見られます。スキーマの確認は&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-event-overview#event-schema&#34;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
  &amp;quot;topic&amp;quot;: &amp;quot;/subscriptions/xxxxx-xxxxx-xxxxx-xxxxx/resourceGroups/blobeventpoc-rg/providers/Microsoft.Storage/storageAccounts/blobeventpoc01&amp;quot;,
  &amp;quot;subject&amp;quot;: &amp;quot;/blobServices/default/containers/images/blobs/handsomeyoungman.jpg&amp;quot;,
  &amp;quot;eventType&amp;quot;: &amp;quot;Microsoft.Storage.BlobCreated&amp;quot;,
  &amp;quot;eventTime&amp;quot;: &amp;quot;2017-09-02T02:25:15.2635962Z&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;f3ff6b96-001e-001d-6e92-23bdea0684d2&amp;quot;,
  &amp;quot;data&amp;quot;: {
    &amp;quot;api&amp;quot;: &amp;quot;PutBlob&amp;quot;,
    &amp;quot;clientRequestId&amp;quot;: &amp;quot;f3cab560-8f85-11e7-bad1-53b58c70ab53&amp;quot;,
    &amp;quot;requestId&amp;quot;: &amp;quot;f3ff6b96-001e-001d-6e92-23bdea000000&amp;quot;,
    &amp;quot;eTag&amp;quot;: &amp;quot;0x8D4F1A9D8A6703A&amp;quot;,
    &amp;quot;contentType&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
    &amp;quot;contentLength&amp;quot;: 42497,
    &amp;quot;blobType&amp;quot;: &amp;quot;BlockBlob&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://blobeventpoc01.blob.core.windows.net/images/handsomeyoungman.jpg&amp;quot;,
    &amp;quot;sequencer&amp;quot;: &amp;quot;0000000000000BAB0000000000060986&amp;quot;,
    &amp;quot;storageDiagnostics&amp;quot;: {
      &amp;quot;batchId&amp;quot;: &amp;quot;f3a538cf-5b88-4bbf-908a-20a37c65e238&amp;quot;
    }
  }
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.jpgだけじゃなくて.jpegも使われるかもしれませんね。ということで、エンドポイントが同じでフィルタ定義を変えたSubscriptionを追加します。&amp;ndash;subject-ends-withをjpegとします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az eventgrid resource event-subscription create --endpoint https://requestb.in/y0jbj1y0 -n blobeventpocsub-jpeg --pro
vider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types Microsoft.Storage.BlobCreated -
g blobeventpoc-rg --resource-name blobeventpoc01 --subject-ends-with jpeg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、拡張子.jpegのファイルをアップロードしても発火しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
  &amp;quot;topic&amp;quot;: &amp;quot;/subscriptions/xxxxx-xxxxx-xxxxx-xxxxx/resourceGroups/blobeventpoc-rg/providers/Microsoft.Storage/storageAccounts/blobeventpoc01&amp;quot;,
  &amp;quot;subject&amp;quot;: &amp;quot;/blobServices/default/containers/images/blobs/handsomeyoungman.jpeg&amp;quot;,
  &amp;quot;eventType&amp;quot;: &amp;quot;Microsoft.Storage.BlobCreated&amp;quot;,
  &amp;quot;eventTime&amp;quot;: &amp;quot;2017-09-02T02:36:33.827967Z&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;e8b036ee-001e-00e7-4994-23740d06225b&amp;quot;,
  &amp;quot;data&amp;quot;: {
    &amp;quot;api&amp;quot;: &amp;quot;PutBlob&amp;quot;,
    &amp;quot;clientRequestId&amp;quot;: &amp;quot;883ff7e0-8f87-11e7-bad1-53b58c70ab53&amp;quot;,
    &amp;quot;requestId&amp;quot;: &amp;quot;e8b036ee-001e-00e7-4994-23740d000000&amp;quot;,
    &amp;quot;eTag&amp;quot;: &amp;quot;0x8D4F1AB6D1B24F6&amp;quot;,
    &amp;quot;contentType&amp;quot;: &amp;quot;image/jpeg&amp;quot;,
    &amp;quot;contentLength&amp;quot;: 42497,
    &amp;quot;blobType&amp;quot;: &amp;quot;BlockBlob&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://blobeventpoc01.blob.core.windows.net/images/handsomeyoungman.jpeg&amp;quot;,
    &amp;quot;sequencer&amp;quot;: &amp;quot;0000000000000BAB0000000000060D42&amp;quot;,
    &amp;quot;storageDiagnostics&amp;quot;: {
      &amp;quot;batchId&amp;quot;: &amp;quot;9ec5c091-061d-4111-ad82-52d9803ce373&amp;quot;
    }
  }
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;azure-functionsに画像リサイズファンクションを作って連携してみる&#34;&gt;Azure Functionsに画像リサイズファンクションを作って連携してみる&lt;/h2&gt;

&lt;p&gt;Gvent Grid側の動きが確認できたので、サンプルアプリを作って検証してみましょう。Azure Functions上に画像ファイルのサイズを変えるHandlerアプリを作ってみます。&lt;/p&gt;

&lt;h3 id=&#34;概要&#34;&gt;概要&lt;/h3&gt;

&lt;p&gt;当初想定したのは、ひとつのファンクションで、トリガーはEventGrid、入出力バインドにBlob、という作りでした。ですが、以下のように設計を変えました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ToruMakabe/Images/master/blobevent-function-bindings.png&#34; alt=&#34;Bindings&#34; title=&#34;Bindings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using &lt;a href=&#34;https://functions-visualizer.azurewebsites.net/&#34;&gt;Azure Functions Bindings Visualizer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;その理由はEvent Grid Blobイベントのペイロードです。Blobファイル名がURLで渡されます。Azure FunctionsのBlob入出力バインド属性、&amp;rdquo;path&amp;rdquo;にURLは使えません。使えるのはコンテナー名+ファイル名です。&lt;/p&gt;

&lt;p&gt;入出力バインドを使わず、アプリのロジック内でStorage SDKを使って入出力してもいいのですが、Azure Functionsの魅力のひとつは宣言的にトリガーとバインドを定義し、アプリをシンプルに書けることなので、あまりやりたくないです。&lt;/p&gt;

&lt;p&gt;そこでイベントを受けてファイル名を取り出してQueueに入れるファンクションと、そのQueueをトリガーに画像をリサイズするファンクションに分けました。&lt;/p&gt;

&lt;p&gt;なお、この悩みはAzureの開発チームも認識しており、Functions側で対応する方針とのことです。&lt;/p&gt;

&lt;h3 id=&#34;handler&#34;&gt;Handler&lt;/h3&gt;

&lt;p&gt;C#(csx)で、Event GridからのWebhookを受けるHandlerを作ります。PublisherがBlobの場合、ペイロードにBlobのURLが入っていますので、そこからファイル名を抽出します。そして、そのファイル名をQueueに送ります。ファンクション名はBlobEventHandlerとしました。&lt;/p&gt;

&lt;p&gt;[run.csx]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#r &amp;quot;Newtonsoft.json&amp;quot;
using Microsoft.Azure.WebJobs.Extensions.EventGrid;

public static void Run(EventGridEvent eventGridEvent, out string outputQueueItem, TraceWriter log)
{
    string imageUrl = eventGridEvent.Data[&amp;quot;url&amp;quot;].ToString();
    outputQueueItem = System.IO.Path.GetFileName(imageUrl);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Event GridのWebJobs拡張向けパッケージを指定します。&lt;/p&gt;

&lt;p&gt;[project.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&amp;quot;frameworks&amp;quot;: {
  &amp;quot;net46&amp;quot;:{
    &amp;quot;dependencies&amp;quot;: {
      &amp;quot;Microsoft.Azure.WebJobs.Extensions.EventGrid&amp;quot;: &amp;quot;1.0.0-beta1-10006&amp;quot;
    }
  }
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トリガーとバインドは以下の通りです。&lt;/p&gt;

&lt;p&gt;[function.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;bindings&amp;quot;: [
    {
      &amp;quot;type&amp;quot;: &amp;quot;eventGridTrigger&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;eventGridEvent&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;in&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;queue&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;outputQueueItem&amp;quot;,
      &amp;quot;queueName&amp;quot;: &amp;quot;imagefilename&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;AzureWebJobsStorage&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;out&amp;quot;
    }
  ],
  &amp;quot;disabled&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resizer&#34;&gt;Resizer&lt;/h3&gt;

&lt;p&gt;Queueをトリガーに、Blobから画像ファイルを取り出し、縮小、出力するファンクションを作ります。ファンクション名はResizerとしました。&lt;/p&gt;

&lt;p&gt;[run.csx]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using ImageResizer;

public static void Run(string myQueueItem, Stream inputBlob, Stream outputBlob, TraceWriter log)
{
  var imageBuilder = ImageResizer.ImageBuilder.Current;
  var size = imageDimensionsTable[ImageSize.Small];

  imageBuilder.Build(inputBlob, outputBlob,
    new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);

}

public enum ImageSize
{
  Small
}

private static Dictionary&amp;lt;ImageSize, Tuple&amp;lt;int, int&amp;gt;&amp;gt; imageDimensionsTable = new Dictionary&amp;lt;ImageSize, Tuple&amp;lt;int, int&amp;gt;&amp;gt;()
{
  { ImageSize.Small, Tuple.Create(100, 100) }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImageResizerのパッケージを指定します。&lt;/p&gt;

&lt;p&gt;[project.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
&amp;quot;frameworks&amp;quot;: {
  &amp;quot;net46&amp;quot;:{
    &amp;quot;dependencies&amp;quot;: {
      &amp;quot;ImageResizer&amp;quot;: &amp;quot;4.1.9&amp;quot;
    }
  }
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トリガーとバインドは以下の通りです。{QueueTrigger}メタデータで、QueueのペイロードをBlobのpathに使います。ペイロードにはファイル名が入っています。&lt;/p&gt;

&lt;p&gt;また、画像を保存するBlobストレージアカウントの接続文字列は、環境変数BLOB_IMAGESへ事前に設定しています。なお、リサイズ後の画像を格納するBlobコンテナーは、&amp;rdquo;images-s&amp;rdquo;として別途作成しました。コンテナー&amp;rdquo;images&amp;rdquo;をイベントの発火対象コンテナーとして、Subscriptionにフィルタを定義したいからです。&lt;/p&gt;

&lt;p&gt;[function.json]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;bindings&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;myQueueItem&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;queueTrigger&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;in&amp;quot;,
      &amp;quot;queueName&amp;quot;: &amp;quot;imagefilename&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;AzureWebJobsStorage&amp;quot;
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;inputBlob&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;blob&amp;quot;,
      &amp;quot;path&amp;quot;: &amp;quot;images/{QueueTrigger}&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;BLOB_IMAGES&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;in&amp;quot;
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;outputBlob&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;blob&amp;quot;,
      &amp;quot;path&amp;quot;: &amp;quot;images-s/{QueueTrigger}&amp;quot;,
      &amp;quot;connection&amp;quot;: &amp;quot;BLOB_IMAGES&amp;quot;,
      &amp;quot;direction&amp;quot;: &amp;quot;out&amp;quot;
    }
  ],
  &amp;quot;disabled&amp;quot;: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handlerの準備が整いました。最後にEvent GridのSubscriptionを作成します。Azure FunctionsのBlobEventHandlerのトークン付きエンドポイントは、ポータルの[統合]で確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az eventgrid resource event-subscription create --endpoint &amp;quot;https://blobeventpoc.azurewebsites.net/admin/exte
nsions/EventGridExtensionConfig?functionName=BlobEventHandler&amp;amp;code=tokenTOKEN1234567890==&amp;quot; -n blobeventpocsub-jpg --provider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types &amp;quot;Microsoft.Storage.BlobCreated&amp;quot; -g blobeventpoc-rg --resource-name blobeventpoc01 --subject-begins-with &amp;quot;/blobServices/default/containers/images/&amp;quot;  --subject-ends-with jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、コンテナー&amp;rdquo;images&amp;rdquo;にjpgファイルがアップロードされると、コンテナー&amp;rdquo;images-s&amp;rdquo;に、リサイズされた同じファイル名の画像ファイルが出来上がります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azureでグローバルにデータをコピーするとどのくらい時間がかかるのか</title>
      <link>http://torumakabe.github.io/post/azureblobcopy_perf/</link>
      <pubDate>Tue, 13 Jun 2017 17:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azureblobcopy_perf/</guid>
      <description>

&lt;h2 id=&#34;ファイルコピーの需要は根強い&#34;&gt;ファイルコピーの需要は根強い&lt;/h2&gt;

&lt;p&gt;グローバルでAzureを使うとき、データをどうやって同期、複製するかは悩みの種です。Cosmos DBなどリージョン間でデータ複製してくれるサービスを使うのが、楽ですし、おすすめです。&lt;/p&gt;

&lt;p&gt;でも、ファイルコピーを無くせないもろもろの事情もあります。となると、「地球の裏側へのファイルコピーに、どんだけ時間かかるのよ」は、課題です。&lt;/p&gt;

&lt;h2 id=&#34;調べてみた&#34;&gt;調べてみた&lt;/h2&gt;

&lt;p&gt;ということで、いくつかのパターンで調べたので参考までに。測定環境は以下の通り。&lt;/p&gt;

&lt;h3 id=&#34;ツールと実行環境&#34;&gt;ツールと実行環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AzCopy 6.1.0&lt;/li&gt;
&lt;li&gt;Azure PowerShell 4.1.0&lt;/li&gt;
&lt;li&gt;Windows 10 1703&lt;/li&gt;
&lt;li&gt;ThinkPad X1 Carbon 2017, Core i7-7600U 2.8GHz, 16GB Memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;アクセス回線パターン&#34;&gt;アクセス回線パターン&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一般的な回線&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自宅(川崎)&lt;/li&gt;
&lt;li&gt;OCN光 100M マンションタイプ&lt;/li&gt;
&lt;li&gt;宅内は802.11ac(5GHz)&lt;/li&gt;
&lt;li&gt;川崎でアクセス回線に入り、横浜(保土ヶ谷)の局舎からインターネットへ&lt;/li&gt;
&lt;li&gt;ゲートウェイ名から推測&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;いい感じの回線&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;日本マイクロソフト 品川オフィス&lt;/li&gt;
&lt;li&gt;1Gbps 有線&lt;/li&gt;
&lt;li&gt;Azureデータセンターへ「ネットワーク的に近くて広帯域」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;コピーするファイル&#34;&gt;コピーするファイル&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;総容量: 約60GB

&lt;ul&gt;
&lt;li&gt;6160ファイル&lt;/li&gt;
&lt;li&gt;1MB * 5000, 10MB * 1000, 100MB * 100, 500MB * 50, 1000MB * 10&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux fallocateコマンドで作成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ファイル形式パターン&#34;&gt;ファイル形式パターン&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;ファイル、Blobそのまま送る (6160ファイル)&lt;/li&gt;
&lt;li&gt;ディスクイメージで送る (1ファイル)

&lt;ul&gt;
&lt;li&gt;Managed Diskとしてアタッチした100GBの領域にファイルシステムを作成し、6160ファイルを配置&lt;/li&gt;
&lt;li&gt;転送前にデタッチ、エクスポート(Blob SAS形式)&lt;/li&gt;
&lt;li&gt;AzCopyではなくAzure PowerShellでコピー指示 (AzCopyにBlob SAS指定オプションが見当たらなかった)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;対象のazureリージョン&#34;&gt;対象のAzureリージョン&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;東日本 (マスター、複製元と位置づける)&lt;/li&gt;
&lt;li&gt;米国中南部 (太平洋越え + 米国内を見たい)&lt;/li&gt;
&lt;li&gt;ブラジル南部&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;転送パターン&#34;&gt;転送パターン&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ユーザー拠点の端末からAzureリージョン: AzCopy Upload&lt;/li&gt;
&lt;li&gt;Azureリージョン間 (Storage to Storage)

&lt;ul&gt;
&lt;li&gt;ファイル: AzCopy Copy&lt;/li&gt;
&lt;li&gt;イメージ: PowerShell Start-AzureStorageBlobCopy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;形式　&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;コピー元　　　　　&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;コピー先　　　　　　　　&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;コマンド　&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;　並列数&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;　実行時間(時:分:秒)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自宅&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 東日本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Upload&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;07:55:22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自宅&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 米国中南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Upload&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10:22:30&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自宅&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure ブラジル南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Upload&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12:46:37&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;オフィス&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 東日本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Upload&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;00:20:47&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;オフィス&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 米国中南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Upload&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;00:45.11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;オフィス&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure ブラジル南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Upload&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;02:07.58&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 東日本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 米国中南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Copy&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;N/A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;00:28:55&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;イメージ　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 東日本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 米国中南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PowerShell&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;N/A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;00:11:11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ファイル　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 東日本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure ブラジル南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AzCopy Copy&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;N/A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;00.25:33&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;イメージ　&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure 東日本&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Azure ブラジル南部&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PowerShell&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;N/A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;00.09:20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;考察&#34;&gt;考察&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;アクセス回線の差が大きく影響&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自宅パターンでプロバイダから帯域制限されていたかは不明 (自宅からAzure東日本まで16Mbpsくらいは出た)&lt;/li&gt;
&lt;li&gt;アクセス回線が細い場合はユーザー拠点から「まとめて」送らないほうがいい&lt;/li&gt;
&lt;li&gt;こまめに送る&lt;/li&gt;
&lt;li&gt;Azure内でデータを生成する&lt;/li&gt;
&lt;li&gt;もしくはExpressRouteを引く (自宅で、とは言っていない)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;アクセス回線が細い場合、AzCopy Uploadの並列数を下げる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AzCopyのデフォルト並列数は実行環境のCPUコア数 *8だが、今回実施した端末での並列数(4コア * 8 = 32)ではかえって性能が劣化した&lt;/li&gt;
&lt;li&gt;アクセス回線に合わせて並列数は調整する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azureのリージョン間コピーは早い&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Azureバックボーンを通るから&lt;/li&gt;
&lt;li&gt;端末よりAzureストレージのほうがリソース的に強いし負荷分散しているから&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;地理的な距離感覚だけで考えてはダメ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;地理的な近さではなく、ネットワーク的な近さと太さ&lt;/li&gt;
&lt;li&gt;Azureバックボーンを使うと日本とブラジルの間でもそれなりのスループット&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファイル数が多いときはイメージで送るのも手&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ファイル数がコピー時間に影響する (1 vs 6160)&lt;/li&gt;
&lt;li&gt;そもそもアプリがBlobとして使うのか、ファイルシステムとして使うかにもよるが&amp;hellip;&lt;/li&gt;
&lt;li&gt;もしファイルシステムとして、であれば有効な手段&lt;/li&gt;
&lt;li&gt;エクスポートのひと手間は考慮&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azureバックボーンを使うと、意外にブラジル近い&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;土管か(ない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Azureバックボーンの帯域にはSLAがありませんが、意識して仕組みを作ると得をします。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azureユーザー視点のLatency測定 2017/4版</title>
      <link>http://torumakabe.github.io/post/azure_latency/</link>
      <pubDate>Sun, 09 Apr 2017 15:15:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_latency/</guid>
      <description>

&lt;h2 id=&#34;関東の片隅で遅延を測る&#34;&gt;関東の片隅で遅延を測る&lt;/h2&gt;

&lt;p&gt;Twitterで「東阪の遅延って最近どのくらい？」と話題になっていたので。首都圏のAzureユーザー視線で測定しようと思います。&lt;/p&gt;

&lt;p&gt;せっかくなので、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;太平洋のそれも測定しましょう&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/blog/how-microsoft-builds-its-fast-and-reliable-global-network/&#34;&gt;Azureバックボーンを通るリージョン間通信&lt;/a&gt;も測りましょう&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;計測パターン&#34;&gt;計測パターン&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;自宅(神奈川) -&amp;gt; OCN光 -&amp;gt; インターネット -&amp;gt; Azure東日本リージョン&lt;/li&gt;
&lt;li&gt;自宅(神奈川) -&amp;gt; OCN光 -&amp;gt; インターネット -&amp;gt; Azure西日本リージョン&lt;/li&gt;
&lt;li&gt;自宅(神奈川) -&amp;gt; OCN光 -&amp;gt; インターネット -&amp;gt; Azure米国西海岸リージョン&lt;/li&gt;
&lt;li&gt;Azure東日本リージョン -&amp;gt; Azureバックボーン -&amp;gt; Azure西日本リージョン&lt;/li&gt;
&lt;li&gt;Azure東日本リージョン -&amp;gt; Azureバックボーン -&amp;gt; Azure米国西海岸リージョン&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;もろもろの条件&#34;&gt;もろもろの条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;遅延測定ツール

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://technet.microsoft.com/en-us/sysinternals/psping.aspx&#34;&gt;PsPing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Azure各リージョンにD1_v2/Windows Server 2016仮想マシンを作成しPsPing&lt;/li&gt;
&lt;li&gt;NSGでデフォルト許可されているRDPポートへのPsPing&lt;/li&gt;
&lt;li&gt;VPN接続せず、パブリックIPへPsPing&lt;/li&gt;
&lt;li&gt;リージョン間PsPingは仮想マシンから仮想マシンへ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自宅Wi-Fi環境

&lt;ul&gt;
&lt;li&gt;802.11ac(5GHz)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自宅加入インターネット接続サービス

&lt;ul&gt;
&lt;li&gt;OCN 光 マンション 100M&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OCNゲートウェイ

&lt;ul&gt;
&lt;li&gt;(ほげほげ)hodogaya.kanagawa.ocn.ne.jp&lt;/li&gt;
&lt;li&gt;神奈川県横浜市保土ケ谷区の局舎からインターネットに出ているようです&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;米国リージョン

&lt;ul&gt;
&lt;li&gt;US WEST (カリフォルニア)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;測定結果&#34;&gt;測定結果&lt;/h2&gt;

&lt;h3 id=&#34;1-自宅-神奈川-ocn光-インターネット-azure東日本リージョン&#34;&gt;1. 自宅(神奈川) -&amp;gt; OCN光 -&amp;gt; インターネット -&amp;gt; Azure東日本リージョン&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;TCP connect statistics for 104.41.187.55:3389:
  Sent = 4, Received = 4, Lost = 0 (0% loss),
  Minimum = 11.43ms, Maximum = 15.66ms, Average = 12.88ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-自宅-神奈川-ocn光-インターネット-azure西日本リージョン&#34;&gt;2. 自宅(神奈川) -&amp;gt; OCN光 -&amp;gt; インターネット -&amp;gt; Azure西日本リージョン&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;TCP connect statistics for 52.175.148.28:3389:
  Sent = 4, Received = 4, Lost = 0 (0% loss),
  Minimum = 17.96ms, Maximum = 19.64ms, Average = 18.92ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-自宅-神奈川-ocn光-インターネット-azure米国西海岸リージョン&#34;&gt;3. 自宅(神奈川) -&amp;gt; OCN光 -&amp;gt; インターネット -&amp;gt; Azure米国西海岸リージョン&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;TCP connect statistics for 40.83.220.19:3389:
  Sent = 4, Received = 4, Lost = 0 (0% loss),
  Minimum = 137.73ms, Maximum = 422.56ms, Average = 218.85ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-azure東日本リージョン-azureバックボーン-azure西日本リージョン&#34;&gt;4. Azure東日本リージョン -&amp;gt; Azureバックボーン -&amp;gt; Azure西日本リージョン&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;TCP connect statistics for 52.175.148.28:3389:
  Sent = 4, Received = 4, Lost = 0 (0% loss),
  Minimum = 8.61ms, Maximum = 9.38ms, Average = 9.00ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-azure東日本リージョン-azureバックボーン-azure米国西海岸リージョン&#34;&gt;5. Azure東日本リージョン -&amp;gt; Azureバックボーン -&amp;gt; Azure米国西海岸リージョン&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;TCP connect statistics for 40.83.220.19:3389:
  Sent = 4, Received = 4, Lost = 0 (0% loss),
  Minimum = 106.38ms, Maximum = 107.38ms, Average = 106.65ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Azureバックボーンを通すと首都圏からの遅延が半分になりました。Wi-Fiの有無など、ちょっと条件は違いますが。&lt;/p&gt;

&lt;h2 id=&#34;ひとこと&#34;&gt;ひとこと&lt;/h2&gt;

&lt;p&gt;インターネット、および接続サービスの遅延が性能の上がらない原因になっている場合は、Azureで完結させてみるのも手です。&lt;/p&gt;

&lt;p&gt;たとえば、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;会社で契約しているインターネット接続サービスが、貧弱&lt;/li&gt;
&lt;li&gt;シリコンバレーの研究所からインターネット経由でデータを取得しているが、遅い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こんなケースではAzureを間に入れると、幸せになれるかもしれません。なったユーザーもいらっしゃいます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Resource Manager テンプレートでManaged Diskを作るときのコツ</title>
      <link>http://torumakabe.github.io/post/arm_template_managed_disk/</link>
      <pubDate>Thu, 23 Mar 2017 15:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/arm_template_managed_disk/</guid>
      <description>

&lt;h2 id=&#34;お伝えしたいこと&#34;&gt;お伝えしたいこと&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ARMテンプレートのドキュメントが使いやすくなった&lt;/li&gt;
&lt;li&gt;Visual Studio CodeとAzure Resource Manager Toolsを使おう&lt;/li&gt;
&lt;li&gt;ARMテンプレートでManaged Diskを作る時のコツ&lt;/li&gt;
&lt;li&gt;可用性セットを意識しよう&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;armテンプレートのドキュメントが使いやすくなった&#34;&gt;ARMテンプレートのドキュメントが使いやすくなった&lt;/h2&gt;

&lt;p&gt;docs.microsoft.com の整備にともない、ARMテンプレートのドキュメントも&lt;a href=&#34;https://azure.microsoft.com/ja-jp/blog/azure-resource-manager-template-reference-now-available/&#34;&gt;使いやすくなりました&lt;/a&gt;。ARMテンプレート使いのみなさまは &lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/templates/&#34;&gt;https://docs.microsoft.com/ja-jp/azure/templates/&lt;/a&gt; をブックマークして、サクサク調べちゃってください。&lt;/p&gt;

&lt;h2 id=&#34;visual-studio-codeとazure-resource-manager-toolsを使おう&#34;&gt;Visual Studio CodeとAzure Resource Manager Toolsを使おう&lt;/h2&gt;

&lt;p&gt;これがあまり知られてないようなのでアピールしておきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/media/resource-manager-create-first-template/vs-code-show-values.png&#34; alt=&#34;コードアシスト&#34; title=&#34;コードアシスト&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コードアシストしてくれます。&lt;/p&gt;

&lt;p&gt;画面スクロールが必要なほどのJSONをフリーハンドで書けるほど人類は進化していないというのがわたしの見解です。ぜひご活用ください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/resource-manager-create-first-template?toc=%2fazure%2ftemplates%2ftoc.json&amp;amp;bc=%2Fazure%2Ftemplates%2Fbreadcrumb%2Ftoc.json#get-vs-code-and-extension&#34;&gt;Get VS Code and extension&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;armテンプレートでmanaged-diskを作る時のコツ&#34;&gt;ARMテンプレートでManaged Diskを作る時のコツ&lt;/h2&gt;

&lt;p&gt;Managed Diskが使えるようになって、ARMテンプレートでもストレージアカウントの定義を省略できるようになりました。Managed Diskの実体は内部的にAzureが管理するストレージアカウントに置かれるのですが、ユーザーからは隠蔽されます。&lt;/p&gt;

&lt;p&gt;Managed Diskは &lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/templates/microsoft.compute/disks&#34;&gt;Microsoft.Compute/disks&lt;/a&gt;  で個別に定義できますが、省略もできます。&lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/templates/microsoft.compute/virtualmachines&#34;&gt;Microsoft.Compute/virtualMachines&lt;/a&gt; の中に書いてしまうやり口です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;osDisk&amp;quot;: {
  &amp;quot;name&amp;quot;: &amp;quot;[concat(variables(&#39;vmName&#39;),&#39;-md-os&#39;)]&amp;quot;,
  &amp;quot;createOption&amp;quot;: &amp;quot;FromImage&amp;quot;,
  &amp;quot;managedDisk&amp;quot;: {
    &amp;quot;storageAccountType&amp;quot;: &amp;quot;Standard_LRS&amp;quot;
  },
  &amp;quot;diskSizeGB&amp;quot;: 128
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで書けます。ポイントはサイズ指定 &amp;ldquo;diskSizeGB&amp;rdquo; の位置です。&amp;rdquo;managedDisk&amp;rdquo;の下ではありません。おじさんちょっと悩みました。&lt;/p&gt;

&lt;h2 id=&#34;可用性セットを意識しよう&#34;&gt;可用性セットを意識しよう&lt;/h2&gt;

&lt;p&gt;Managed Diskを使う利点のひとつが、可用性セットを意識したディスク配置です。可用性セットに仮想マシンを配置し、かつManaged Diskを使うと、可用性を高めることができます。&lt;/p&gt;

&lt;p&gt;Azureのストレージサービスは、多数のサーバーで構成された分散ストレージで実現されています。そのサーバー群をStorage Unitと呼びます。StampとかClusterと表現されることもあります。Storage Unitは数十のサーバーラック、数百サーバーで構成され、Azureの各リージョンに複数配置されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://download.microsoft.com/download/C/0/2/C02C4D26-0472-4688-AC13-199EA321135E/23rdACM_SOSP_WindowsAzureStorage_201110_jpn.pdf&#34;&gt;参考情報:Windows Azure ストレージ: 高可用性と強い一貫性を両立する クラウド ストレージ サービス(PDF)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可用性セットは、電源とネットワークを共有するグループである&amp;rdquo;障害ドメイン(FD: Fault Domain)&amp;ldquo;を意識して仮想マシンを分散配置する設定です。そして、可用性セットに配置した仮想マシンに割り当てたManaged Diskは、Storage Unitを分散するように配置されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://msdnshared.blob.core.windows.net/media/2017/03/92.jpg&#34; alt=&#34;Unmanaged vs Managed&#34; title=&#34;Unmanaged vs Managed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;すなわち、Storage Unitの障害に耐えることができます。Storage Unitは非常に可用性高く設計されており、長期に運用されてきた実績もあるのですが、ダウンする可能性はゼロではありません。可用性セットとManaged Diskの組み合わせは、可用性を追求したいシステムでは、おすすめです。&lt;/p&gt;

&lt;p&gt;さて、この場合の可用性セット定義ですが、以下のように書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;Microsoft.Compute/availabilitySets&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;AvSet01&amp;quot;,
  &amp;quot;apiVersion&amp;quot;: &amp;quot;2016-04-30-preview&amp;quot;,
  &amp;quot;location&amp;quot;: &amp;quot;[resourceGroup().location]&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;managed&amp;quot;: true,
    &amp;quot;platformFaultDomainCount&amp;quot;: 2,
    &amp;quot;platformUpdateDomainCount&amp;quot;: 5
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/templates/microsoft.compute/availabilitysets&#34;&gt;Microsoft.Compute/availabilitySets&lt;/a&gt; を読むと、Managed Diskを使う場合は&amp;rdquo;propaties&amp;rdquo;の&amp;rdquo;managed&amp;rdquo;をtrueにすべし、とあります。なるほど。&lt;/p&gt;

&lt;p&gt;そしてポイントです。合わせて&amp;rdquo;platformFaultDomainCount&amp;rdquo;を指定してください。managedにする場合は必須パラメータです。&lt;/p&gt;

&lt;p&gt;なお、リージョンによって配備されているStorage Unit数には違いがあるのでご注意を。例えば東日本リージョンは2です。3のリージョンもあります。それに合わせて可用性セットの障害ドメイン数を指定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/azure/storage/storage-faq-for-disks&#34;&gt;Azure IaaS VM ディスクと Premium 管理ディスクおよび非管理ディスクについてよく寄せられる質問&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Managed Disks を使用する可用性セットでサポートされる障害ドメイン数はいくつですか?

Managed Disks を使用する可用性セットでサポートされる障害ドメイン数は 2 または 3 です。これは、配置されているリージョンによって異なります。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker for WindowsでインストールレスAzure CLI 2.0環境を作る</title>
      <link>http://torumakabe.github.io/post/dockerforwin_azurecli2/</link>
      <pubDate>Tue, 28 Feb 2017 08:00:30 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/dockerforwin_azurecli2/</guid>
      <description>

&lt;h2 id=&#34;azure-cli-2-0版です&#34;&gt;Azure CLI 2.0版です&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://torumakabe.github.io/post/dockerforwin_azurecli/&#34;&gt;Docker for WindowsでインストールレスAzure CLI環境を作る&lt;/a&gt;、のAzure CLI 2.0版です。Azure CLI 2.0の一般提供開始に合わせて書いています。&lt;/p&gt;

&lt;h2 id=&#34;動機&#34;&gt;動機&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker for Windows、もっと活用しようぜ&lt;/li&gt;
&lt;li&gt;がんがんアップデートされるAzure CLI2.0をいちいちインストールしたくない、コンテナ引っ張って以上、にしたい&lt;/li&gt;
&lt;li&gt;開発端末の環境を汚したくない、いつでもきれいに作り直せるようにしたい&lt;/li&gt;
&lt;li&gt;WindowsでPythonのバージョン管理するのつらくないですか? コンテナで解決しましょう&lt;/li&gt;
&lt;li&gt;○○レスって言ってみたかった&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;やり口&#34;&gt;やり口&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;もちろんDocker for Windows (on Client Hyper-V) を使う&lt;/li&gt;
&lt;li&gt;いちいちdocker run&amp;hellip;と打たなくていいよう、エイリアス的にPowerShellのfunction &amp;ldquo;az_cli&amp;rdquo; を作る&lt;/li&gt;
&lt;li&gt;&amp;ldquo;az_cli&amp;rdquo;入力にてAzure CLIコンテナを起動&lt;/li&gt;
&lt;li&gt;コンテナとホスト(Windows)間でファイル共有、ホスト側のIDEなりエディタを使えるようにする&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作業の中身&#34;&gt;作業の中身&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker for Windowsを&lt;a href=&#34;https://docs.docker.com/docker-for-windows/install/&#34;&gt;インストール&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;64bit Windows 10 Pro/Enterprise/Education 1511以降に対応&lt;/li&gt;
&lt;li&gt;Hyper-Vの有効化を忘れずに&lt;/li&gt;
&lt;li&gt;Hyper-VとぶつかるVirtualBoxとはお別れです&lt;/li&gt;
&lt;li&gt;モードをLinuxにします。タスクトレイのdockerアイコンを右クリック [Switch to Linux containers]&lt;/li&gt;
&lt;li&gt;ドライブ共有をお忘れなく。 タスクトレイのdockerアイコンを右クリック [settings] &amp;gt; [Shared Drives]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PowerShell functionを作成

&lt;ul&gt;
&lt;li&gt;のちほど詳しく&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;powershellのfunctionを作る&#34;&gt;PowerShellのfunctionを作る&lt;/h2&gt;

&lt;p&gt;ここが作業のハイライト。&lt;/p&gt;

&lt;p&gt;PowerShellのプロファイルを編集します。ところでエディタはなんでもいいのですが、AzureやDockerをがっつり触る人にはVS Codeがおすすめです。&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools&#34;&gt;Azure Resource Manager Template&lt;/a&gt;や&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=PeterJausovec.vscode-docker&#34;&gt;Docker&lt;/a&gt;むけextensionがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\Workspace\ARM&amp;gt; code $profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなfunctionを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function az_cli {
   C:\PROGRA~1\Docker\Docker\Resources\bin\docker.exe run -it --rm -v ${HOME}/.azure:/root/.azure -v ${PWD}:/data -w /data azuresdk/azure-cli-python
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;エイリアスでなくfunctionにした理由は、引数です。エイリアスだと引数を渡せないので&lt;/li&gt;
&lt;li&gt;コンテナが溜まるのがいやなので、&amp;ndash;rmで都度消します&lt;/li&gt;
&lt;li&gt;毎度 az login しなくていいよう、トークンが保管されるコンテナの/root/azureディレクトリをホストの${HOME}/.azureと-v オプションで共有します&lt;/li&gt;
&lt;li&gt;ARM TemplateのJSONファイルなど、ホストからファイルを渡したいため、カレントディレクトリ ${PWD} をコンテナと -v オプションで共有します&lt;/li&gt;
&lt;li&gt;コンテナはdocker hubのazuresdk/azure-cli-pythonリポジトリ、latestを引っ張ります。latestで不具合あればバージョン指定してください&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ではテスト。まずはホスト側のファイルを確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\Workspace\ARM&amp;gt; ls


    ディレクトリ: C:\Workspace\ARM


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----       2017/02/28      8:29           4515 azuredeploy.json
-a----       2017/02/28      8:30            374 azuredeploy.parameters.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつかのファイルがあります。&lt;/p&gt;

&lt;p&gt;コンテナを起動してみましょう。az_cli functionを呼びます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\Workspace\ARM&amp;gt; az_cli
bash-4.3#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナを起動し、入出力をつなぎました。ここからは頭と手をLinuxに切り替えてください。Azure CLI 2.0コンテナは&lt;a href=&#34;https://hub.docker.com/r/azuresdk/azure-cli-python/~/dockerfile/&#34;&gt;alpine linux&lt;/a&gt;ベースです。&lt;/p&gt;

&lt;p&gt;カレントディレクトリを確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash-4.3# pwd
/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイル共有できているか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash-4.3# ls
azuredeploy.json             azuredeploy.parameters.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できてますね。&lt;/p&gt;

&lt;p&gt;azコマンドが打てるか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash-4.3# az --version
azure-cli (2.0.0+dev)

acr (0.1.1b4+dev)
acs (2.0.0+dev)
appservice (0.1.1b5+dev)
batch (0.1.1b4+dev)
cloud (2.0.0+dev)
component (2.0.0+dev)
configure (2.0.0+dev)
container (0.1.1b4+dev)
core (2.0.0+dev)
documentdb (0.1.1b2+dev)
feedback (2.0.0+dev)
iot (0.1.1b3+dev)
keyvault (0.1.1b5+dev)
network (2.0.0+dev)
nspkg (2.0.0+dev)
profile (2.0.0+dev)
redis (0.1.1b3+dev)
resource (2.0.0+dev)
role (2.0.0+dev)
sql (0.1.1b5+dev)
storage (2.0.0+dev)
taskhelp (0.1.1b3+dev)
vm (2.0.0+dev)

Python (Linux) 3.5.2 (default, Dec 27 2016, 21:33:11)
[GCC 5.3.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;タブで補完も効きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash-4.3# az a
account     acr         acs         ad          appservice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しあわせ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure N-SeriesでPaintsChainerを動かす</title>
      <link>http://torumakabe.github.io/post/paintschainer_on_azure/</link>
      <pubDate>Fri, 03 Feb 2017 18:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/paintschainer_on_azure/</guid>
      <description>

&lt;h2 id=&#34;paintschainer面白い&#34;&gt;PaintsChainer面白い&lt;/h2&gt;

&lt;p&gt;クラスメソッドさんのDevelopers.IOでのエントリ&lt;a href=&#34;http://dev.classmethod.jp/cloud/paintschainer-on-ec2/&#34;&gt;&amp;ldquo;PaintsChainerをAmazon EC2で動かしてみた&amp;rdquo;&lt;/a&gt;が、とても面白いです。&lt;/p&gt;

&lt;p&gt;畳みこみニューラルネットワークを駆使して白黒線画に色付けしちゃうPaintsChainerすごい。EC2のGPUインスタンスでさくっと動かせるのもいいですね。&lt;/p&gt;

&lt;p&gt;せっかくなのでAzureでもやってみようと思います。AzurerはN-Series &amp;amp; NVIDIA-Dockerのサンプルとして、Azurerでない人はUbuntuでPaintsChainerを動かす参考手順として見ていただいてもいいかと。&lt;/p&gt;

&lt;h2 id=&#34;試した環境&#34;&gt;試した環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;米国中南部リージョン&lt;/li&gt;
&lt;li&gt;Standard NC6 (6 コア、56 GB メモリ、NVIDIA Tesla K80)&lt;/li&gt;
&lt;li&gt;Ubuntu 16.04&lt;/li&gt;
&lt;li&gt;NSGはSSH(22)の他にHTTP(80)を受信許可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;導入手順&#34;&gt;導入手順&lt;/h2&gt;

&lt;h3 id=&#34;nvidia-tesla-driversのインストール&#34;&gt;NVIDIA Tesla driversのインストール&lt;/h3&gt;

&lt;p&gt;マイクロソフト公式ドキュメントの通りに導入します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/virtual-machines/virtual-machines-linux-n-series-driver-setup&#34;&gt;Set up GPU drivers for N-series VMs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;dockerのインストール&#34;&gt;Dockerのインストール&lt;/h3&gt;

&lt;p&gt;Docker公式ドキュメントの通りに導入します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/ubuntu/&#34;&gt;Get Docker for Ubuntu&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;nvidia-dockerのインストール&#34;&gt;NVIDIA Dockerのインストール&lt;/h3&gt;

&lt;p&gt;GitHub上のNVIDIAのドキュメント通りに導入します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker&#34;&gt;NVIDIA Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここまでの作業に問題がないか、確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo nvidia-docker run --rm nvidia/cuda nvidia-smi
Using default tag: latest
latest: Pulling from nvidia/cuda
8aec416115fd: Pull complete
[...]
Status: Downloaded newer image for nvidia/cuda:latest
Fri Feb  3 06:43:18 2017
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 367.48                 Driver Version: 367.48                    |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  Tesla K80           Off  | 86BF:00:00.0     Off |                    0 |
| N/A   34C    P8    33W / 149W |      0MiB / 11439MiB |      0%      Default |
+-------------------------------+----------------------+----------------------+

+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID  Type  Process name                               Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;paintschainer-dockerのインストール&#34;&gt;PaintsChainer-Dockerのインストール&lt;/h3&gt;

&lt;p&gt;Liam Jones氏が公開している&lt;a href=&#34;https://github.com/liamjones/PaintsChainer-Docker&#34;&gt;PaintsChainer-Docker&lt;/a&gt;を使って、PaintsChanierコンテナーを起動します。ポートマッピングはコンテナーホストの80番とコンテナーの8000番です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo nvidia-docker run -p 80:8000 liamjones/paintschainer-docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paintschainerを使ってみる&#34;&gt;PaintsChainerを使ってみる&lt;/h2&gt;

&lt;p&gt;VMのパブリックIP、ポート80番にアクセスすると、先ほどコンテナーで起動したPaintsChainerのページが開きます。クラウディアさんの白黒画像ファイルで試してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ToruMakabe/Images/master/paintschainer_cloudia.png&#34; alt=&#34;結果&#34; title=&#34;Cloudia&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PaintsChainer、すごいなぁ。
クラウディアさん、おなか寒そうだけど。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure App Service on LinuxのコンテナをCLIで更新する方法</title>
      <link>http://torumakabe.github.io/post/azure_webapponlinux_dockertag/</link>
      <pubDate>Sun, 20 Nov 2016 13:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_webapponlinux_dockertag/</guid>
      <description>

&lt;h2 id=&#34;cliでコンテナを更新したい&#34;&gt;CLIでコンテナを更新したい&lt;/h2&gt;

&lt;p&gt;Connect(); 2016にあわせ、Azure App Service on Linuxのコンテナ対応が&lt;a href=&#34;https://azure.microsoft.com/en-us/blog/app-service-on-linux-now-supports-containers-and-asp-net-core/&#34;&gt;発表&lt;/a&gt;されました。Azure Container Serviceほどタップリマシマシな環境ではなく、サクッと楽してコンテナを使いたい人にオススメです。&lt;/p&gt;

&lt;p&gt;さっそくデプロイの自動化どうすっかな、と検討している人もちらほらいらっしゃるようです。CI/CD側でビルド、テストしたコンテナをAPIなりCLIでApp Serviceにデプロイするやり口、どうしましょうか。&lt;/p&gt;

&lt;p&gt;まだプレビューなのでAzureも、VSTSなどCI/CD側も機能追加が今後あると思いますし、使い方がこなれてベストプラクティスが生まれるとは思いますが、アーリーアダプターなあなた向けに、現時点でできることを書いておきます。&lt;/p&gt;

&lt;h2 id=&#34;azure-cli-2-0&#34;&gt;Azure CLI 2.0&lt;/h2&gt;

&lt;p&gt;Azure CLI 2.0に&amp;rdquo;appservice web config container&amp;rdquo;コマンドがあります。これでコンテナイメージを更新できます。&lt;/p&gt;

&lt;p&gt;すでにyourrepoレポジトリのyourcontainerコンテナ、タグ1.0.0がデプロイされているとします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az appservice web config container show -n yourcontainerapp -g YourRG
{
  &amp;quot;DOCKER_CUSTOM_IMAGE_NAME&amp;quot;: &amp;quot;yourrepo/yourcontainer:1.0.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新ビルドのタグ1.0.1をデプロイするには、update -c オプションを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ az appservice web config container update -n yourcontainerapp -g YourRG -c &amp;quot;yourrepo/yourcontainer:1.0.1&amp;quot;
{
  &amp;quot;DOCKER_CUSTOM_IMAGE_NAME&amp;quot;: &amp;quot;yourrepo/yourcontainer:1.0.1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで更新されます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SlackとAzure FunctionsでChatOpsする</title>
      <link>http://torumakabe.github.io/post/azure_chatops_onfunctions/</link>
      <pubDate>Fri, 07 Oct 2016 17:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_chatops_onfunctions/</guid>
      <description>

&lt;h2 id=&#34;azure-functionsでやってみよう&#34;&gt;Azure Functionsでやってみよう&lt;/h2&gt;

&lt;p&gt;Azure上でChatOpsしたい、と相談をいただきました。&lt;/p&gt;

&lt;p&gt;AzureでChatOpsと言えば、Auth0のSandrino Di Mattia氏が作った素敵な&lt;a href=&#34;http://fabriccontroller.net/chatops-deploy-and-manage-complete-environments-on-azure-using-slack/&#34;&gt;サンプル&lt;/a&gt;があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fabriccontroller.net/static/chatops-how-this-works.png.pagespeed.ce.lN444drUKd.png&#34; alt=&#34;Azure Runスラッシュ&#34; title=&#34;from fabriccontroller.net&#34; /&gt;&lt;/p&gt;

&lt;p&gt;素晴らしい。これで十分、という気もしますが、実装のバリエーションがあったほうが後々参考になる人も多いかなと思い、Web App/Web JobをAzure Functionsで置き換えてみました。&lt;/p&gt;

&lt;h2 id=&#34;slackからrunbookを実行できて-何がうれしいか&#34;&gt;SlackからRunbookを実行できて、何がうれしいか&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;誰がいつ、どんな文脈でRunbookを実行したかを可視化する&lt;/li&gt;
&lt;li&gt;CLIやAPIをRunbookで隠蔽し、おぼえることを減らす&lt;/li&gt;
&lt;li&gt;CLIやAPIをRunbookで隠蔽し、できることを制限する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ブツ&#34;&gt;ブツ&lt;/h2&gt;

&lt;p&gt;Githubに上げておきました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ToruMakabe/AZChatOpsSample&#34;&gt;AZChatOpsSample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;おおまかな流れ&#34;&gt;おおまかな流れ&lt;/h2&gt;

&lt;p&gt;手順書つらいのでポイントだけ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SlackのSlash CommandとIncoming Webhookを作る&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;流れは氏の&lt;a href=&#34;http://fabriccontroller.net/chatops-deploy-and-manage-complete-environments-on-azure-using-slack/&#34;&gt;元ネタ&lt;/a&gt;と同じ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ARM TemplateでFunction Appをデプロイ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Github上のDeployボタンからでもいいですが、パラメータファイルを作っておけばCLIで楽に繰り返せます&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;パラメータファイルのサンプルは&lt;a href=&#34;https://github.com/ToruMakabe/AZChatOpsSample/blob/master/sample.azuredeploy.parameters.json&#34;&gt;sample.azuredeploy.parameters.json&lt;/a&gt;です。GUIでデプロイするにしても、パラメータの意味を理解するためにざっと読むと幸せになれると思います&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function AppのデプロイはGithubからのCIです。クローンしたリポジトリとブランチを指定してください&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GithubからのCIは、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/app-service-deploy-complex-application-predictably/&#34;&gt;はじめてのケースを考慮し&lt;/a&gt;ARM Templateのリソースプロパティ&amp;rdquo;IsManualIntegration&amp;rdquo;をtrueにしています&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure Automationのジョブ実行権限を持つサービスプリンシパルが必要です (パラメータ SUBSCRIPTION_ID、TENANT_ID、CLIENT_ID、CLIENT_SECRET で指定)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure Automationについて詳しく説明しませんが、Slackから呼び出すRunbookを準備しておいてください。そのAutomationアカウントと所属するリソースグループを指定します&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作成済みのSlack関連パラメータを指定します&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ARM Templateデプロイ後にkuduのデプロイメントスクリプトが走るので、しばし待つ(Function Appの設定-&amp;gt;継続的インテグレーションの構成から進捗が見えます)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;デプロイ後、Slash Commandで呼び出すhttptrigger function(postJob)のtokenを変更&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kuduでdata/Functions/secrets/postJob.jsonの値を、Slackが生成したSlash Commandのtokenに書き換え&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slack上で、Slash Commandのリクエスト先URLを変更 (例: &lt;a href=&#34;https://yourchatops.azurewebsites.net/api/postJob?code=TokenTokenToken&#34;&gt;https://yourchatops.azurewebsites.net/api/postJob?code=TokenTokenToken&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファンクションが動いたら、Slackの指定チャンネルでSlash Commandが打てるようになる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/runbook [runbook名] [parm1] [parm2] [parm&amp;hellip;]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;パラメータはrunbook次第&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runbookの進捗はIncoming Webhookでslackに通知される&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Runbookのステータスが変わったときに通知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;よもやま話&#34;&gt;よもやま話&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SlackのSlash Commandは、3秒以内に返事を返さないとタイムアウトします。なのでいくつか工夫しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ファンクションはトリガーされるまで寝ています。また、5分間動きがないとこれまた寝ます(cold状態になる)。寝た子を起こすのには時間がかかるので、Slackの3秒ルールに間に合わない可能性があります。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure FunctionsのWebコンソールログが無活動だと30分で停止するので、coldに入る条件も30分と誤解していたのですが、正しくは5分。ソースは&lt;a href=&#34;https://github.com/Azure/azure-webjobs-sdk-script/issues/529&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;そこで、4分周期でTimer Triggerし、postJobにダミーPOSTするpingFuncを作りました。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファンクションのコードに更新があった場合、リロード処理が走ります。リロード後、またしてもトリガーを待って寝てしまうので、コード変更直後にSlash Commandを打つとタイムアウトする可能性大です。あせらずpingまで待ちましょう。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;でもAzure AutomationのAPI応答待ちなど、外部要因で3秒超えちゃう可能性はあります。非同期にしてひとまずSlackに応答返す作りに変えたほうがいいですね。これはSlackのSlash Commandに限らず、呼び出し元に待ってもらえないケース全てに言える考慮点です。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Azure Functionsはまだプレビューなので、&lt;a href=&#34;https://github.com/Azure/azure-webjobs-sdk-script/issues/529&#34;&gt;議論されているとおり&lt;/a&gt;改善の余地が多くあります。期待しましょう。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Bash on WindowsでNode開発環境を作る</title>
      <link>http://torumakabe.github.io/post/bashonwindows_nvm/</link>
      <pubDate>Wed, 14 Sep 2016 15:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/bashonwindows_nvm/</guid>
      <description>

&lt;h2 id=&#34;bash-on-windows-現時点での使いどころ&#34;&gt;Bash on Windows 現時点での使いどころ&lt;/h2&gt;

&lt;p&gt;Windows 10 Anniversary Updateでベータ提供がはじまったBash on Ubuntu on Windows、みなさん使ってますか。わたしは、まだベータなので本気運用ではないのですが、開発ツールを動かすのに使い始めてます。Linux/Macと同じツールが使えるってのは便利です。&lt;/p&gt;

&lt;p&gt;たとえばNodeのバージョン管理。Windowsには&lt;a href=&#34;https://github.com/marcelklehr/nodist&#34;&gt;nodist&lt;/a&gt;がありますが、Linux/Macでは動きません。Linux/Macで使ってる&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;NVM&lt;/a&gt;がWindowsで動いたら、いくつもバージョン管理ツールを覚えずに済むのに！あ、Bash on Windowsあるよ！！おお、そうだな！！！という話です。&lt;/p&gt;

&lt;p&gt;最近、Azure FunctionsでNode v6.4.0が&lt;a href=&#34;https://blogs.msdn.microsoft.com/appserviceteam/2016/09/01/azure-functions-0-5-release-august-portal-update/&#34;&gt;使えるようになった&lt;/a&gt;ので、「これからバージョン管理どうすっかな」と考えていた人も多いのでは。それはわたしです。&lt;/p&gt;

&lt;h2 id=&#34;nvmのインストール&#34;&gt;NVMのインストール&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bash on Ubuntu on Windowsを入れます (&lt;a href=&#34;http://www.atmarkit.co.jp/ait/articles/1608/08/news039.html&#34;&gt;参考&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Bash on Ubuntu on Windowsを起動します&lt;/li&gt;
&lt;li&gt;build-essentialとlibssl-devを入れます&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential checkinstall
sudo apt-get install libssl-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;インストールスクリプトを流します&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.7/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;バージョンアップを考慮し、インストールのつど&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;公式ページ&lt;/a&gt;を確認してください。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

&lt;h2 id=&#34;nvmの使い方&#34;&gt;NVMの使い方&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;nvm install 6.4.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定のバージョンをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nvm use 6.4.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使うバージョンを指定します。&lt;/p&gt;

&lt;p&gt;簡単ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /mnt/c/your_work_directory
node ./index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんて感じで、書いたコードをテストしちゃってください。&lt;/p&gt;

&lt;p&gt;なお、Visual Studio Code使いの人は&lt;a href=&#34;https://blogs.msdn.microsoft.com/ayatokura/2016/08/06/vsc_windows_bash/&#34;&gt;統合ターミナルをBashにしておく&lt;/a&gt;と、さらに幸せになれます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure Functionsで運用管理サーバレス生活(使用量データ取得編)</title>
      <link>http://torumakabe.github.io/post/azurefunctions_getusagedata/</link>
      <pubDate>Tue, 13 Sep 2016 17:30:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azurefunctions_getusagedata/</guid>
      <description>

&lt;h2 id=&#34;背景と動機&#34;&gt;背景と動機&lt;/h2&gt;

&lt;p&gt;Azure Functions使ってますか。「サーバレス」という、ネーミングに突っ込みたい衝動を抑えられないカテゴリに属するため損をしている気もしますが、システムのつくり方を変える可能性がある、潜在能力高めなヤツです。キャッチアップして損はないです。&lt;/p&gt;

&lt;p&gt;さて、Azure Functionsを使ってAzureの使用量データを取得、蓄積したいというリクエストを最近いくつかいただきました。いい機会なのでまとめておきます。以下、その背景。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;運用管理業務がビジネスの差別化要素であるユーザは少ない。可能な限り省力化したい。運用管理ソフトの導入維持はもちろん、その土台になるサーバの導入、維持は真っ先に無くしたいオーバヘッド。もうパッチ当てとか監視システムの監視とか、やりたくない。&lt;/li&gt;
&lt;li&gt;Azure自身が持つ運用管理の機能が充実し、また、運用管理SaaS(&lt;a href=&#34;https://www.microsoft.com/ja-jp/server-cloud/products-operations-management-suite.aspx&#34;&gt;MS OMS&lt;/a&gt;、New Relic、Datadogなど)が魅力的になっており、使い始めている。いつかは運用管理サーバを無くしたい。&lt;/li&gt;
&lt;li&gt;でも、それら標準的なサービスでカバーされていない、ちょっとした機能が欲しいことがある。&lt;/li&gt;
&lt;li&gt;Azureリソースの使用量データ取得が一例。Azureでは使用量データを&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/billing-understand-your-bill/&#34;&gt;ポータルからダウンロード&lt;/a&gt;したり、&lt;a href=&#34;https://powerbi.microsoft.com/ja-jp/documentation/powerbi-content-pack-azure-enterprise/&#34;&gt;Power BIで分析&lt;/a&gt;できたりするが、元データは自分でコントロールできるようためておきたい。もちろん手作業なし、自動で。&lt;/li&gt;
&lt;li&gt;ちょっとしたコードを気軽に動かせる仕組みがあるなら、使いたい。インフラエンジニアがさくっと書くレベルで。&lt;/li&gt;
&lt;li&gt;それAzure Functionsで出来るよ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方針&#34;&gt;方針&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Azure FunctionsのTimer Triggerを使って、日次で実行&lt;/li&gt;
&lt;li&gt;Azure Resource Usage APIを使って使用量を取得し、ファイルに書き込み&lt;/li&gt;
&lt;li&gt;Nodeで書く (C#のサンプルはたくさんあるので)&lt;/li&gt;
&lt;li&gt;業務、チームでの運用を考慮して、ブラウザでコード書かずにソース管理ツールと繋げる (Githubを使う)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick Start&lt;/h2&gt;

&lt;h3 id=&#34;準備&#34;&gt;準備&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ところでAzure Funtionsって何よ、って人はまず&lt;a href=&#34;https://blogs.technet.microsoft.com/azure-sa-members/azurefunctions/&#34;&gt;いい資料1&lt;/a&gt;と&lt;a href=&#34;https://buchizo.wordpress.com/2016/06/04/azure-functions-overview-and-under-the-hood/&#34;&gt;いい資料2&lt;/a&gt;でざっと把握を&lt;/li&gt;
&lt;li&gt;AzureのAPIにプログラムからアクセスするため、サービスプリンシパルを作成 (&lt;a href=&#34;https://doc.co/66mYfB&#34;&gt;ここ&lt;/a&gt;とか&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/resource-group-authenticate-service-principal/&#34;&gt;ここ&lt;/a&gt;を参考に)

&lt;ul&gt;
&lt;li&gt;後ほど環境変数に設定するので、Domain(Tenant ID)、Client ID(App ID)、Client Secret(Password)、Subscription IDを控えておいてください&lt;/li&gt;
&lt;li&gt;権限はsubscriptionに対するreaderが妥当でしょう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Githubのリポジトリを作成 (VSTSやBitbucketも使えます)&lt;/li&gt;
&lt;li&gt;使用量データを貯めるストレージアカウントを作成

&lt;ul&gt;
&lt;li&gt;後ほど環境変数に設定するので、接続文字列を控えておいてください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;デプロイ&#34;&gt;デプロイ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Function Appを作成

&lt;ul&gt;
&lt;li&gt;ポータル左上&amp;rdquo;+新規&amp;rdquo; -&amp;gt; Web + モバイル -&amp;gt; Function App&lt;/li&gt;
&lt;li&gt;アプリ名は.azurewebsites.net空間でユニークになるように&lt;/li&gt;
&lt;li&gt;App Seriviceプランは、占有型の&amp;rdquo;クラシック&amp;rdquo;か、共有で実行したぶん課金の&amp;rdquo;動的&amp;rdquo;かを選べます。今回の使い方だと動的がお得でしょう&lt;/li&gt;
&lt;li&gt;メモリは128MBあれば十分です&lt;/li&gt;
&lt;li&gt;他のパラメータはお好みで&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;環境変数の設定

&lt;ul&gt;
&lt;li&gt;Function Appへポータルからアクセス -&amp;gt; Function Appの設定 -&amp;gt; アプリケーション設定の構成 -&amp;gt; アプリ設定&lt;/li&gt;
&lt;li&gt;先ほど控えた環境変数を設定します(CLIENT_ID、DOMAIN、APPLICATION_SECRET、AZURE_SUBSCRIPTION_ID、azfuncpoc_STORAGE)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプルコードを取得

&lt;ul&gt;
&lt;li&gt;githubに置いてますので、作業するマシンにcloneしてください -&amp;gt; &lt;a href=&#34;https://github.com/ToruMakabe/AZFuncTimerTriggerSample&#34;&gt;AZFuncTimerTriggerSample&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;準備済みのGithubリポジトリにpush&lt;/li&gt;
&lt;li&gt;リポジトリとFunction Appを同期

&lt;ul&gt;
&lt;li&gt;Function Appへポータルからアクセス -&amp;gt; Function Appの設定 -&amp;gt; 継続的インテグレーションの構成 -&amp;gt; セットアップ&lt;/li&gt;
&lt;li&gt;Githubリポジトリとブランチを設定し、同期を待ちます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Nodeのモジュールをインストール

&lt;ul&gt;
&lt;li&gt;&lt;del&gt;Function Appへポータルからアクセス -&amp;gt; Function Appの設定 -&amp;gt; kuduに移動 -&amp;gt; site/wwwroot/getUsageData へ移動&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;このディレクトリが、実行する関数、functionの単位です&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&amp;ldquo;npm install&amp;rdquo; を実行 (package.jsonの定義に従ってNodeのモジュールが”node_modules&amp;rdquo;へインストールされます)&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;deploy.cmd で自動的にインストールするよう変えました&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これで、指定ストレージアカウントの&amp;rdquo;usagedata&amp;rdquo;コンテナに日次で使用量データファイルができます。&lt;/p&gt;

&lt;h2 id=&#34;コード解説&#34;&gt;コード解説&lt;/h2&gt;

&lt;p&gt;3つのファイルをデプロイしました。簡単な順に、ざっと解説します。&lt;a href=&#34;https://github.com/ToruMakabe/AZFuncTimerTriggerSample&#34;&gt;コード&lt;/a&gt;を眺めながら読み進めてください。&lt;/p&gt;

&lt;h3 id=&#34;package-json&#34;&gt;package.json&lt;/h3&gt;

&lt;p&gt;主となるコードファイルは後述の&amp;rdquo;index.js&amp;rdquo;ですが、その動作に必要な環境を定義します。依存モジュールのバージョンの違いでトラブらないよう、dependenciesで指定するところがクライマックスです。&lt;/p&gt;

&lt;h3 id=&#34;function-json&#34;&gt;function.json&lt;/h3&gt;

&lt;p&gt;Azure Functionsの特徴である、TriggerとBindingsを定義します。サンプルはTimer Triggerなので、実行タイミングをここに書きます。&amp;rdquo;schedule&amp;rdquo;属性に、cron形式({秒}{分}{時}{日}{月}{曜日})で。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;0 0 0 * * *&amp;rdquo; と指定しているので、毎日0時0分0秒に起動します。UTCです。&lt;/p&gt;

&lt;h3 id=&#34;index-js&#34;&gt;index.js&lt;/h3&gt;

&lt;p&gt;メインロジックです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先ほど設定した環境変数は、&amp;rdquo;process.env.HOGE&amp;rdquo;を通じ実行時に読み込まれます。認証関連情報はハードコードせず、このやり口で。&lt;/li&gt;
&lt;li&gt;日付関連処理はUTCの明示を徹底しています。Azure Functions実行環境はUTCですが、ローカルでのテストなど他環境を考えると、指定できるところはしておくのがおすすめです。これはクラウドでグローバル展開する可能性があるコードすべてに言えます。&lt;/li&gt;
&lt;li&gt;0時に起動しますが、使用量データ作成遅延の可能性があるので、処理対象は2日前です。お好みで調整してください。詳細仕様は&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/azure/mt219001.aspx&#34;&gt;こちら&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;module.export からが主フローです。asyncを使って、Blobコンテナの作成、使用量データ取得&amp;amp;ファイル書き込みを、順次処理しています。後ほど豆知識で補足します。&lt;/li&gt;
&lt;li&gt;最後にcontext.done()でFunctionsに対してアプリの終了を伝えます。黙って終わるような行儀の悪い子は嫌いです。&lt;/li&gt;
&lt;li&gt;ヘルパー関数たちは最後にまとめてあります。ポイントはcontinuationTokenを使ったループ処理です。

&lt;ul&gt;
&lt;li&gt;Resource Usage API は、レスポンスで返すデータが多い場合に、途中で切って「次はこのトークンで続きからアクセスしてちょ」という動きをします。&lt;/li&gt;
&lt;li&gt;ループが2周目に入った場合は、データを書きだすファイルが分かれます。フォーマットは&amp;rdquo;YYYY-MM-DD_n.json&amp;rdquo;です。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;豆知識-node-on-azure-functions&#34;&gt;豆知識 (Node on Azure Functions)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通信やI/Oの関数など、非同期処理の拾い忘れ、突き抜けに注意してください

&lt;ul&gt;
&lt;li&gt;NodeはJavascript、シングルスレッドなので時間のかかる処理でブロックしないのが基本です&lt;/li&gt;
&lt;li&gt;Azure FunctionsはNode v6.4.0が使えるのでES6のpromiseが書けるのですが、SDKがまだpromiseを&lt;a href=&#34;https://github.com/Azure/azure-sdk-for-node/issues/1450&#34;&gt;サポートしていない&lt;/a&gt;ので、サポートされるまではcallbackで堅く書きましょう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Nodeに限った話ではないですが、Azure Functions Timer TriggerはInput/Output Bindingと組み合わせられません

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/functions-reference/#-7&#34;&gt;サポートマトリックス&lt;/a&gt;を確認しましょう&lt;/li&gt;
&lt;li&gt;なのでサンプルではOutput Binding使わずに書きました&lt;/li&gt;
&lt;li&gt;Input/Outputを使える他のTriggerでは、楽なのでぜひ活用してください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;豆知識-azure-usage-api&#34;&gt;豆知識 (Azure Usage API)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Resource Usage APIは使用量のためのAPIなので、料金に紐づけたい場合は、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/billing-usage-rate-card-overview/&#34;&gt;Ratecard API&lt;/a&gt;を組み合わせてください&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;それでは、幸せな運用管理サーバレス生活を。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OMSでLinuxコンテナのログを分析する</title>
      <link>http://torumakabe.github.io/post/oms_container_linux/</link>
      <pubDate>Thu, 25 Aug 2016 16:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/oms_container_linux/</guid>
      <description>

&lt;h2 id=&#34;oms-container-solution-for-linux-プレビュー開始&#34;&gt;OMS Container Solution for Linux プレビュー開始&lt;/h2&gt;

&lt;p&gt;OMS Container Solution for Linuxのプレビューが&lt;a href=&#34;https://blogs.technet.microsoft.com/msoms/2016/08/24/announcing-public-preview-oms-container-solution-for-linux/&#34;&gt;はじまりました&lt;/a&gt;。OMSのログ分析機能は500MB/日のログ転送まで無料で使えるので、利用者も多いのではないでしょうか。&lt;/p&gt;

&lt;p&gt;さて、このたびプレビュー開始したLinuxコンテナのログ分析機能、サクッと使えるので紹介します。まだプレビューなので、仕様が変わったらごめんなさい。&lt;/p&gt;

&lt;h2 id=&#34;何ができるか-とその特徴&#34;&gt;何ができるか、とその特徴&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dockerコンテナに関わるログの収集と分析、ダッシュボード表示

&lt;ul&gt;
&lt;li&gt;収集データの詳細 - &lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/log-analytics-containers/#containers-data-collection-details&#34;&gt;Containers data collection details&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;導入が楽ちん

&lt;ol&gt;
&lt;li&gt;OMSエージェントコンテナを導入し、コンテナホスト上のすべてのコンテナのログ分析ができる&lt;/li&gt;
&lt;li&gt;コンテナホストに直接OMS Agentを導入することもできる&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1がコンテナ的でいいですよね。実現イメージはこんな感じです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://msdnshared.blob.core.windows.net/media/2016/08/3-OMS-082416.png&#34; alt=&#34;OMS Agent Installation Type&#34; title=&#34;from microsoft.com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これであれば、CoreOSのような「コンテナホストはあれこれいじらない」というポリシーのディストリビューションにも対応できます。&lt;/p&gt;

&lt;p&gt;では試しに、1のやり口でUbuntuへ導入してみましょう。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OMSのログ分析機能を有効化しワークスペースを作成、IDとKeyを入手 (&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/log-analytics-get-started/&#34;&gt;参考&lt;/a&gt;)

&lt;ul&gt;
&lt;li&gt;Azureのサブスクリプションを持っている場合、&amp;rdquo;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/log-analytics-get-started/#microsoft-azure&#34;&gt;Microsoft Azure を使用した迅速なサインアップ&lt;/a&gt;&amp;ldquo;から読むと、話が早いです&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OMSポータルのソリューションギャラリーから、&amp;rdquo;Containers&amp;rdquo;を追加&lt;/li&gt;
&lt;li&gt;UbuntuにDockerを導入

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/ubuntulinux/&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;現在、OMSエージェントが対応するDockerバージョンは 1.11.2までなので、たとえばUbuntu 16.04の場合は sudo apt-get install docker-engine=1.11.2-0~xenial とするなど、バージョン指定してください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OMSエージェントコンテナを導入

&lt;ul&gt;
&lt;li&gt;先ほど入手したOMSのワークスペースIDとKeyを入れてください&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run --privileged -d -v /var/run/docker.sock:/var/run/docker.sock -e WSID=&amp;quot;your workspace id&amp;quot; -e KEY=&amp;quot;your key&amp;quot; -h=`hostname` -p 127.0.0.1:25224:25224/udp -p 127.0.0.1:25225:25225 --name=&amp;quot;omsagent&amp;quot; --log-driver=none --restart=always microsoft/oms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上。これでOMSポータルからログ分析ができます。こんな感じで。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://acom.azurecomcdn.net/80C57D/cdn/mediahandler/docarticles/dpsmedia-prod/azure.microsoft.com/en-us/documentation/articles/log-analytics-containers/20160824105310/containers-dash01.png&#34; alt=&#34;Dashboard1&#34; title=&#34;from microsoft.com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://acom.azurecomcdn.net/80C57D/cdn/mediahandler/docarticles/dpsmedia-prod/azure.microsoft.com/en-us/documentation/articles/log-analytics-containers/20160824105310/containers-dash02.png&#34; alt=&#34;Dashboard2&#34; title=&#34;from microsoft.com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;なんと簡単じゃありませんか。詳細が気になるかたは、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/log-analytics-containers/&#34;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;

&lt;p&gt;なお、フィードバック&lt;a href=&#34;https://blogs.technet.microsoft.com/msoms/2016/08/24/announcing-public-preview-oms-container-solution-for-linux/&#34;&gt;熱烈歓迎&lt;/a&gt;だそうです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker for WindowsでインストールレスAzure CLI環境を作る</title>
      <link>http://torumakabe.github.io/post/dockerforwin_azurecli/</link>
      <pubDate>Wed, 22 Jun 2016 15:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/dockerforwin_azurecli/</guid>
      <description>

&lt;h2 id=&#34;舌の根の乾かぬ内に&#34;&gt;舌の根の乾かぬ内に&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://torumakabe.github.io/post/azure_osstools_iac/&#34;&gt;最近&lt;/a&gt;、VagrantとVirualBoxで似たようなやり口を紹介しましたが、気にしないでください。テクノロジーの進化は早い。&lt;/p&gt;

&lt;h2 id=&#34;動機&#34;&gt;動機&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker for Windows(on Client Hyper-V)のベータが一般開放された&lt;/li&gt;
&lt;li&gt;Dockerもそうだが、Hyper-V前提のツールが今後増えそう、となると、それとぶつかるVirtualBoxをぼちぼちやめたい&lt;/li&gt;
&lt;li&gt;月一ペースでアップデートされるAzure CLIをいちいちインストールしたくない、コンテナ引っ張って以上、にしたい&lt;/li&gt;
&lt;li&gt;開発端末の環境を汚したくない、いつでもきれいに作り直せるようにしたい&lt;/li&gt;
&lt;li&gt;○○レスって言ってみたかった&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;やり口&#34;&gt;やり口&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;もちろんDocker for Windows (on Client Hyper-V) を使う&lt;/li&gt;
&lt;li&gt;いちいちdocker run&amp;hellip;と打たなくていいよう、エイリアス的にPowerShellのfunction &amp;ldquo;azure_cli&amp;rdquo; を作る&lt;/li&gt;
&lt;li&gt;&amp;ldquo;azure_cli&amp;rdquo;入力にてAzure CLIコンテナを起動&lt;/li&gt;
&lt;li&gt;コンテナとホスト(Windows)間でファイル共有、ホスト側のIDEなりエディタを使えるようにする&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作業の中身&#34;&gt;作業の中身&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker for Windowsを&lt;a href=&#34;https://docs.docker.com/docker-for-windows/&#34;&gt;インストール&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;64bit Windows 10 Pro/Enterprise/Education 1511以降に対応&lt;/li&gt;
&lt;li&gt;Hyper-Vの有効化を忘れずに&lt;/li&gt;
&lt;li&gt;Hyper-VとぶつかるVirtualBoxとはお別れです&lt;/li&gt;
&lt;li&gt;Docker for Windowsの起動時にIPをとれないケースがありますが、その場合はsettings -&amp;gt; Network から、設定変えずにApplyしてみてください。いまのところこれで対処できています。この辺はベータなので今後の調整を期待しましょう。&lt;/li&gt;
&lt;li&gt;共有ドライブも共有が外れていることが。settings -&amp;gt; Shared Drives で共有しなおしてください。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PowerShell functionを作成

&lt;ul&gt;
&lt;li&gt;のちほど詳しく&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;powershellのfunctionを作る&#34;&gt;PowerShellのfunctionを作る&lt;/h2&gt;

&lt;p&gt;ここが作業のハイライト。&lt;/p&gt;

&lt;p&gt;PowerShellのプロファイルを編集します。ところでエディタはなんでもいいのですが、AzureやDockerをがっつり触る人にはVS Codeがおすすめです。&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools&#34;&gt;Azure Resource Manager Template&lt;/a&gt;や&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=PeterJausovec.vscode-docker&#34;&gt;Docker&lt;/a&gt;むけextensionがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\Workspace\dockereval\arm&amp;gt; code $profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなfunctionを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function azure_cli {
   C:\PROGRA~1\Docker\Docker\Resources\bin\docker.exe run -it --rm -v ${HOME}/.azure:/root/.azure -v ${PWD}:/data -w /data microsoft/azure-cli:latest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;エイリアスでなくfunctionにした理由は、引数です。エイリアスだと引数を渡せないので&lt;/li&gt;
&lt;li&gt;コンテナが溜まるのがいやなので、&amp;ndash;rmで都度消します&lt;/li&gt;
&lt;li&gt;毎度 azure login しなくていいよう、トークンが保管されるコンテナの/root/azureディレクトリをホストの${HOME}/.azureと-v オプションで共有します&lt;/li&gt;
&lt;li&gt;ARM TemplateのJSONファイルなど、ホストからファイルを渡したいため、カレントディレクトリ ${PWD} をコンテナと -v オプションで共有します&lt;/li&gt;
&lt;li&gt;コンテナはdocker hubのMicrosoft公式イメージ、latestを引っ張ります。latestで不具合あればバージョン指定してください&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ではテスト。まずはホスト側のファイルを確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\Workspace\dockereval\arm&amp;gt; ls


    ディレクトリ: C:\Workspace\dockereval\arm


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----       2016/06/22     11:21                subd
-a----       2016/06/22     10:26           8783 azuredeploy.json
-a----       2016/06/22     11:28            690 azuredeploy.parameters.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつかのファイルとサブディレクトリがあります。&lt;/p&gt;

&lt;p&gt;コンテナを起動してみましょう。azure_cli functionを呼びます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\Workspace\dockereval\arm&amp;gt; azure_cli
root@be41d3389a21:/data#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナを起動し、入出力をつなぎました。ここからは頭と手をLinuxに切り替えてください。公式Azure CLIコンテナは&lt;a href=&#34;https://hub.docker.com/r/microsoft/azure-cli/~/dockerfile/&#34;&gt;debianベース&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;ファイル共有できているか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@be41d3389a21:/data# ls
azuredeploy.json  azuredeploy.parameters.json  subd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できてますね。&lt;/p&gt;

&lt;p&gt;azureコマンドが打てるか確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@be41d3389a21:/data# azure -v
0.10.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しあわせ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure X-Plat CLIでResource Policyを設定する</title>
      <link>http://torumakabe.github.io/post/azure_cli_resourcepolicy/</link>
      <pubDate>Sat, 21 May 2016 11:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_cli_resourcepolicy/</guid>
      <description>

&lt;h2 id=&#34;azure-x-plat-cliのリリースサイクル&#34;&gt;Azure X-Plat CLIのリリースサイクル&lt;/h2&gt;

&lt;p&gt;OSS/Mac/Linux派なAzurerの懐刀、Azure X-Plat CLIのリリースサイクルは、おおよそ&lt;a href=&#34;https://github.com/Azure/azure-xplat-cli/releases&#34;&gt;月次&lt;/a&gt;です。改善と機能追加を定期的にまわしていくことには意味があるのですが、いっぽう、Azureの機能追加へタイムリーに追随できないことがあります。短期間とはいえ、次のリリースまで空白期間ができてしまうのです。&lt;/p&gt;

&lt;p&gt;たとえば、今回のテーマであるResource Policy。GA直後に公開された&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/resource-manager-policy/&#34;&gt;ドキュメント&lt;/a&gt;に、X-Plat CLIでの使い方が2016/5/21現在書かれていません。おやCLIではできないのかい、と思ってしまいますね。でもその後のアップデートで、できるようになりました。&lt;/p&gt;

&lt;p&gt;機能リリース時点ではCLIでできなかった、でもCLIの月次アップデートで追加された、いまはできる、ドキュメントの更新待ち。こんなパターンは多いので、あきらめずに探ってみてください。&lt;/p&gt;

&lt;h2 id=&#34;ポリシーによるアクセス管理&#34;&gt;ポリシーによるアクセス管理&lt;/h2&gt;

&lt;p&gt;さて本題。リソースの特性に合わせて、きめ細かいアクセス管理をしたいことがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VMやストレージのリソースタグに組織コードを入れること強制し、費用負担の計算に使いたい&lt;/li&gt;
&lt;li&gt;日本国外リージョンのデータセンタを使えないようにしたい&lt;/li&gt;
&lt;li&gt;Linuxのディストリビューションを標準化し、その他のディストリビューションは使えなくしたい&lt;/li&gt;
&lt;li&gt;開発環境リソースグループでは、大きなサイズのインスタンスを使えないようにしたい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などなど。こういう課題にポリシーが効きます。&lt;/p&gt;

&lt;p&gt;従来からあるRBACは「役割と人」目線です。「この役割を持つ人は、このリソースを読み取り/書き込み/アクションできる」という表現をします。&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/role-based-access-built-in-roles/&#34;&gt;組み込みロールの一覧&lt;/a&gt;を眺めると、理解しやすいでしょう。&lt;/p&gt;

&lt;p&gt;ですが、RBACは役割と人を切り口にしているので、各リソースの多様な特性にあわせた統一表現が難しいです。たとえばストレージにはディストリビューションという属性はありません。無理してカスタム属性なんかで表現すると破綻しそうです。&lt;/p&gt;

&lt;p&gt;リソース目線でのアクセス管理もあったほうがいい、ということで、ポリシーの出番です。もちろんRBACと、組み合わせできます。&lt;/p&gt;

&lt;h2 id=&#34;x-plat-cliでの定義方法&#34;&gt;X-Plat CLIでの定義方法&lt;/h2&gt;

&lt;p&gt;2016/4リリースの&lt;a href=&#34;https://github.com/Azure/azure-xplat-cli/releases/tag/v0.9.20-April2016&#34;&gt;v0.9.20&lt;/a&gt;から、X-Plat CLIでもResource Policyを定義できます。&lt;/p&gt;

&lt;p&gt;ポリシーの定義、構文はPowerShellと同じなので、公式ドキュメントに任せます。ご一読を。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/resource-manager-policy/&#34;&gt;ポリシーを使用したリソース管理とアクセス制御&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;X-Plat CLI固有部分に絞って紹介します。&lt;/p&gt;

&lt;h3 id=&#34;ポリシー定義ファイルを作る&#34;&gt;ポリシー定義ファイルを作る&lt;/h3&gt;

&lt;p&gt;CLIでインラインに書けるようですが、人類には早すぎる気がします。ここではファイルに。&lt;/p&gt;

&lt;p&gt;例として、作成できるVMのサイズを限定してみましょう。開発環境などでよくあるパターンと思います。VM作成時、Standard_D1～5_v2に当てはまらないVMサイズが指定されると、拒否します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;if&amp;quot;: {
    &amp;quot;allOf&amp;quot;: [
      {
        &amp;quot;field&amp;quot;: &amp;quot;type&amp;quot;,
        &amp;quot;equals&amp;quot;: &amp;quot;Microsoft.Compute/virtualMachines&amp;quot;
      },
      {
        &amp;quot;not&amp;quot;: {
          &amp;quot;field&amp;quot;: &amp;quot;Microsoft.Compute/virtualMachines/sku.name&amp;quot;,
          &amp;quot;in&amp;quot;: [ &amp;quot;Standard_D1_v2&amp;quot;, &amp;quot;Standard_D2_v2&amp;quot;,&amp;quot;Standard_D3_v2&amp;quot;, &amp;quot;Standard_D4_v2&amp;quot;, &amp;quot;Standard_D5_v2&amp;quot; ]
        }
      }
    ]
  },
  &amp;quot;then&amp;quot;: {
    &amp;quot;effect&amp;quot;: &amp;quot;deny&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;policy_deny_vmsize.json というファイル名にしました。では投入。ポリシー名は deny_vmsize とします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ azure policy definition create -n deny_vmsize -p ./policy_deny_vmsize.json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;info:    Executing command policy definition create
+ Creating policy definition deny_vmsize
data:    PolicyName:             deny_vmsize
data:    PolicyDefinitionId:     /subscriptions/mysubscription/providers/Microsoft.Authorization/policyDefinitions/deny_vmsize
data:    PolicyType:             Custom
data:    DisplayName:
data:    Description:
data:    PolicyRule:             allOf=[field=type, equals=Microsoft.Compute/virtualMachines, field=Microsoft.Compute/virtualMachines/sku.name, in=[Standard_D1_v2, Standard_D2_v2, Standard_D3_v2, Standard_D4_v2, Standard_D5_v2]], effect=deny
info:    policy definition create command OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できたみたいです。&lt;/p&gt;

&lt;h3 id=&#34;ポリシーをアサインする&#34;&gt;ポリシーをアサインする&lt;/h3&gt;

&lt;p&gt;では、このポリシーを割り当てます。割り当ての範囲(スコープ)はサブスクリプションとします。リソースグループなど、より細かいスコープも&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/azure/mt588464.aspx&#34;&gt;指定可能&lt;/a&gt;です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ azure policy assignment create -n deny_vmsize_assignment -p /subscriptions/mysubscription/providers/Microsoft.Authorization/policyDefinitions/deny_vmsize -s /subscriptions/mysubscription
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;info:    Executing command policy assignment create
+ Creating policy assignment deny_vmsize_assignment
data:    PolicyAssignmentName:     deny_vmsize_assignment
data:    Type:                     Microsoft.Authorization/policyAssignments
data:    DisplayName:
data:    PolicyDefinitionId:       /subscriptions/mysubscription/providers/Microsoft.Authorization/policyDefinitions/deny_vmsize
data:    Scope:                    /subscriptions/mysubscription
info:    policy assignment create command OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割り当て完了。では試しに、このサブスクリプションに属するユーザで、Gシリーズのゴジラ級インスタンスを所望してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ azure vm quick-create -g RPPoC -n rppocvm westus -y Linux -Q &amp;quot;canonical:ubuntuserver:14.04.4-LTS:latest&amp;quot; -u &amp;quot;adminname&amp;quot; -p &amp;quot;adminpass&amp;quot; -z Standard_G5
info:    Executing command vm quick-create
[...snip]
+ Creating VM &amp;quot;rppocvm&amp;quot;
error:   The resource action &#39;Microsoft.Compute/virtualMachines/write&#39; is disallowed by one or more policies. Policy identifier(s): &#39;/subscriptions/mysubscription/providers/Microsoft.Authorization/policyDefinitions/deny_vmsize&#39;.
info:    Error information has been recorded to /root/.azure/azure.err
error:   vm quick-create command failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拒否られました。&lt;/p&gt;

&lt;p&gt;許可されているVMサイズだと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ azure vm quick-create -g RPPoC -n rppocvm westus -y Linux -Q &amp;quot;canonical:ubuntuserver:14.04.4-LTS:latest&amp;quot; -u &amp;quot;adminname&amp;quot; -p &amp;quot;adminpass&amp;quot; -z Standard_D1_v2
info:    Executing command vm quick-create
[...snip]
info:    vm quick-create command OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VagrantとDockerによるAzure向けOSS開発・管理端末のコード化</title>
      <link>http://torumakabe.github.io/post/azure_osstools_iac/</link>
      <pubDate>Fri, 13 May 2016 18:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_osstools_iac/</guid>
      <description>

&lt;h2 id=&#34;端末だってコード化されたい&#34;&gt;端末だってコード化されたい&lt;/h2&gt;

&lt;p&gt;Infrastructure as Codeは特に騒ぐ話でもなくなってきました。このエントリは、じゃあ端末の開発環境やツール群もコード化しようという話です。結論から書くと、VagrantとDockerを活かします。超絶便利なのにAzure界隈ではあまり使われてない印象。もっと使われていいのではと思い、書いております。&lt;/p&gt;

&lt;h2 id=&#34;解決したい課題&#34;&gt;解決したい課題&lt;/h2&gt;

&lt;p&gt;こんな悩みを解決します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WindowsでOSS開発環境、Azure管理ツールのセットアップをするのがめんどくさい&lt;/li&gt;
&lt;li&gt;WindowsもMacも使っているので、どちらでも同じ環境を作りたい&lt;/li&gt;
&lt;li&gt;サーバはLinuxなので手元にもLinux環境欲しいけど、Linuxデスクトップはノーサンキュー&lt;/li&gt;
&lt;li&gt;2016年にもなって長いコードをVimとかEmacsで書きたくない&lt;/li&gt;
&lt;li&gt;Hyper-VとかVirtualboxで仮想マシンのセットアップと起動、後片付けをGUIでするのがいちいちめんどくさい&lt;/li&gt;
&lt;li&gt;仮想マシン起動したあとにターミナル起動-&amp;gt;IP指定-&amp;gt;ID/Passでログインとか、かったるい&lt;/li&gt;
&lt;li&gt;Azure CLIやTerraformなどクラウド管理ツールの進化が頻繁でつらい(月一回アップデートとか)&lt;/li&gt;
&lt;li&gt;でもアップデートのたびに超絶便利機能が追加されたりするので、なるべく追いかけたい&lt;/li&gt;
&lt;li&gt;新メンバーがチームに入るたび、セットアップが大変&lt;/li&gt;
&lt;li&gt;不思議とパソコンが生えてくる部屋に住んでおり、セットアップが大変&lt;/li&gt;
&lt;li&gt;毎度作業のどこかが抜ける、漏れる、間違う 人間だもの&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;やり口&#34;&gt;やり口&lt;/h2&gt;

&lt;p&gt;VagrantとDockerで解決します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windows/Macどちらにも対応しているVirtualboxでLinux仮想マシンを作る&lt;/li&gt;
&lt;li&gt;Vagrantでセットアップを自動化する&lt;/li&gt;
&lt;li&gt;Vagrantfile(RubyベースのDSL)でシンプルに環境をコード化する&lt;/li&gt;
&lt;li&gt;Vagrant Puttyプラグインを使って、Windowsでもsshログインを簡素化する&lt;/li&gt;
&lt;li&gt;公式dockerイメージがあるツールは、インストールせずコンテナを引っ張る&lt;/li&gt;
&lt;li&gt;Windows/MacのいまどきなIDEなりエディタを使えるようにする&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;セットアップ概要&#34;&gt;セットアップ概要&lt;/h2&gt;

&lt;p&gt;簡単す。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Virtualboxを&lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;インストール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vagrantを&lt;a href=&#34;https://www.vagrantup.com/downloads.html&#34;&gt;インストール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vagrant Putty Plugin(vagrant-multi-putty)を&lt;a href=&#34;https://github.com/nickryand/vagrant-multi-putty&#34;&gt;インストール&lt;/a&gt; #Windowsのみ。Puttyは別途入れてください&lt;/li&gt;
&lt;li&gt;作業フォルダを作り、Vagrant ファイルを書く&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;もしWindowsでうまく動かない時は、Hyper-Vが有効になっていないか確認しましょう。Virtualboxと共存できません。&lt;/p&gt;

&lt;h2 id=&#34;サンプル解説&#34;&gt;サンプル解説&lt;/h2&gt;

&lt;p&gt;OSSなAzurerである、わたしのVagrantfileです。日々環境に合わせて変えてますが、以下は現時点でのスナップショット。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don&#39;t touch unless you know what you&#39;re doing!
VAGRANTFILE_API_VERSION = &amp;quot;2&amp;quot;

$bootstrap=&amp;lt;&amp;lt;SCRIPT

#Common tools
sudo apt-get update
sudo apt-get -y install wget unzip jq

#Docker Engine
sudo apt-get -y install apt-transport-https ca-certificates
sudo apt-get -y install linux-image-extra-$(uname -r)
sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
sudo sh -c &amp;quot;echo deb https://apt.dockerproject.org/repo ubuntu-trusty main &amp;gt; /etc/apt/sources.list.d/docker.list&amp;quot;
sudo apt-get update
sudo apt-get -y purge lxc-docker
sudo apt-cache policy docker-engine
sudo apt-get -y install docker-engine=1.11.1-0~trusty
sudo gpasswd -a vagrant docker
sudo service docker restart

#Docker Machine
sudo sh -c &amp;quot;curl -L https://github.com/docker/machine/releases/download/v0.7.0/docker-machine-`uname -s`-`uname -m` &amp;gt;/usr/local/bin/docker-machine &amp;amp;&amp;amp; chmod +x /usr/local/bin/docker-machine&amp;quot;

#Azure CLI
echo &amp;quot;alias azure=&#39;docker run -it --rm -v \\\$HOME/.azure:/root/.azure -v \\\$PWD:/data -w /data microsoft/azure-cli:latest azure&#39;&amp;quot; &amp;gt;&amp;gt; $HOME/.bashrc

#Terraform
echo &amp;quot;alias terraform=&#39;docker run -it --rm -v \\\$PWD:/data -w /data hashicorp/terraform:0.6.14&#39;&amp;quot; &amp;gt;&amp;gt; $HOME/.bashrc

#Packer
echo &amp;quot;alias packer=&#39;docker run -it --rm -v \\\$PWD:/data -w /data hashicorp/packer:latest&#39;&amp;quot; &amp;gt;&amp;gt; $HOME/.bashrc

#nodebrew
curl -L git.io/nodebrew | perl - setup
echo &#39;export PATH=$HOME/.nodebrew/current/bin:$PATH&#39; &amp;gt;&amp;gt; $HOME/.bashrc
$HOME/.nodebrew/current/bin/nodebrew install-binary 5.9.1
$HOME/.nodebrew/current/bin/nodebrew use 5.9.1

#Python3
wget -qO- https://bootstrap.pypa.io/get-pip.py | sudo -H python3.4

SCRIPT

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # Every Vagrant virtual environment requires a box to build off of.

  config.vm.box = &amp;quot;ubuntu/trusty64&amp;quot;

  # Create a private network, which allows host-only access to the machine
  # using a specific IP.

  config.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;192.168.33.10&amp;quot;

  config.vm.provider &amp;quot;virtualbox&amp;quot; do |vb|
     vb.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--memory&amp;quot;, &amp;quot;2048&amp;quot;]
  end

  config.vm.provision :shell, inline: $bootstrap, privileged: false

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$bootstrap=&amp;lt;&amp;lt;SCRIPT から SCRIPT が、プロビジョニングシェルです。初回のvagrant up時とvagrant provision時に実行されます。&lt;/p&gt;

&lt;h3 id=&#34;common-tools&#34;&gt;Common tools&lt;/h3&gt;

&lt;p&gt;一般的なツールをaptでインストールします。wgetとかjqとか。&lt;/p&gt;

&lt;h3 id=&#34;docker-engine-machine&#34;&gt;Docker Engine &amp;amp; Machine&lt;/h3&gt;

&lt;p&gt;この後前提となるDockerをインストール。Dockerのバージョンは1.11.1を明示しています。Dockerは他への影響が大きいので、バージョンアップは慎重めの方針です。&lt;/p&gt;

&lt;h3 id=&#34;azure-cli&#34;&gt;Azure CLI&lt;/h3&gt;

&lt;p&gt;インストールせずに&lt;a href=&#34;https://hub.docker.com/r/microsoft/azure-cli/&#34;&gt;MS公式のDockerイメージ&lt;/a&gt;を引っ張ります。なのでalias設定だけ。
-v オプションで、ホストLinuxとコンテナ間でデータを共有します。CLIが使う認証トークン($HOME/.azure下)やCLI実行時に渡すjsonファイル(作業ディレクトリ)など。詳細は後ほど。
また、azureコマンド発行ごとにコンテナが溜まっていくのがつらいので、&amp;ndash;rmで消します。&lt;/p&gt;

&lt;h3 id=&#34;terraform-packer&#34;&gt;Terraform &amp;amp; Packer&lt;/h3&gt;

&lt;p&gt;Azure CLIと同様です。Hashicorpが&lt;a href=&#34;https://hub.docker.com/u/hashicorp/&#34;&gt;公式イメージ&lt;/a&gt;を提供しているので、それを活用します。
方針はlatest追いですが、不具合があればバージョンを指定します。たとえば、現状Terraformのlatestイメージに不具合があるので、0.6.14を指定しています。
-v オプションもAzure CLIと同じ。ホストとコンテナ間のファイルマッピングに使います。&lt;/p&gt;

&lt;p&gt;なお、公式とはいえ他人のイメージを使う時には、Dockerfileの作りやビルド状況は確認しましょう。危険がデンジャラスですし、ENTRYPOINTとか知らずにうっかり使うと途方に暮れます。&lt;/p&gt;

&lt;h3 id=&#34;nodebrew&#34;&gt;nodebrew&lt;/h3&gt;

&lt;p&gt;nodeのバージョンを使い分けるため。セットアップ時にv5.9.1を入れています。Azure Functions開発向け。&lt;/p&gt;

&lt;h3 id=&#34;python3&#34;&gt;Python3&lt;/h3&gt;

&lt;p&gt;Ubuntu 14.04では標準がPython2なので別途入れてます。Azure Batch向け開発でPython3使いたいので。&lt;/p&gt;

&lt;p&gt;みなさん他にもいろいろあるでしょう。シェルなのでお好みで。&lt;/p&gt;

&lt;p&gt;さて、ここまでがプロビジョニング時の処理です。以降の&amp;rdquo;Vagrant.configure～&amp;rdquo;は仮想マシンの定義で、難しくありません。ubuntu/trusty64(14.04)をboxイメージとし、IPやメモリを指定し、先ほど定義したプロビジョニング処理を指しているだけです。&lt;/p&gt;

&lt;h2 id=&#34;どれだけ楽か&#34;&gt;どれだけ楽か&lt;/h2&gt;

&lt;p&gt;では、環境を作ってみましょう。Vagrantfileがあるフォルダで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仮想マシンが作成されます。初回はプロビジョニング処理も走ります。&lt;/p&gt;

&lt;p&gt;できましたか。できたら、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant putty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はい。Puttyが起動し、ID/Passを入れなくてもsshログインします。破壊力抜群。わたしはこの魅力だけでTeraterm(Terraformではない)からPuttyに乗り換えました。ちなみにMacでは、vagrant sshで済みます。&lt;/p&gt;

&lt;p&gt;あとはプロビジョニングされたLinuxを使って楽しんでください。そして、必要なくなったら or 作り直したくなったら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant destroy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;綺麗さっぱりです。仮想マシンごと消します。消さずにまた使う時は、vagrant haltを。&lt;/p&gt;

&lt;p&gt;なお、vagrant upしたフォルダにあるファイルは、Virtualboxの共有フォルダ機能で仮想マシンと共有されます。shareとかいう名のフォルダを作って、必要なファイルを放り込んでおきましょう。その場合、仮想マシンのUbuntuからは/vagrant/shareと見えます。双方向で同期されます。&lt;/p&gt;

&lt;p&gt;わたしは長いコードを書くときは、Windows/Mac側のIDEなりエディタを使って、実行は仮想マシンのLinux側、という流れで作業しています。&lt;/p&gt;

&lt;p&gt;ちなみに、改行コードの違いやパーミッションには気を付けてください。改行コードはLFにする癖をつけておくと幸せになれます。パーミッションは全開、かつ共有領域では変えられないので、問題になるときは仮想マシン側で/vagrant外にコピーして使ってください。パーミッション全開だと怒られる認証鍵など置かないよう、注意。&lt;/p&gt;

&lt;p&gt;また、Dockerコンテナを引っ張るAzure CLI、Terraform、Packerの注意点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初回実行時にイメージのPullを行うので、帯域の十分なところでやりましょう&lt;/li&gt;
&lt;li&gt;サンプルでは -v $PWD:/data オプションにて、ホストのカレントディレクトリをコンテナの/dataにひもづけています。そして、-w /data にて、コンテナ内ワーキングディレクトリを指定しています。コマンドの引数でファイル名を指定したい場合は、実行したいファイルがあるディレクトリに移動して実行してください

&lt;ul&gt;
&lt;li&gt;(例) azure group deployment create RG01 DEP01 -f ./azuredeploy.json -e ./azuredeploy.parameters.json&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bash-on-windowsまで待つとか言わない&#34;&gt;Bash on Windowsまで待つとか言わない&lt;/h2&gt;

&lt;p&gt;「WindowsではOSSの開発や管理がしにくい。Bash on Windowsが出てくるまで待ち」という人は、待たないで今すぐGoです。思い立ったが吉日です。繰り返しますがVagrantとDocker、超絶便利です。&lt;/p&gt;

&lt;p&gt;インフラのコード化なんか信用ならん！という人も、まず今回紹介したように端末からはじめてみたらいかがでしょう。激しく生産性上がると思います。&lt;/p&gt;

&lt;p&gt;夏近し、楽して早く帰ってビール呑みましょう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Azure FunctionsとFacebook Messenger APIで好みなんて聞いてないBotを作る</title>
      <link>http://torumakabe.github.io/post/azure_functions_fbmsgapi/</link>
      <pubDate>Sun, 08 May 2016 14:00:00 +0900</pubDate>
      
      <guid>http://torumakabe.github.io/post/azure_functions_fbmsgapi/</guid>
      <description>

&lt;h2 id=&#34;まだ好みなんて聞いてないぜ&#34;&gt;まだ好みなんて聞いてないぜ&lt;/h2&gt;

&lt;p&gt;Build 2016で、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/services/functions/&#34;&gt;Azure Functions&lt;/a&gt;が発表されました。&lt;/p&gt;

&lt;p&gt;Azure Functionsは、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;アプリを放り込めば動く。サーバの管理が要らない。サーバレス。  #でもこれは従来のPaaSもそう&lt;/li&gt;
&lt;li&gt;利用メモリ単位での、粒度の細かい課金。  #現在プレビュー中にて、詳細は今後発表&lt;/li&gt;
&lt;li&gt;Azure内外機能との、容易なイベント連動。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;が特徴です。AWSのLambdaと似てるっちゃ似ています。&lt;/p&gt;

&lt;p&gt;何が新しいかというと、特に3つ目の特徴、イベント連動です。触ってみなければわからん、ということで、流行りのBotでも作ってみたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;基本方針&#34;&gt;基本方針&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;FunctionsはAzure内の様々な機能と&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/functions-reference/#bindings&#34;&gt;イベント連動&lt;/a&gt;できるが、あえてサンプルの少ないAzure外とつないでみる&lt;/li&gt;
&lt;li&gt;Facebook Messenger APIを使って、webhook連動する&lt;/li&gt;
&lt;li&gt;Facebook Messenger向けに書き込みがあると、ランダムでビールの種類と参考URLを返す&lt;/li&gt;
&lt;li&gt;ビールは&lt;a href=&#34;http://beertaster.org/beerstyle/web/beerstyle_main_j.html&#34;&gt;Craft Beer Association&lt;/a&gt;の分類に従い、協会のビアスタイル・ガイドライン参考ページの該当URLを返す&lt;/li&gt;
&lt;li&gt;Botらしく、それらしい文末表現をランダムで返す&lt;/li&gt;
&lt;li&gt;好みとか文脈は全く聞かないぜSorry&lt;/li&gt;
&lt;li&gt;アプリはNodeで書く。C#のサンプルは増えてきたので&lt;/li&gt;
&lt;li&gt;静的データをランダムに返す、かつ少量なのでメモリ上に広げてもいいが、せっかくなのでNodeと相性のいいDocumentDBを使う&lt;/li&gt;
&lt;li&gt;DocumentDBではSQLでいうORDER BY RAND()のようなランダムな問い合わせを書けないため、ストアドプロシージャで実装する  #&lt;a href=&#34;https://gist.github.com/murdockcrc/12266f9d844be416a6a0&#34;&gt;サンプル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FunctionsとGithubを連携し、GithubへのPush -&amp;gt; Functionsへのデプロイというフローを作る&lt;/li&gt;
&lt;li&gt;拡張性はひとまず目をつぶる  #&lt;a href=&#34;http://qiita.com/yoichiro@github/items/6d4c7309210af20a5c8f&#34;&gt;この辺の話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ひとまずFunctionsとBotの枠組みの理解をゴールとします。ロジックをたくさん書けばそれなりに文脈を意識した返事はできるのですが、書かずに済む仕組みがこれからいろいろ出てきそうなので、書いたら負けの精神でぐっと堪えます。&lt;/p&gt;

&lt;h2 id=&#34;必要な作業&#34;&gt;必要な作業&lt;/h2&gt;

&lt;p&gt;以下が必要な作業の流れです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Azureで

&lt;ul&gt;
&lt;li&gt;Function Appの作成  #1&lt;/li&gt;
&lt;li&gt;Bot用Functionの作成 #2&lt;/li&gt;
&lt;li&gt;Facebook Messenger APIとの接続検証  #6&lt;/li&gt;
&lt;li&gt;Facebook Messenger API接続用Tokenの設定  #8&lt;/li&gt;
&lt;li&gt;DocumentDBのデータベース、コレクション作成、ドキュメント投入  #9&lt;/li&gt;
&lt;li&gt;DocumentDBのストアドプロシージャ作成  #10&lt;/li&gt;
&lt;li&gt;Function Appを書く  #11&lt;/li&gt;
&lt;li&gt;FunctionsのサイトにDocumentDB Node SDKを導入 #12&lt;/li&gt;
&lt;li&gt;Function AppのGithub連携設定  #13&lt;/li&gt;
&lt;li&gt;Function Appのデプロイ (GithubへのPush)  #14&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Facebookで

&lt;ul&gt;
&lt;li&gt;Facebook for Developersへの登録  #3&lt;/li&gt;
&lt;li&gt;Botをひも付けるFacebook Pageの作成  #4&lt;/li&gt;
&lt;li&gt;Bot用マイアプリの作成  #5&lt;/li&gt;
&lt;li&gt;Azure Functionsからのcallback URLを登録、接続検証  #6&lt;/li&gt;
&lt;li&gt;Azure Functions向けTokenを生成 #7&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アプリのコード書きの他はそれほど重くない作業ですが、すべての手順を書くと本ができそうです。Function Appの作りにポイントを絞りたいので、以下、参考になるサイトをご紹介します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function Appを書くまで、#1〜2、#5〜8は、&lt;a href=&#34;http://oauth.jp/blog/2016/04/19/fb-message-callback-with-azure-function/&#34;&gt;こちらのブログエントリ&lt;/a&gt;がとても参考になります。&lt;/li&gt;
&lt;li&gt;Facebook for Developersへの登録、#3は、&lt;a href=&#34;https://developers.facebook.com/&#34;&gt;https://developers.facebook.com/&lt;/a&gt; から。いきなり迷子の人は、&lt;a href=&#34;http://qiita.com/k_kuni/items/3d7176ee4e3009b45dd8&#34;&gt;こちら&lt;/a&gt;も参考に。&lt;/li&gt;
&lt;li&gt;Facebook Pageの作成は、&lt;a href=&#34;http://allabout.co.jp/gm/gc/387840/&#34;&gt;ここ&lt;/a&gt;を。Botで楽しむだけなら細かい設定は後回しでいいです。&lt;/li&gt;
&lt;li&gt;DocumentDBについては、&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-introduction/&#34;&gt;公式&lt;/a&gt;を。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-create-account/&#34;&gt;DBアカウント〜コレクション作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-import-data/&#34;&gt;ドキュメントインポート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/ja-jp/documentation/articles/documentdb-programming/&#34;&gt;ストアドプロシージャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;FunctionsのサイトにDocumentDB Node SDKを導入する#12は、&lt;a href=&#34;http://tech.guitarrapc.com/entry/2016/04/05/043723&#34;&gt;こちら&lt;/a&gt;を。コンソールからnpm installできます。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Github連携設定、#13〜14は、&lt;a href=&#34;http://tech.guitarrapc.com/entry/2016/04/03/051552&#34;&gt;こちら&lt;/a&gt;がとても参考になります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;function-appのサンプル&#34;&gt;Function Appのサンプル&lt;/h2&gt;

&lt;p&gt;Githubにソースを&lt;a href=&#34;https://github.com/ToruMakabe/MakabeerBot&#34;&gt;置いておきます&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ちなみにこのディレクトリ階層はGithub連携を考慮し、Function Appサイトのそれと合わせています。以下がデプロイ後のサイト階層です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\home\site\wwwroot
├── fb-message-callback
│   ├── TestOutput.json
│   ├── function.json
│   └── index.js  #これが今回のアプリ
├── node_modules  #DocumentDB Node SDKが入っている
├── host.json
├── README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、DocumentDBのSDKパッケージは、なぜかfb-message-callbackローカルに置くと読み込まれないため、暫定的にルートへ配置しています。&lt;/p&gt;

&lt;p&gt;ではFunction Appの実体、index.jsを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var https = require(&#39;https&#39;);
var documentClient = require(&amp;quot;documentdb&amp;quot;).DocumentClient;
const databaseUrl = &amp;quot;dbs/&amp;quot; + process.env.APPSETTING_DOCDB_DB_ID;

var client = new documentClient(process.env.APPSETTING_DOCDB_ENDPOINT, { &amp;quot;masterKey&amp;quot;: process.env.APPSETTING_DOCDB_AUTHKEY });

function sendTextMessage(sender, text, context) {
  getDataFromDocDB().then(function (value) {
    var msgAll = value[0].randomDocument.beer + &amp;quot; &amp;quot; + value[1].randomDocument.msg;
    var postData = JSON.stringify({
      recipient: sender,
      message: {
        &amp;quot;attachment&amp;quot;:{
          &amp;quot;type&amp;quot;:&amp;quot;template&amp;quot;,
          &amp;quot;payload&amp;quot;:{
            &amp;quot;template_type&amp;quot;:&amp;quot;button&amp;quot;,
            &amp;quot;text&amp;quot;:msgAll,
            &amp;quot;buttons&amp;quot;:[
              {
                &amp;quot;type&amp;quot;:&amp;quot;web_url&amp;quot;,
                &amp;quot;url&amp;quot;:value[0].randomDocument.url,
                &amp;quot;title&amp;quot;:&amp;quot;詳しく&amp;quot;
              }
            ]
          }
        }
      }
    });
    var req = https.request({
      hostname: &#39;graph.facebook.com&#39;,
      port: 443,
      path: &#39;/v2.6/me/messages&#39;,
      method: &#39;POST&#39;,
      headers: {
        &#39;Content-Type&#39;: &#39;application/json&#39;,
        &#39;Authorization&#39;: &#39;Bearer &#39; + process.env.APPSETTING_FB_PAGE_TOKEN
      }
    });
    req.write(postData);
    req.end();
  }).catch(function(err){
    context.log(err);
  });  
}

function getRandomDoc(sprocUrl){
  return new Promise(function (resolve, reject) {
    const sprocParams = {};
    client.executeStoredProcedure(sprocUrl, sprocParams, function(err, result, responseHeaders) {
      if (err) {
        reject(err);
      }
      if (result) {
        resolve(result);
      }
    });
  });
}

var results = {
  beer: function getBeer() {
    var collectionUrl = databaseUrl + &amp;quot;/colls/beer&amp;quot;;
    var sprocUrl = collectionUrl + &amp;quot;/sprocs/GetRandomDoc&amp;quot;;
    return getRandomDoc(sprocUrl).then(function (result) {
      return result;
    });
  },
  eom: function getEom() {
    var collectionUrl = databaseUrl + &amp;quot;/colls/eom&amp;quot;;
    var sprocUrl = collectionUrl + &amp;quot;/sprocs/GetRandomDoc&amp;quot;;
    return getRandomDoc(sprocUrl).then(function (result) {
      return result;
    });
  }
}

function getDataFromDocDB() {
  return Promise.all([results.beer(), results.eom()]);
}

module.exports = function (context, req) {
  messaging_evts = req.body.entry[0].messaging;
  for (i = 0; i &amp;lt; messaging_evts.length; i++) {
    evt = req.body.entry[0].messaging[i];
    sender = evt.sender;
    if (evt.message &amp;amp;&amp;amp; evt.message.text, context) {
      sendTextMessage(sender, evt.message.text, context);
    }
  }
  context.done();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;最下部のmodule.export以降のブロックで、webhookイベントを受け取ります&lt;/li&gt;
&lt;li&gt;それがmessageイベントで、テキストが入っていれば、sendTextMessage関数を呼びます

&lt;ul&gt;
&lt;li&gt;好みは聞いてないので、以降、受け取ったテキストが読まれることはありませんが&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sendTextMessage関数内、getDataFromDocDB関数呼び出しでDocumentDBへ問い合わせてビールと文末表現をランダムに取り出します

&lt;ul&gt;
&lt;li&gt;コレクション&amp;rdquo;beer&amp;rdquo;、&amp;rdquo;eom(end of message)&amp;ldquo;の構造はそれぞれこんな感じ
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;url&amp;quot;: &amp;quot;http://beertaster.org/beerstyle/web/001A.html#japanese&amp;quot;,
  &amp;quot;beer&amp;quot;: &amp;quot;酵母なし、ライトアメリカン・ウィートビール&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;bf3636c5-4284-4e7a-b587-9002a771f214&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;msg&amp;quot;: &amp;quot;はウマい&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;acd63222-2138-4e19-894e-dc85a950be64&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DocumentDBの2つのコレクションへの問い合わせが終わった後、Facebookへメッセージを返すため、逐次処理目的でJavaScriptの&lt;a href=&#34;http://azu.github.io/promises-book/&#34;&gt;Promise&lt;/a&gt;を使っています&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いかがでしょう。好みを聞かない気まぐれBotとはいえ、気軽に作れることがわかりました。ゼロからこの手のイベント処理を作るの、面倒ですものね。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;なお、Facebook Messenger API連動アプリの外部公開には、審査が必要とのことです&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>