<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure &middot; re-imagine</title>

    <meta name="description" content="my life is the sum of my imagination">

    <meta name="generator" content="Hugo 0.17" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="tmak_tw" />
    <meta name="twitter:title" content="Azure &middot; re-imagine">
    <meta name="twitter:description" content="my life is the sum of my imagination">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Azure &middot; re-imagine">
    <meta property="og:description" content="my life is the sum of my imagination">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://torumakabe.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="re-imagine" href="http://torumakabe.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://torumakabe.github.io/">re-imagine</a></h1>
            <h2 class="brand-tagline"> my life is the sum of my imagination </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/tmak_tw"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/ToruMakabe "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://torumakabe.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">22 Jan 2018, 22:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_rg_contributor/" class="post-title">Azureのリソースグループ限定 共同作成者をいい感じに作る</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="共同作成者は-ちょっと強い">共同作成者は、ちょっと強い</h2>

<p>Azureのリソースグループは、リソースを任意のグループにまとめ、ライフサイクルや権限の管理を一括して行える便利なコンセプトです。</p>

<p>ユースケースのひとつに、&rdquo;本番とは分離した開発向けリソースグループを作って、アプリ/インフラ開発者に開放したい&rdquo;、があります。新しい技術は試行錯誤で身につくので、こういった環境は重要です。</p>

<p>なのですが、このようなケースで、権限付与の落とし穴があります。</p>

<ul>
<li>サブスクリプション所有者が開発用リソースグループを作る</li>
<li>スコープを開発用リソースグループに限定し、開発者に対し共同作成者ロールを割り当てる</li>
<li>開発者はリソースグループ限定で、のびのび試行錯誤できて幸せ</li>
<li>開発者がスッキリしたくなり、リソースグループごとバッサリ削除 (共同作成者なので可能)</li>
<li>開発者にはサブスクリプションレベルの権限がないため、リソースグループを作成できない</li>
<li>詰む</li>
<li>サブスクリプション所有者が、リソースグループ作成と権限付与をやり直し</li>
</ul>

<p>共同作成者ロールから、リソースグループの削除権限だけを除外できると、いいんですが。そこでカスタムロールの出番です。リソースグループ限定、グループ削除権限なしの共同作成者を作ってみましょう。</p>

<h2 id="いい感じのカスタムロールを作る">いい感じのカスタムロールを作る</h2>

<p>Azureのカスタムロールは、個別リソースレベルで粒度の細かい権限設定ができます。ですが、やり過ぎると破綻するため、シンプルなロールを最小限作る、がおすすめです。</p>

<p>シンプルに行きましょう。まずはカスタムロールの定義を作ります。role.jsonとします。</p>

<pre><code>{
    &quot;Name&quot;: &quot;Resource Group Contributor&quot;,
    &quot;IsCustom&quot;: true,
    &quot;Description&quot;: &quot;Lets you manage everything except access to resources, but can not delete Resouce Group&quot;,
    &quot;Actions&quot;: [
        &quot;*&quot;
    ],
    &quot;NotActions&quot;: [
        &quot;Microsoft.Authorization/*/Delete&quot;,
        &quot;Microsoft.Authorization/*/Write&quot;,
        &quot;Microsoft.Authorization/elevateAccess/Action&quot;,
        &quot;Microsoft.Resources/subscriptions/resourceGroups/Delete&quot;
    ],
    &quot;AssignableScopes&quot;: [
        &quot;/subscriptions/your-subscriotion-id&quot;
    ]
}
</code></pre>

<p>組み込みロールの共同作成者をテンプレに、NotActionsでリソースグループの削除権限を除外しました。AssignableScopesでリソースグループを限定してもいいですが、リソースグループの数だけロールを作るのはつらいので、ここでは指定しません。後からロールを割り当てる時にスコープを指定します。</p>

<p>では、カスタムロールを作成します。</p>

<pre><code>$ az role definition create --role-definition ./role.json
</code></pre>

<p>出力にカスタムロールのIDが入っていますので、控えておきます。</p>

<pre><code>&quot;id&quot;: &quot;/subscriptions/your-subscriotion-id/providers/Microsoft.Authorization/roleDefinitions/your-customrole-id&quot;
</code></pre>

<h2 id="カスタムロールをユーザー-グループ-サービスプリンシパルに割り当てる">カスタムロールをユーザー、グループ、サービスプリンシパルに割り当てる</h2>

<p>次に、ユーザー/グループに先ほど作ったカスタムロールを割り当てます。スコープはリソースグループに限定します。</p>

<pre><code>$ az role assignment create --assignee-object-id your-user-or-group-object-id --role your-customrole-id --scope &quot;/subscriptions/your-subscriotion-id/resourceGroups/sample-dev-rg&quot;
</code></pre>

<p>サービスプリンシパル作成時に割り当てる場合は、以下のように。</p>

<pre><code>$ az ad sp create-for-rbac -n &quot;rgcontributor&quot; -p &quot;your-password&quot; --role your-customrole-id --scopes &quot;/subscriptions/your-subscriotion-id/resourceGroups/sample-dev-rg&quot;
</code></pre>

<p>余談ですが、&rdquo;az ad sp create-for-rbac&rdquo;コマンドはAzure ADアプリケーションを同時に作るため、別途アプリを作ってサービスプリンシパルと紐づける、という作業が要りません。</p>

<h2 id="試してみる">試してみる</h2>

<p>ログインして試してみましょう。サービスプリンシパルの例です。</p>

<pre><code>$ az login --service-principal -u &quot;http://rgcontributor&quot; -p &quot;your-password&quot; -t &quot;your-tenant-id&quot;
</code></pre>

<p>検証したサブスクリプションには多数のリソースグループがあるのですが、スコープで指定したものだけが見えます。</p>

<pre><code>$ az group list -o table
Name              Location    Status
----------------  ----------  ---------
sample-dev-rg  japaneast   Succeeded
</code></pre>

<p>このリソースグループに、VMを作っておきました。リストはしませんが、ストレージやネットワークなど関連リソースもこのグループにあります。</p>

<pre><code>$ az vm list -o table
Name              ResourceGroup     Location
----------------  ----------------  ----------
sampledevvm01     sample-dev-rg  japaneast
</code></pre>

<p>試しにリソースグループを作ってみます。サブスクリプションスコープの権限がないため怒られます。</p>

<pre><code>$ az group create -n rgc-poc-rg -l japaneast
The client 'aaaaa-bbbbb-ccccc-ddddd-eeeee' with object id 'aaaaa-bbbbb-ccccc-ddddd-eeeee' does not have authorization to perform action 'Microsoft.Resources/subscriptions/resourcegroups/write' over scope '/subscriptions/your-subscriotion-id/resourcegroups/rgc-poc-rg'.
</code></pre>

<p>リソースグループを消してみます。消すかい？ -&gt; y -&gt; ダメ、という、持ち上げて落とす怒り方です。</p>

<pre><code>$ az group delete -n sample-dev-rg
Are you sure you want to perform this operation? (y/n): y
The client 'aaaaa-bbbbb-ccccc-ddddd-eeeee' with object id 'aaaaa-bbbbb-ccccc-ddddd-eeeee' does not have authorization to perform action 'Microsoft.Resources/subscriptions/resourcegroups/delete' over scope '/subscriptions/your-subscriotion-id/resourcegroups/sample-dev-rg'.
</code></pre>

<h2 id="でもリソースグループのリソースを一括削除したい">でもリソースグループのリソースを一括削除したい</h2>

<p>でも、リソースグループは消せなくても、リソースをバッサリ消す手段は欲しいですよね。そんな時には空のリソースマネージャーテンプレートを、completeモードでデプロイすると、消せます。</p>

<p>空テンプレートを、empty.jsonとしましょう。</p>

<pre><code>{
    &quot;$schema&quot;: &quot;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&quot;,
    &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
    &quot;parameters&quot;: {},
    &quot;variables&quot;: {},
    &quot;resources&quot;: [],
    &quot;outputs&quot;: {}
}
</code></pre>

<p>破壊的空砲を打ちます。</p>

<pre><code>$ az group deployment create --mode complete -g sample-dev-rg --template-file ./empty.json
</code></pre>

<p>リソースグループは残ります。</p>

<pre><code>$ az group list -o table
Name              Location    Status
----------------  ----------  ---------
sample-dev-rg  japaneast   Succeeded
</code></pre>

<p>VMは消えました。リストしませんが、他の関連リソースもバッサリ消えています。</p>

<pre><code>$ az vm list -o table

</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">08 Jan 2018, 16:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/terraform_azure_sample_201801/" class="post-title">TerraformでAzure サンプル 2018/1版</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="サンプルのアップデート">サンプルのアップデート</h2>

<p>年末にリポジトリの大掃除をしていて、2年前に書いたTerraform &amp; Azureの<a href="http://torumakabe.github.io/post/azure_tf_fundamental_rules/">記事</a>に目が止まりました。原則はいいとして、<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample">サンプル</a>は2年物で腐りかけです。ということでアップデートします。</p>

<h2 id="インパクトの大きな変更点">インパクトの大きな変更点</h2>

<p>Terraformの、ここ2年の重要なアップデートは以下でしょうか。Azure視点で。</p>

<ol>
<li>BackendにAzure Blobを使えるようになった</li>
<li>Workspaceで同一コード・複数環境管理ができるようになった</li>
<li>対応リソースが増えた</li>
<li><a href="https://registry.terraform.io/">Terraform Module Registry</a>が公開された</li>
</ol>

<h2 id="更新版サンプルの方針">更新版サンプルの方針</h2>

<p>重要アップデートをふまえ、以下の方針で新サンプルを作りました。</p>

<h3 id="チーム-複数端末での運用">チーム、複数端末での運用</h3>

<p>BackendにAzure Blobがサポートされたので、チーム、複数端末でstateの共有がしやすくなりました。ひとつのプロジェクトや環境を、チームメンバーがどこからでも、だけでなく、複数プロジェクトでのstate共有もできます。</p>

<h3 id="workspaceの導入">Workspaceの導入</h3>

<p>従来は /dev /stage /prodなど、環境別にコードを分けて管理していました。ゆえに環境間のコード同期が課題でしたが、TerraformのWorkspace機能で解決しやすくなりました。リソース定義で ${terraform.workspace} 変数を参照するように書けば、ひとつのコードで複数環境を扱えます。</p>

<p>要件によっては、従来通り環境別にコードを分けた方がいいこともあるでしょう。環境間の差分が大きい、開発とデプロイのタイミングやライフサイクルが異なるなど、Workspaceが使いづらいケースもあるでしょう。その場合は無理せず従来のやり方で。今回のサンプルは「Workspaceを使ったら何ができるか？」を考えるネタにしてください。</p>

<h3 id="module-terraform-module-registryの活用">Module、Terraform Module Registryの活用</h3>

<p>TerraformのModuleはとても強力な機能なのですが、あーでもないこーでもないと、こだわり過ぎるとキリがありません。「うまいやり方」を見てから使いたいのが人情です。そこでTerraform Module Registryを活かします。お墨付きのVerifiedモジュールが公開されていますので、そのまま使うもよし、ライセンスを確認の上フォークするのもよし、です。</p>

<h3 id="リソースグループは環境ごとに準備し-管理をterraformから分離">リソースグループは環境ごとに準備し、管理をTerraformから分離</h3>

<p>AzureのリソースをプロビジョニングするTerraformコードの多くは、Azureのリソースグループを管理下に入れている印象です。すなわちdestroyするとリソースグループごとバッサリ消える。わかりやすいけど破壊的。</p>

<p>TerraformはApp ServiceやACIなどPaaS、アプリ寄りのリソースも作成できるようになってきたので、アプリ開発者にTerraformを開放したいケースが増えてきています。dev環境をアプリ開発者とインフラ技術者がコラボして育て、そのコードをstageやprodにデプロイする、など。</p>

<p>ところで。TerraformのWorkspaceは、こんな感じで簡単に切り替えられます。</p>

<pre><code>terraform workspace select prod
</code></pre>

<p>みなまで言わなくても分かりますね。悲劇はプラットフォーム側で回避しましょう。今回のサンプルではリソースグループをTerraform管理下に置かず、別途作成します。Terraformからはdata resourcesとしてRead Onlyで参照する実装です。環境別のリソースグループを作成し、dev環境のみアプリ開発者へ権限を付与します。</p>

<h2 id="サンプル解説">サンプル解説</h2>

<p>サンプルは<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample_201801">GitHub</a>に置きました。合わせてご確認ください。</p>

<p>このコードをapplyすると、以下のリソースが出来上がります。</p>

<ul>
<li>NGINX on Ubuntu Webサーバー VMスケールセット</li>
<li>VMスケールセット向けロードバランサー</li>
<li>踏み台サーバー</li>
<li>上記を配置するネットワーク (仮想ネットワーク、サブネット、NSG)</li>
</ul>

<h3 id="リポジトリ構造">リポジトリ構造</h3>

<p>サンプルのリポジトリ構造です。</p>

<pre><code>├── modules
│   ├── computegroup
│   │   ├── main.tf
│   │   ├── os
│   │   │   ├── outputs.tf
│   │   │   └── variables.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   ├── loadbalancer
│   │   ├── main.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   └── network
│       ├── main.tf
│       ├── outputs.tf
│       └── variables.tf
└── projects
    ├── project_a
    │   ├── backend.tf
    │   ├── main.tf
    │   ├── outputs.tf
    │   └── variables.tf
    └── shared
        ├── backend.tf
        ├── main.tf
        ├── outputs.tf
        └── variables.tf
</code></pre>

<p>/modulesには<a href="https://registry.terraform.io/browse?provider=azurerm">Terraform Module Registry</a>でVerifiedされているモジュールをフォークしたコードを入れました。フォークした理由は、リソースグループをdata resource化して参照のみにしたかったためです。</p>

<p>そして、/projectsに2つのプロジェクトを作りました。プロジェクトでリソースとTerraformの実行単位、stateを分割します。sharedで土台となる仮想ネットワークと踏み台サーバー関連リソース、project_aでVMスケールセットとロードバランサーを管理します。</p>

<p>このボリュームだとプロジェクトを分割する必然性は低いのですが、以下のケースにも対応できるように分けました。</p>

<ul>
<li>アプリ開発者がproject_a下でアプリ関連リソースに集中したい</li>
<li>性能観点で分割したい (Terraformはリソース量につれて重くなりがち)</li>
<li>有事を考慮し影響範囲を分割したい</li>
</ul>

<p>プロジェクト間では、stateをremote_stateを使って共有します。サンプルではsharedで作成した仮想ネットワークのサブネットIDを<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample_201801/blob/master/projects/shared/outputs.tf#L1">output</a>し、project_aで参照できるよう<a href="https://github.com/ToruMakabe/Terraform_Azure_Sample_201801/blob/master/projects/project_a/backend.tf.sample#L10">定義</a>しています。</p>

<h2 id="使い方">使い方</h2>

<h3 id="前提">前提</h3>

<ul>
<li>Linux、WSL、macOSなどbash環境の実行例です</li>
<li>SSHの公開鍵をTerraform実行環境の ~/.ssh/id_rsa.pub として準備してください</li>
</ul>

<h3 id="管理者向けのサービスプリンシパルを用意する">管理者向けのサービスプリンシパルを用意する</h3>

<p>インフラのプロビジョニングの主体者、管理者向けのサービスプリンシパルを用意します。リソースグループを作成できる権限が必要です。</p>

<p>もしなければ作成します。組み込みロールでは、サブスクリプションに対するContributorが妥当でしょう。<a href="https://www.terraform.io/docs/providers/azurerm/authenticating_via_service_principal.html">Terraformのドキュメント</a>も参考に。</p>

<pre><code>az ad sp create-for-rbac --role=&quot;Contributor&quot; --scopes=&quot;/subscriptions/SUBSCRIPTION_ID&quot;
</code></pre>

<p>出力されるappId、password、tenantを控えます。既存のサービスプリンシパルを使うのであれば、同情報を確認してください。</p>

<p>なお参考までに。Azure Cloud ShellなどAzure CLIが導入されている環境では、特に認証情報の指定なしでterraform planやapply時にAzureのリソースにアクセスできます。TerraformがCLIの認証トークンを<a href="https://github.com/terraform-providers/terraform-provider-azurerm/blob/master/azurerm/helpers/authentication/config.go">使う</a>からです。</p>

<p>そしてBackendをAzure Blobとする場合、Blobにアクセスするためのキーが別途必要です。ですが、残念ながらBackendロジックでキーを得る際に、このトークンが<a href="https://github.com/hashicorp/terraform/blob/master/backend/remote-state/azure/backend.go">使われません</a>。キーを明示することもできますが、Blobのアクセスキーは漏洩時のリカバリーが大変です。できれば直に扱いたくありません。</p>

<p>サービスプリンシパル認証であれば、Azureリソースへのプロビジョニング、Backendアクセスどちらも<a href="https://www.terraform.io/docs/backends/types/azurerm.html">対応できます</a>。これがこのサンプルでサービスプリンシパル認証を選んだ理由です。</p>

<h3 id="管理者の環境変数を設定する">管理者の環境変数を設定する</h3>

<p>Terraformが認証関連で必要な情報を環境変数で設定します。先ほど控えた情報を使います。</p>

<pre><code>export ARM_SUBSCRIPTION_ID=&quot;&lt;your subscription id&gt;&quot;
export ARM_CLIENT_ID=&quot;&lt;your servicce principal appid&gt;&quot;
export ARM_CLIENT_SECRET=&quot;&lt;your service principal password&gt;&quot;
export ARM_TENANT_ID=&quot;&lt;your service principal tenant&gt;&quot;
</code></pre>

<h3 id="workspaceを作る">Workspaceを作る</h3>

<p>開発(dev)/ステージング(stage)/本番(prod)、3つのWorkspaceを作る例です。</p>

<pre><code>terraform workspace new dev
terraform workspace new stage
terraform workspace new prod
</code></pre>

<h3 id="リソースグループを作る">リソースグループを作る</h3>

<p>まずWorkspace別にリソースグループを作ります。</p>

<pre><code>az group create -n tf-sample-dev-rg -l japaneast
az group create -n tf-sample-stage-rg -l japaneast
az group create -n tf-sample-prod-rg -l japaneast
</code></pre>

<p>リソースグループ名にはルールがあります。Workspace別にリソースグループを分離するため、Terraformのコードで ${terraform.workspace} 変数を使っているためです。この変数は実行時に評価されます。</p>

<pre><code>data &quot;azurerm_resource_group&quot; &quot;resource_group&quot; {
  name = &quot;${var.resource_group_name}-${terraform.workspace}-rg&quot;
}
</code></pre>

<p>${var.resource_group_name} は接頭辞です。サンプルではvariables.tfで&rdquo;tf-sample&rdquo;と指定しています。</p>

<p>次にBackend、state共有向けリソースグループを作ります。</p>

<pre><code>az group create -n tf-sample-state-rg -l japaneast
</code></pre>

<p>このリソースグループは、各projectのbackend.tfで指定しています。</p>

<pre><code>terraform {
  backend &quot;azurerm&quot; {
    resource_group_name  = &quot;tf-sample-state-rg&quot;
    storage_account_name = &quot;&lt;your storage account name&gt;&quot;
    container_name       = &quot;tfstate-project-a&quot;
    key                  = &quot;terraform.tfstate&quot;
  }
}
</code></pre>

<p>最後にアプリ開発者がリソースグループtf-sample-dev-rg、tf-sample-state-rgへアクセスできるよう、アプリ開発者向けサービスプリンシパルを作成します。</p>

<pre><code>az ad sp create-for-rbac --role=&quot;Contributor&quot; --scopes &quot;/subscriptions/&lt;your subscription id&gt;/resourceGroups/tf-sample-dev-rg&quot; &quot;/subscriptions/&lt;your subscription id&gt;/resourceGroups/tf-sample-state-rg&quot;
</code></pre>

<p>出力されるappId、password、tenantは、アプリ開発者向けに控えておきます。</p>

<h3 id="backendを準備する">Backendを準備する</h3>

<p>project別にストレージアカウントとコンテナーを作ります。tf-sample-state-rgに</p>

<ul>
<li>ストレージアカウント (名前は任意)</li>
<li>コンテナー *2 (tfstate-project-a, tfstate-shared)</li>
</ul>

<p>を作ってください。GUIでもCLIでも、お好きなやり方で。</p>

<p>その後、project_a/backend.tf.sample、shared/backend.tf.sampleをそれぞれbackend.tfにリネームし、先ほど作ったストレージアカウント名を指定します。以下はproject_a/backend.tf.sampleの例。</p>

<pre><code>terraform {
  backend &quot;azurerm&quot; {
    resource_group_name  = &quot;tf-sample-state-rg&quot;
    storage_account_name = &quot;&lt;your storage account name&gt;&quot;
    container_name       = &quot;tfstate-project-a&quot;
    key                  = &quot;terraform.tfstate&quot;
  }
}

data &quot;terraform_remote_state&quot; &quot;shared&quot; {
  backend = &quot;azurerm&quot;

  config {
    resource_group_name  = &quot;tf-sample-state-rg&quot;
    storage_account_name = &quot;&lt;your storage account name&gt;&quot;
    container_name       = &quot;tfstate-shared&quot;
    key                  = &quot;terraform.tfstateenv:${terraform.workspace}&quot;
  }
}
</code></pre>

<p>これで準備完了です。</p>

<h3 id="実行">実行</h3>

<p>Workspaceをdevに切り替えます。</p>

<pre><code>terraform workspace select dev
</code></pre>

<p>まずは土台となるリソースを作成するsharedから。</p>

<pre><code>cd shared
terraform init
terraform plan
terraform apply
</code></pre>

<p>土台となるリソースが作成されたら、次はproject_aを。</p>

<pre><code>cd ../project_a
terraform init
terraform plan
terraform apply
</code></pre>

<p>ここでは割愛しますが、dev向けサービスプリンシパルで認証しても、dev Workspaceではplan、apply可能です。</p>

<p>dev Workspaceでコードが育ったら、stage/prod Workspaceに切り替えて実行します。</p>

<pre><code>terraform workspace select stage
[以下devと同様の操作]
</code></pre>

<p>当然、dev向けサービスプリンシパルで認証している場合は、stage/prodでのplan、apply、もちろんdestroyも失敗します。stage/prod リソースグループにアクセスする権限がないからです。</p>

<h2 id="参考情報">参考情報</h2>

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/azure/terraform/">Terraform on Azure のドキュメント</a></li>
<li><a href="https://github.com/terraform-providers/terraform-provider-azurerm/tree/master/examples">サンプル集 on GitHub</a></li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">28 Nov 2017, 08:45</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azblob_golang/" class="post-title">Azure Blob アップローダーをGoで書いた、そしてその理由</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="azure-blob-アップローダーをgoで書いた">Azure Blob アップローダーをGoで書いた</h2>

<p>ふたつほど理由があり、GolangでAzure Blobのファイルアップローダーを書きました。</p>

<h2 id="ひとつめの理由-sdkが新しくなったから">ひとつめの理由: SDKが新しくなったから</h2>

<p>最近公式ブログで<a href="https://azure.microsoft.com/en-us/blog/preview-the-new-azure-storage-sdk-for-go-storage-sdks-roadmap/">紹介された</a>通り、Azure Storage SDK for Goが再設計され、プレビューが始まりました。GoはDockerやKubernetes、Terraformなど最近話題のプラットフォームやツールを書くのに使われており、ユーザーも増えています。再設計してもっと使いやすくしてちょ、という要望が多かったのも、うなずけます。</p>

<p>ということで、新しいSDKで書いてみたかった、というのがひとつめの理由です。ローカルにあるファイルを読んでBlobにアップロードするコードは、こんな感じ。</p>

<pre><code>package main

import (
	&quot;context&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/url&quot;
	&quot;os&quot;

	&quot;github.com/Azure/azure-storage-blob-go/2016-05-31/azblob&quot;
)

var (
	accountName    string
	accountKey     string
	containerName  string
	fileName       string
	blockSize      int64
	blockSizeBytes int64
)

func init() {
	flag.StringVar(&amp;accountName, &quot;account-name&quot;, &quot;&quot;, &quot;(Required) Storage Account Name&quot;)
	flag.StringVar(&amp;accountKey, &quot;account-key&quot;, &quot;&quot;, &quot;(Required) Storage Account Key&quot;)
	flag.StringVar(&amp;containerName, &quot;c&quot;, &quot;&quot;, &quot;(Required - short option) Blob Container Name&quot;)
	flag.StringVar(&amp;containerName, &quot;container-name&quot;, &quot;&quot;, &quot;(Required) Blob Container Name&quot;)
	flag.StringVar(&amp;fileName, &quot;f&quot;, &quot;&quot;, &quot;(Required - short option) Upload filename&quot;)
	flag.StringVar(&amp;fileName, &quot;file&quot;, &quot;&quot;, &quot;(Required) Upload filename&quot;)
	flag.Int64Var(&amp;blockSize, &quot;b&quot;, 4, &quot;(Optional - short option) Blob Blocksize (MB) - From 1 to 100. Max filesize depends on this value. Max filesize = Blocksize * 50,000 blocks&quot;)
	flag.Int64Var(&amp;blockSize, &quot;blocksize&quot;, 4, &quot;(Optional) Blob Blocksize (MB) - From 1 to 100. Max filesize depends on this value. Max filesize = Blocksize * 50,000 blocks&quot;)
	flag.Parse()

	if (blockSize &lt; 1) || (blockSize) &gt; 100 {
		fmt.Println(&quot;Blocksize must be from 1MB to 100MB&quot;)
		os.Exit(1)
	}
	blockSizeBytes = blockSize * 1024 * 1024
}

func main() {
	file, err := os.Open(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	fileSize, err := file.Stat()
	if err != nil {
		log.Fatal(err)
	}

	u, _ := url.Parse(fmt.Sprintf(&quot;https://%s.blob.core.windows.net/%s/%s&quot;, accountName, containerName, fileName))
	blockBlobURL := azblob.NewBlockBlobURL(*u, azblob.NewPipeline(azblob.NewSharedKeyCredential(accountName, accountKey), azblob.PipelineOptions{}))

	ctx := context.Background()

	fmt.Println(&quot;Uploading block blob...&quot;)
	putBlockList, err := azblob.UploadStreamToBlockBlob(ctx, file, fileSize.Size(), blockBlobURL,
		azblob.UploadStreamToBlockBlobOptions{
			BlockSize: blockSizeBytes,
			Progress: func(bytesTransferred int64) {
				fmt.Printf(&quot;Uploaded %d of %d bytes.\n&quot;, bytesTransferred, fileSize.Size())
			},
		})
	if err != nil {
		log.Fatal(err)
	}
	_ = putBlockList // Avoid compiler's &quot;declared and not used&quot; error

	fmt.Println(&quot;Done&quot;)
}
</code></pre>

<p>以前のSDKと比較し、スッキリ書けるようになりました。進行状況もPipelineパッケージを使って、楽に取れるようになっています。ブロック分割のロジックを書く必要もなくなりました。ブロックサイズを指定すればOK。</p>

<p>ちなみにファイルサイズがブロックサイズで割り切れると最終ブロックの転送がエラーになるバグを見つけたのですが、<a href="https://github.com/Azure/azure-storage-blob-go/issues/8">修正してもらった</a>ので、次のリリースでは解決していると思います。</p>

<h2 id="ふたつめの理由-レガシー対応">ふたつめの理由: レガシー対応</h2>

<p>Blobのアップロードが目的であれば、Azure CLIをインストールすればOK。以上。なのですが、残念ながらそれができないケースがあります。</p>

<p>たとえば。Azure CLI(2.0)はPythonで書かれています。なので、Pythonのバージョンや依存パッケージの兼ね合いで、「ちょっとそれウチのサーバーに入れるの？汚さないでくれる？ウチはPython2.6よ」と苦い顔をされることが、あるんですね。気持ちはわかります。立場の数だけ正義があります。Docker?その1歩半くらい前の話です。</p>

<p>ですが、オンプレのシステムからクラウドにデータをアップロードして処理したい、なんていうニーズが急増している昨今、あきらめたくないわけであります。どうにか既存環境に影響なく入れられないものかと。そこでシングルバイナリーを作って、ポンと置いて、動かせるGoは尊いわけです。</p>

<p>ファイルのアップロードだけでなく、Azureにちょっとした処理を任せたい、でもそれはいじりづらいシステムの上なのねん、って話は、結構多いんですよね。ということでシングルバイナリーを作って、ポンと置いて、動かせるGoは尊いわけです。大事なことなので2回書きました。</p>

<p>C#やNode、Python SDKと比較してGoのそれはまだ物足りないところも多いわけですが、今後注目ということで地道に盛り上がっていこうと思います。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">08 Oct 2017, 10:30</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_vpngw_act_act_perf/" class="post-title">Azure VPN Gateway Active/Active構成のスループット検証(リージョン内)</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="動機">動機</h2>

<p><a href="https://kogelog.com/">焦げlogさん</a>で、とても興味深いエントリを拝見しました。</p>

<ul>
<li><a href="https://kogelog.com/2017/10/06/20171006-01/">Azure VPN ゲートウェイをアクティブ/アクティブ構成した場合にスループットが向上するのか検証してみました</a></li>
</ul>

<p>確かにActive/Active構成にはスループット向上を期待したくなります。その伸びが測定されており、胸が熱くなりました。ですが、ちょっと気になったのは</p>

<blockquote>
<p>※それと、VpnGw3 よりも VpnGw2 のほうがスループットがよかったのが一番の謎ですが…</p>
</blockquote>

<p>ここです。VPN GatewayのSKU、VpnGw3とVpnGw2には小さくない価格差があり、その基準はスループットです。ここは現状を把握しておきたいところ。すごく。</p>

<p>そこで、焦げlogさんの検証パターンの他に、追加で検証しました。それは同一リージョン内での測定です。リージョン内でVPNを張るケースはまれだと思いますが、リージョンが分かれることによる</p>

<ul>
<li>遅延</li>
<li>リージョン間通信に関するサムシング</li>
</ul>

<p>を除き、VPN Gateway自身のスループットを測定したいからです。焦げlogさんの測定は東日本/西日本リージョン間で行われたので、その影響を確認する価値はあるかと考えました。</p>

<h2 id="検証方針">検証方針</h2>

<ul>
<li>同一リージョン(東日本)に、2つのVNETを作る</li>
<li>それぞれのVNETにVPN Gatewayを配置し、接続する</li>
<li>比較しやすいよう、焦げlogさんの検証と条件を合わせる

<ul>
<li>同じ仮想マシンサイズ: DS3_V2</li>
<li>同じストレージ: Premium Storage Managed Disk</li>
<li>同じOS: Ubuntu 16.04</li>
<li>同じツール: ntttcp</li>
<li>同じパラメータ: ntttcp -r -m 16,*,<IP> -t 300</li>
</ul></li>
<li>送信側 VNET1 -&gt; 受信側 VNET2 のパターンに絞る</li>
<li>スループットのポテンシャルを引き出す検証はしない</li>
</ul>

<h2 id="結果">結果</h2>

<h3 id="vpngw1-650mbps">VpnGW1(650Mbps)</h3>

<table>
<thead>
<tr>
<th align="left">パターン　</th>
<th align="left">送信側GW構成　　　　　</th>
<th align="left">受信側GW構成　　　　　　　　</th>
<th align="right">送信側スループット　</th>
<th align="right">　受信側スループット</th>
<th align="right">　スループット平均</th>
<th align="right">　パターン1との比較</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">パターン1　</td>
<td align="left">Act/Stb</td>
<td align="left">Act/Stb</td>
<td align="right">677.48Mbps</td>
<td align="right">676.38Mbps</td>
<td align="right">676.93Mbps</td>
<td align="right">-</td>
</tr>

<tr>
<td align="left">パターン2　</td>
<td align="left">Act/Stb</td>
<td align="left">Act/Act</td>
<td align="right">674.34Mbps</td>
<td align="right">673.85Mbps</td>
<td align="right">674.10Mbps</td>
<td align="right">99%</td>
</tr>

<tr>
<td align="left">パターン3　</td>
<td align="left">Act/Act</td>
<td align="left">Act/Act</td>
<td align="right">701.19Mbps</td>
<td align="right">699.91Mbps</td>
<td align="right">700.55Mbps</td>
<td align="right">103%</td>
</tr>
</tbody>
</table>

<h3 id="vpngw2-1gbps">VpnGW2(1Gbps)</h3>

<table>
<thead>
<tr>
<th align="left">パターン　</th>
<th align="left">送信側GW構成　　　　　</th>
<th align="left">受信側GW構成　　　　　　　　</th>
<th align="right">送信側スループット　</th>
<th align="right">　受信側スループット</th>
<th align="right">　スループット平均</th>
<th align="right">　パターン1との比較</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">パターン1　</td>
<td align="left">Act/Stb</td>
<td align="left">Act/Stb</td>
<td align="right">813.09Mbps</td>
<td align="right">805.60Mbps</td>
<td align="right">809.35Mbps</td>
<td align="right">-</td>
</tr>

<tr>
<td align="left">パターン2　</td>
<td align="left">Act/Stb</td>
<td align="left">Act/Act</td>
<td align="right">1.18Gbps</td>
<td align="right">1.18Gbps</td>
<td align="right">1.18Gbps</td>
<td align="right">149%</td>
</tr>

<tr>
<td align="left">パターン3　</td>
<td align="left">Act/Act</td>
<td align="left">Act/Act</td>
<td align="right">2.03Gbps</td>
<td align="right">2.02Gbps</td>
<td align="right">2.03Gbps</td>
<td align="right">256%</td>
</tr>
</tbody>
</table>

<h3 id="vpngw3-1-25gbps">VpnGW3(1.25Gbps)</h3>

<table>
<thead>
<tr>
<th align="left">パターン　</th>
<th align="left">送信側GW構成　　　　　</th>
<th align="left">受信側GW構成　　　　　　　　</th>
<th align="right">送信側スループット　</th>
<th align="right">　受信側スループット</th>
<th align="right">　スループット平均</th>
<th align="right">　パターン1との比較</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">パターン1　</td>
<td align="left">Act/Stb</td>
<td align="left">Act/Stb</td>
<td align="right">958.56Mbps</td>
<td align="right">953.72Mbps</td>
<td align="right">956.14Mbps</td>
<td align="right">-</td>
</tr>

<tr>
<td align="left">パターン2　</td>
<td align="left">Act/Stb</td>
<td align="left">Act/Act</td>
<td align="right">1.39Gbps</td>
<td align="right">1.39Gbps</td>
<td align="right">1.39Gbps</td>
<td align="right">149%</td>
</tr>

<tr>
<td align="left">パターン3　</td>
<td align="left">Act/Act</td>
<td align="left">Act/Act</td>
<td align="right">2.19Gbps</td>
<td align="right">2.19Gbps</td>
<td align="right">2.19Gbps</td>
<td align="right">234%</td>
</tr>
</tbody>
</table>

<h3 id="sku視点-パターン1-act-stb-to-act-stb">SKU視点 パターン1(Act/Stb to Act/Stb)</h3>

<table>
<thead>
<tr>
<th align="left">SKU　</th>
<th align="right">　スループット平均</th>
<th align="right">　VpnGw1との比較</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">VpnGw1　</td>
<td align="right">676.93Mbps</td>
<td align="right">-</td>
</tr>

<tr>
<td align="left">VpnGw2　</td>
<td align="right">809.35Mbps</td>
<td align="right">119%</td>
</tr>

<tr>
<td align="left">VpnGw3　</td>
<td align="right">956.14Mbps</td>
<td align="right">141%</td>
</tr>
</tbody>
</table>

<h3 id="sku視点-パターン2-act-stb-to-act-act">SKU視点 パターン2(Act/Stb to Act/Act)</h3>

<table>
<thead>
<tr>
<th align="left">SKU　</th>
<th align="right">　スループット平均</th>
<th align="right">　VpnGw1との比較</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">VpnGw1　</td>
<td align="right">674.10Mbps</td>
<td align="right">-</td>
</tr>

<tr>
<td align="left">VpnGw2　</td>
<td align="right">1.18Gbps</td>
<td align="right">179%</td>
</tr>

<tr>
<td align="left">VpnGw3　</td>
<td align="right">1.39Gbps</td>
<td align="right">211%</td>
</tr>
</tbody>
</table>

<h3 id="sku視点-パターン3-act-act-to-act-act">SKU視点 パターン3(Act/Act to Act/Act)</h3>

<table>
<thead>
<tr>
<th align="left">SKU　</th>
<th align="right">　スループット平均</th>
<th align="right">　VpnGw1との比較</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">VpnGw1　</td>
<td align="right">700.55Mbps</td>
<td align="right">-</td>
</tr>

<tr>
<td align="left">VpnGw2　</td>
<td align="right">2.03Gbps</td>
<td align="right">297%</td>
</tr>

<tr>
<td align="left">VpnGw3　</td>
<td align="right">2.19Gbps</td>
<td align="right">320%</td>
</tr>
</tbody>
</table>

<h2 id="考察と推奨">考察と推奨</h2>

<ul>
<li>リージョン間の遅延やサムシングを除くと、SKUによるGatewayのスループット差は測定できる

<ul>
<li>Act/Actでないパターン1(Act/Stb to Act/Stb)で、その差がわかる</li>
</ul></li>
<li>公式ドキュメントの通り、GatewayのAct/Act構成は可用性向上が目的であるため、スループットの向上はボーナスポイントと心得る

<ul>
<li>期待しちゃうのが人情ではありますが</li>
<li>VpnGw2がコストパフォーマンス的に最適という人が多いかもしれませんね 知らんけど</li>
</ul></li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">05 Sep 2017, 12:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://torumakabe.github.io/post/azure_blobevent/" class="post-title">Azure Event GridでBlobイベントを拾う</a>

                        <p class="post-meta">
                            
                            
                                under 
                                
                                <a class="post-category post-category-Azure" href="http://torumakabe.github.io//categories/azure">Azure</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="event-gridがblobに対応">Event GridがBlobに対応</h2>

<p>Event GridがBlobのイベントを拾えるように<a href="https://azure.microsoft.com/en-us/blog/announcing-azure-blob-storage-events-preview/">なりました</a>。まだ申請が必要なプライベートプレビュー段階ですが、使い勝手の良いサービスに育つ予感がします。このたび検証する機会があったので、共有を。</p>

<p>プレビュー中なので、今後仕様が変わるかもしれないこと、不具合やメンテナンス作業の可能性などは、ご承知おきください。</p>

<h2 id="event-gridがblobに対応して何がうれしいか">Event GridがBlobに対応して何がうれしいか</h2>

<p>Event Gridは、Azureで発生した様々なイベントを検知してWebhookで通知するサービスです。カスタムトピックも作成できます。</p>

<p>イベントの発生元をPublisherと呼びますが、このたびPublisherとしてAzureのBlobがサポートされました。Blobの作成、削除イベントを検知し、Event GridがWebhookで通知します。通知先はHandlerと呼びます。Publisherとそこで拾うイベント、Handlerを紐づけるのがSubscriptionです。Subscriptionにはフィルタも定義できます。</p>

<p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ff3644c9-58ab-4729-8939-66a83ab0605d.png" alt="コンセプト" title="Concept" /></p>

<p>Event Gridに期待する理由はいくつかあります。</p>

<ul>
<li>フィルタ

<ul>
<li>特定のBlobコンテナーにあるjpegファイルの作成イベントのみで発火させる、なんてことができます</li>
</ul></li>
<li>信頼性

<ul>
<li>リトライ機能があるので、Handlerが一時的に黙ってしまっても対応できます</li>
</ul></li>
<li>スケールと高スループット

<ul>
<li><a href="https://docs.microsoft.com/ja-jp/azure/azure-functions/functions-bindings-storage-blob#blob-storage-triggers-and-bindings">Azure Functions Blobトリガー</a>のようにHandler側で定期的にスキャンする必要がありません。これまではファイル数が多いとつらかった</li>
<li>具体的な数値はプレビュー後に期待しましょう</li>
</ul></li>
<li>ファンアウト

<ul>
<li>ひとつのイベントを複数のHandlerに紐づけられます</li>
</ul></li>
<li>Azureの外やサードパーティーとの連携

<ul>
<li>Webhookでシンプルにできます</li>
</ul></li>
</ul>

<h2 id="前提条件">前提条件</h2>

<ul>
<li>Publisherに設定できるストレージアカウントはBlobストレージアカウントのみです。汎用ストレージアカウントは対応していません</li>
<li>現時点ではWest Central USリージョンのみで提供しています</li>
<li>プライベートプレビューは申請が必要です</li>
</ul>

<p>Azure CLIの下記コマンドでプレビューに申請できます。</p>

<pre><code>az provider register --namespace  Microsoft.EventGrid
az feature register --name storageEventSubscriptions --namespace Microsoft.EventGrid
</code></pre>

<p>以下のコマンドで確認し、statusが&rdquo;Registered&rdquo;であれば使えます。</p>

<pre><code>az feature show --name storageEventSubscriptions --namespace Microsoft.EventGrid
</code></pre>

<h2 id="使い方">使い方</h2>

<p>ストレージアカウントの作成からSubscription作成までの流れを追ってみましょう。</p>

<p>リソースグループを作ります。</p>

<pre><code>$ az group create -n blobeventpoc-rg -l westcentralus
</code></pre>

<p>Blobストレージアカウントを作ります。</p>

<pre><code>$ az storage account create -n blobeventpoc01 -l westcentralus -g blobeventpoc-rg --sku Standard_LRS --kind BlobStorage --access-tier Hot
</code></pre>

<p>ではいよいよEvent GridのSubscriptionを作ります。</p>

<pre><code>$ az eventgrid resource event-subscription create --endpoint https://requestb.in/y4jgj2x0 -n blobeventpocsub-jpg --prov
ider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types Microsoft.Storage.BlobCreated
-g blobeventpoc-rg --resource-name blobeventpoc01 --subject-ends-with jpg
</code></pre>

<p>以下はパラメーターの補足です。</p>

<ul>
<li>&ndash;endpoint

<ul>
<li>Handlerのエンドポイントを指定します。ここではテストのために<a href="https://requestb.in/">RequestBin</a>に作ったエンドポイントを指定します</li>
</ul></li>
<li>&ndash;included-event-types

<ul>
<li>イベントの種類をフィルタします。Blobの削除イベントは不要で、作成のみ拾いたいため、Microsoft.Storage.BlobCreatedを指定します</li>
</ul></li>
<li>&ndash;subject-ends-with

<ul>
<li>対象ファイルをフィルタします。Blob名の末尾文字列がjpgであるBlobのみイベントの対象にしました</li>
</ul></li>
</ul>

<p>では作成したストレージアカウントにBlobコンテナーを作成し、jpgファイルを置いてみましょう。テストには<a href="https://azure.microsoft.com/ja-jp/features/storage-explorer/">Azure Storage Explorer</a>が便利です。</p>

<p>RequestBinにWebhookが飛び、中身を見られます。スキーマの確認は<a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-event-overview#event-schema">こちら</a>から。</p>

<pre><code>[{
  &quot;topic&quot;: &quot;/subscriptions/xxxxx-xxxxx-xxxxx-xxxxx/resourceGroups/blobeventpoc-rg/providers/Microsoft.Storage/storageAccounts/blobeventpoc01&quot;,
  &quot;subject&quot;: &quot;/blobServices/default/containers/images/blobs/handsomeyoungman.jpg&quot;,
  &quot;eventType&quot;: &quot;Microsoft.Storage.BlobCreated&quot;,
  &quot;eventTime&quot;: &quot;2017-09-02T02:25:15.2635962Z&quot;,
  &quot;id&quot;: &quot;f3ff6b96-001e-001d-6e92-23bdea0684d2&quot;,
  &quot;data&quot;: {
    &quot;api&quot;: &quot;PutBlob&quot;,
    &quot;clientRequestId&quot;: &quot;f3cab560-8f85-11e7-bad1-53b58c70ab53&quot;,
    &quot;requestId&quot;: &quot;f3ff6b96-001e-001d-6e92-23bdea000000&quot;,
    &quot;eTag&quot;: &quot;0x8D4F1A9D8A6703A&quot;,
    &quot;contentType&quot;: &quot;image/jpeg&quot;,
    &quot;contentLength&quot;: 42497,
    &quot;blobType&quot;: &quot;BlockBlob&quot;,
    &quot;url&quot;: &quot;https://blobeventpoc01.blob.core.windows.net/images/handsomeyoungman.jpg&quot;,
    &quot;sequencer&quot;: &quot;0000000000000BAB0000000000060986&quot;,
    &quot;storageDiagnostics&quot;: {
      &quot;batchId&quot;: &quot;f3a538cf-5b88-4bbf-908a-20a37c65e238&quot;
    }
  }
}]
</code></pre>

<p>.jpgだけじゃなくて.jpegも使われるかもしれませんね。ということで、エンドポイントが同じでフィルタ定義を変えたSubscriptionを追加します。&ndash;subject-ends-withをjpegとします。</p>

<pre><code>$ az eventgrid resource event-subscription create --endpoint https://requestb.in/y4jgj2x0 -n blobeventpocsub-jpeg --pro
vider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types Microsoft.Storage.BlobCreated -
g blobeventpoc-rg --resource-name blobeventpoc01 --subject-ends-with jpeg
</code></pre>

<p>すると、拡張子.jpegのファイルをアップロードしても発火しました。</p>

<pre><code>[{
  &quot;topic&quot;: &quot;/subscriptions/xxxxx-xxxxx-xxxxx-xxxxx/resourceGroups/blobeventpoc-rg/providers/Microsoft.Storage/storageAccounts/blobeventpoc01&quot;,
  &quot;subject&quot;: &quot;/blobServices/default/containers/images/blobs/handsomeyoungman.jpeg&quot;,
  &quot;eventType&quot;: &quot;Microsoft.Storage.BlobCreated&quot;,
  &quot;eventTime&quot;: &quot;2017-09-02T02:36:33.827967Z&quot;,
  &quot;id&quot;: &quot;e8b036ee-001e-00e7-4994-23740d06225b&quot;,
  &quot;data&quot;: {
    &quot;api&quot;: &quot;PutBlob&quot;,
    &quot;clientRequestId&quot;: &quot;883ff7e0-8f87-11e7-bad1-53b58c70ab53&quot;,
    &quot;requestId&quot;: &quot;e8b036ee-001e-00e7-4994-23740d000000&quot;,
    &quot;eTag&quot;: &quot;0x8D4F1AB6D1B24F6&quot;,
    &quot;contentType&quot;: &quot;image/jpeg&quot;,
    &quot;contentLength&quot;: 42497,
    &quot;blobType&quot;: &quot;BlockBlob&quot;,
    &quot;url&quot;: &quot;https://blobeventpoc01.blob.core.windows.net/images/handsomeyoungman.jpeg&quot;,
    &quot;sequencer&quot;: &quot;0000000000000BAB0000000000060D42&quot;,
    &quot;storageDiagnostics&quot;: {
      &quot;batchId&quot;: &quot;9ec5c091-061d-4111-ad82-52d9803ce373&quot;
    }
  }
}]
</code></pre>

<h2 id="azure-functionsに画像リサイズファンクションを作って連携してみる">Azure Functionsに画像リサイズファンクションを作って連携してみる</h2>

<p>Gvent Grid側の動きが確認できたので、サンプルアプリを作って検証してみましょう。Azure Functions上に画像ファイルのサイズを変えるHandlerアプリを作ってみます。</p>

<h3 id="概要">概要</h3>

<p>当初想定したのは、ひとつのファンクションで、トリガーはEventGrid、入出力バインドにBlob、という作りでした。ですが、以下のように設計を変えました。</p>

<p><img src="https://raw.githubusercontent.com/ToruMakabe/Images/master/blobevent-function-bindings.png" alt="Bindings" title="Bindings" /></p>

<p>Using <a href="https://functions-visualizer.azurewebsites.net/">Azure Functions Bindings Visualizer</a></p>

<p>その理由はEvent Grid Blobイベントのペイロードです。Blobファイル名がURLで渡されます。Azure FunctionsのBlob入出力バインド属性、&rdquo;path&rdquo;にURLは使えません。使えるのはコンテナー名+ファイル名です。</p>

<p>入出力バインドを使わず、アプリのロジック内でStorage SDKを使って入出力してもいいのですが、Azure Functionsの魅力のひとつは宣言的にトリガーとバインドを定義し、アプリをシンプルに書けることなので、あまりやりたくないです。</p>

<p>そこでイベントを受けてファイル名を取り出してQueueに入れるファンクションと、そのQueueをトリガーに画像をリサイズするファンクションに分けました。</p>

<p>なお、この悩みはAzureの開発チームも認識しており、Functions側で対応する方針とのことです。</p>

<h3 id="handler">Handler</h3>

<p>C#(csx)で、Event GridからのWebhookを受けるHandlerを作ります。PublisherがBlobの場合、ペイロードにBlobのURLが入っていますので、そこからファイル名を抽出します。そして、そのファイル名をQueueに送ります。ファンクション名はBlobEventHandlerとしました。なおEventGridTriggerテンプレートは、現在は[試験段階]シナリオに入っています。</p>

<p>[run.csx]</p>

<pre><code>#r &quot;Newtonsoft.json&quot;
using Microsoft.Azure.WebJobs.Extensions.EventGrid;

public static void Run(EventGridEvent eventGridEvent, out string outputQueueItem, TraceWriter log)
{
    string imageUrl = eventGridEvent.Data[&quot;url&quot;].ToString();
    outputQueueItem = System.IO.Path.GetFileName(imageUrl);
}
</code></pre>

<p>Event GridのWebJobs拡張向けパッケージを指定します。</p>

<p>[project.json]</p>

<pre><code>{
&quot;frameworks&quot;: {
  &quot;net46&quot;:{
    &quot;dependencies&quot;: {
      &quot;Microsoft.Azure.WebJobs.Extensions.EventGrid&quot;: &quot;1.0.0-beta1-10006&quot;
    }
  }
 }
}
</code></pre>

<p>トリガーとバインドは以下の通りです。</p>

<p>[function.json]</p>

<pre><code>{
  &quot;bindings&quot;: [
    {
      &quot;type&quot;: &quot;eventGridTrigger&quot;,
      &quot;name&quot;: &quot;eventGridEvent&quot;,
      &quot;direction&quot;: &quot;in&quot;
    },
    {
      &quot;type&quot;: &quot;queue&quot;,
      &quot;name&quot;: &quot;outputQueueItem&quot;,
      &quot;queueName&quot;: &quot;imagefilename&quot;,
      &quot;connection&quot;: &quot;AzureWebJobsStorage&quot;,
      &quot;direction&quot;: &quot;out&quot;
    }
  ],
  &quot;disabled&quot;: false
}
</code></pre>

<h3 id="resizer">Resizer</h3>

<p>Queueをトリガーに、Blobから画像ファイルを取り出し、縮小、出力するファンクションを作ります。ファンクション名はResizerとしました。</p>

<p>[run.csx]</p>

<pre><code>using ImageResizer;

public static void Run(string myQueueItem, Stream inputBlob, Stream outputBlob, TraceWriter log)
{
  var imageBuilder = ImageResizer.ImageBuilder.Current;
  var size = imageDimensionsTable[ImageSize.Small];

  imageBuilder.Build(inputBlob, outputBlob,
    new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);

}

public enum ImageSize
{
  Small
}

private static Dictionary&lt;ImageSize, Tuple&lt;int, int&gt;&gt; imageDimensionsTable = new Dictionary&lt;ImageSize, Tuple&lt;int, int&gt;&gt;()
{
  { ImageSize.Small, Tuple.Create(100, 100) }
};
</code></pre>

<p>ImageResizerのパッケージを指定します。</p>

<p>[project.json]</p>

<pre><code>{
&quot;frameworks&quot;: {
  &quot;net46&quot;:{
    &quot;dependencies&quot;: {
      &quot;ImageResizer&quot;: &quot;4.1.9&quot;
    }
  }
 }
}
</code></pre>

<p>トリガーとバインドは以下の通りです。{QueueTrigger}メタデータで、QueueのペイロードをBlobのpathに使います。ペイロードにはファイル名が入っています。</p>

<p>また、画像を保存するBlobストレージアカウントの接続文字列は、環境変数BLOB_IMAGESへ事前に設定しています。なお、リサイズ後の画像を格納するBlobコンテナーは、&rdquo;images-s&rdquo;として別途作成しました。コンテナー&rdquo;images&rdquo;をイベントの発火対象コンテナーとして、Subscriptionにフィルタを定義したいからです。</p>

<p>[function.json]</p>

<pre><code>{
  &quot;bindings&quot;: [
    {
      &quot;name&quot;: &quot;myQueueItem&quot;,
      &quot;type&quot;: &quot;queueTrigger&quot;,
      &quot;direction&quot;: &quot;in&quot;,
      &quot;queueName&quot;: &quot;imagefilename&quot;,
      &quot;connection&quot;: &quot;AzureWebJobsStorage&quot;
    },
    {
      &quot;name&quot;: &quot;inputBlob&quot;,
      &quot;type&quot;: &quot;blob&quot;,
      &quot;path&quot;: &quot;images/{QueueTrigger}&quot;,
      &quot;connection&quot;: &quot;BLOB_IMAGES&quot;,
      &quot;direction&quot;: &quot;in&quot;
    },
    {
      &quot;name&quot;: &quot;outputBlob&quot;,
      &quot;type&quot;: &quot;blob&quot;,
      &quot;path&quot;: &quot;images-s/{QueueTrigger}&quot;,
      &quot;connection&quot;: &quot;BLOB_IMAGES&quot;,
      &quot;direction&quot;: &quot;out&quot;
    }
  ],
  &quot;disabled&quot;: false
}
</code></pre>

<p>Handlerの準備が整いました。最後にEvent GridのSubscriptionを作成します。Azure FunctionsのBlobEventHandlerのトークン付きエンドポイントは、ポータルの[統合]で確認できます。</p>

<pre><code>$ az eventgrid resource event-subscription create --endpoint &quot;https://blobeventpoc.azurewebsites.net/admin/exte
nsions/EventGridExtensionConfig?functionName=BlobEventHandler&amp;code=tokenTOKEN1234567890==&quot; -n blobeventpocsub-jpg --provider-namespace Microsoft.Storage --resource-type storageAccounts --included-event-types &quot;Microsoft.Storage.BlobCreated&quot; -g blobeventpoc-rg --resource-name blobeventpoc01 --subject-begins-with &quot;/blobServices/default/containers/images/&quot;  --subject-ends-with jpg
</code></pre>

<p>これで、コンテナー&rdquo;images&rdquo;にjpgファイルがアップロードされると、コンテナー&rdquo;images-s&rdquo;に、リサイズされた同じファイル名の画像ファイルが出来上がります。</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 8</span>
    
      <a href="/categories/azure/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://torumakabe.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
